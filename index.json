[
{
	"uri": "https://cordier-info.github.io/cours_python/cours1/",
	"title": "Bases",
	"tags": [],
	"description": "",
	"content": "Introduction Python est un langage de programmation interprété développé par Guido van Rossum en 1989. Langage impératif de haut-niveau doté d\u0026rsquo;une syntaxe simple, Python s\u0026rsquo;adapte à de nombreux contextes grâce à sa modularité ; une importante librairie de modules et packages permet en effet d\u0026rsquo;étendre ses capacités.\n Shell et IDE Python possède son propre shell (interface en ligne de commande) : l\u0026rsquo;utilisateur entre une commande Python qui est interprétée immédiatement lorsque Entrée est tapée.\nAu lancement, le shell Python, poli, se présente :\nPython 3.7.3 (default, Mar 27 2019, 16:54:48)\n[Clang 4.0.1 (tags/RELEASE_401/final)] :: Anaconda, Inc. on darwin\nType \u0026quot;help\u0026quot;, \u0026quot;copyright\u0026quot;, \u0026quot;credits\u0026quot; or \u0026quot;license\u0026quot; for more information.\n\u0026gt;\u0026gt;\u0026gt;\nLes 3 chevrons sont l\u0026rsquo;invite (ou prompt) où les commandes seront écrites.\nIPython, un shell plus évolué, utilise [1] comme invite (où le chiffre dans les crochets s\u0026rsquo;incrémente à chaque commande).\nPour sortir du shell classique, il faut taper exit(), et exit ou quit pour sortie du shell IPython.\nOn peut tout à fait exécuter des commandes Python une à une dans le shell.\nUne commande qui renvoie un résultat est appelée expression, alors qu\u0026rsquo;une commande qui ne renvoie rien est une instruction.\nToute fonction est une expression, mais certaines ont en plus un effet sur l\u0026rsquo;environnement comme print() qui permet d\u0026rsquo;afficher une chaîne de caractère dans le shell ou dans un fichier (elle retourne aussi la valeur None qui est omise dans ce cas par le shell).\n5 + 2 7\na = 7 print(a) 7\nPour les projets plus complexes nécessitant d\u0026rsquo;enchaîner les instructions, on écrit l\u0026rsquo;ensemble de ces commandes (le programme) dans un éditeur de texte et on enregistre le fichier avec une extension .py.\nOn demande alors à l\u0026rsquo;interprète Python d\u0026rsquo;exécuter l\u0026rsquo;ensemble du script en utilisant la commande python nom_du_fichier.py dans le shell de l\u0026rsquo;OS. Les différents retours dans le shell ne sont alors plus affichés, seuls les effets ont un\u0026hellip; effet.\nLe plus simple pour coder est d\u0026rsquo;utiliser un environnement de travail (IDE pour \u0026ldquo;integrated development environment\u0026rdquo;) qui combine un éditeur de code et un shell Python permettant d\u0026rsquo;exécuter le script entier ou une partie directement via l\u0026rsquo;interface.\nCela fait parti du bon usage en informatique de commenter son code afin qu\u0026rsquo;il soit plus facilement compréhensible et donc partageable. En Python, les commentaires sont placés derrière un hastag # les rendant invisible pour l\u0026rsquo;interprète.\n import math # pour pouvoir utiliser pi (commentaire ignoré par l\u0026#39;interprète) r = 3 # rayon 2*math.pi*r # circonférence du cercle de rayon r  Installation L\u0026rsquo;installation d'Anaconda rend disponible les principales bibliothèques scientifiques Python ainsi que le preformant IDE Spyder ou encore Jupyterlab (très intéressant pour les présentations de projets car associant dans une même interface texte et code pour former un notebook).\nLes oraux de Centrale \u0026ldquo;Mathématiques 2\u0026rdquo; et \u0026ldquo;Physique-chimie 2\u0026rdquo; utilisent l\u0026rsquo;IDE Pyzo. Les ordinateurs du lycée ont les IDE EduPython et Pyzo disponibles sur le serveur S:\\. Vous pouvez aussi utiliser pour dépanner l\u0026rsquo;IDE en ligne Repl.it depuis le repository du TP.\n Types de nombres Les nombres sont parmi les objets Python les plus basiques.\nIl en existe 3 types :\n les entiers (type : int).\nIls n\u0026rsquo;ont pas de limite de taille (à part la mémoire vive disponible de l\u0026rsquo;ordinateur).\nL\u0026rsquo;arithmétique sur les entiers est exacte. les nombres à virgule flottante (type : float).\nCe sont des nombres décimaux. Ils sont stockés en binaire jusqu\u0026rsquo;à une certaine précision (l\u0026rsquo;équivalent de 15 ou 16 chiffres en écriture décimale sur la plupart des systèmes). Ils ne peuvent donc en général pas représenter fidèlement un nombre réel. On reviendra sur ce point plus tard.\nRq : c\u0026rsquo;est un point \u0026ldquo;.\u0026rdquo; et non une virgule \u0026ldquo;,\u0026rdquo; qui sépare la partie entière de la partie décimale en Python. les nombres complexes (type : complex).\nNombre de type 4+3j (la partie imaginaire est notée j en python).\n4+3j peut aussi s\u0026rsquo;écrire complex(4,3).  Taper un nombre dans le shell Python renvoie simplement la nombre :\n5 5\n5. 5.0\n0.10 0.1\n0.0001 0.0001\n0.0000999 9.99e-05\nLes nombres inférieurs à 0,0001 sont écrits en notation scientifique.\nOn peut changer le type d\u0026rsquo;un nombre (conversion) en utilisant les fonctions natives int(), float et complex :\nfloat(5) 5.0\nint(5.2) 5\nint(5.9) 5\nOn remarque que la transformation en entier d\u0026rsquo;un nombre décimal prend en fait sa partie entière.\n complex(3.) (3+0j)\ncomplex(0.,3.) 3j\n  Arithmétique de base Les opérateurs de base utilisables en Python sont :\n   symbole opération     + addition   - soustraction   * multiplication   / division décimale   // division euclidienne   % modulo (reste de la division euclidienne)   ** puissance    Règles de priorités des opérations :\n** \u0026gt; { * ,/ , // , % } \u0026gt; { + , - }\n6 / 2 / 4 # comme 3 / 4 0.75\n6 / (2 / 4) # comme 6 / 0.5 12.0\n2**2**3 # comme 2**(2**3) == 2**8 256\n(2**2)**3 # comme 4**3 64\nLes opérations de priorité égale sont évaluées de gauche à droite à l\u0026rsquo;exception des puissances (ce qui correspond à évaluer de haut en bas les exposants).\n  Méthodes et attributs En Python, tout, y compris un nombre, est un objet ayant certains attributs accessibles grâce à la notation \u0026ldquo;point\u0026rdquo; : \u0026lt;objet\u0026gt;.\u0026lt;attribut\u0026gt;. Certains attributs sont des simples valeurs : les nombres complexes ont par exemple les attributs real et imag qui sont les parties réelles et imaginaires d\u0026rsquo;un nombre complexe.\n(3+4j).imag 4.0\nD\u0026rsquo;autres attributs sont des méthodes : des fonctions qui modifient leur objet d\u0026rsquo;une façon ou d\u0026rsquo;une autre.\nPar exemple, les nombres complexes ont la méthode conjugate qui retourne le complexe conjugué :\n(3+4j).conjugate() (3-4j)\n  Fonctions mathématiques round et abs sont deux fonctions proposées par défaut (natives).\nabs retourne la valeur absolue d\u0026rsquo;un nombre entier ou décimal, ou le module d\u0026rsquo;un nombre complexe (c\u0026rsquo;est un exemple de polymorphisme : comportement différent en fonction du type de l\u0026rsquo;argument).\nabs(-7.2) 7.2\nabs(3+4j) 5.0\nround arrondi un nombre décimal à l\u0026rsquo;entier le plus proche (attention, la convention utilisée lorsque la décimale vaut 5 est l\u0026rsquo;arrondi bancaire ou arrondi au pair le plus proche : au-dessus lorsque la partie entière est impaire et en dessous lorsqu\u0026rsquo;elle est paire).\nround(7.6) 8\nround(7.5) 8\nround(8.5) 8\nPython est un langage d\u0026rsquo;une grande modularité : des fonctionnalités supplémentaires sont accessibles en important des modules ou des packages qui ne sont pas chargés par défaut (ce qui permet de ne pas encombrer la mémoire).\nBeaucoup de fonctions mathématiques utiles peuvent ainsi être ajoutées grâce au module math, importé grâce à la déclaration import math.\nimport math math.exp(-1.5) 0.22313016014842982\nmath.cos(0) 1.0\nmath.sqrt(9) 3.0\nL\u0026rsquo;ensemble des fonctions disponibles dans le module sont répertoriées dans sa documentation en ligne et les plus utiles sont dans le tableau suivant (les angles des fonctions trigonométriques sont supposés en radians) :\n   nom de la fonction signification nom de la fonction signification     math.sqrt(x) $$\\sqrt{x}$$ math.atan(x) $$\\arctan (x)$$   math.exp(x) $$e^x$$ math.sinh(x) $$\\sinh (x)$$   math.log(x) $$\\ln (x)$$ math.cosh(x) $$\\cosh (x)$$   math.log(x,b) $$\\log_b(x)$$ math.tanh(x) $$\\tanh (x)$$   math.log10(x) $$\\log_{10}(x)$$ math.asinh(x) $$\\text{arsinh} (x)$$   math.sin(x) $$\\sin (x)$$ math.acosh(x) $$\\text{arcosh} (x)$$   math.cos(x) $$\\cos (x)$$ math.atanh(x) $$\\text{artanh} (x)$$   math.tan(x) $$\\tan (x)$$ math.hypot(x,y) norme euclidienne $$\\sqrt{x^2+y^2}$$   math.asin(x) $$\\arcsin (x)$$ math.degrees(x) convertit x des radians aux degrés   math.acos(x) $$\\arccos (x)$$ math.radians(x) convertit x des degrés aux radians    Le module math propose aussi deux attributs très utiles : math.pi et math.e qui donnent les valeurs de $\\pi$ et $e$.\nIl est possible d\u0026rsquo;importer le module math par la commande from math import * afin d\u0026rsquo;accéder à ses fonctions directement :\nfrom math import * cos(pi) -1.0\nBien que cela puisse être pratique pour des petites interactions avec le shell, ce n\u0026rsquo;est pas recommandé pour des programmes plus conséquent car cela peut générer confusions et conflits de noms.\nOn peut bien sûr composer les fonctions :\nmath.degrees(math.acos(math.sqrt(3)/2)) 30.000000000000004\nNotons que le nombre affiché diffère du résultat exact attendu $\\arccos(\\sqrt{3}/2)=30°$. C\u0026rsquo;est dû au codage machine des flottants qui ne permet qu\u0026rsquo;une précision limité.\n  Variables Lorsqu\u0026rsquo;un objet, comme un float, est créé dans un programme Python, une certaine place en mémoire lui est allouée. Cette place est repérée par une adresse dont la valeur peut être obtenue grâce à la fonction id().\nid(3.7) 4387417928\nIl est beaucoup plus pratique de pouvoir récupérer une valeur en mémoire grâce à un petit nom plutôt que par son adresse. C\u0026rsquo;est à ça que servent les variables. Une variable est liée à un objet grâce à une affectation et identifie cet objet pour les calculs suivants.\na = 3 b = -0.1 a * b -0.30000000000000004\nÀ nouveau, le résultat décimal affiché est un peu étrange, toujours à cause de la précision limité des flottants (environ 16 chiffres significatifs seulement)\u0026hellip;\nSi on veut pouvoir utiliser le résultat de a * b pour des calculs ultérieurs, il faut lui aussi le stocker en mémoire.\nc = a * b c -0.30000000000000004\nContrairement à des langages à typage statique comme le C, une variable n\u0026rsquo;a pas besoin d\u0026rsquo;être déclarée en Python. On parle alors de typage dynamique. Mais il faut néanmoins initialiser la valeur de la variable pour ne pas provoquer d\u0026rsquo;erreur. Le type de la variable est induit au moment de cette première affectation.\n3+x NameError: name 'x' is not defined\nOn peut interroger le type d\u0026rsquo;une variable avec la fonction type() :\ntype(c) float\n Règles sur les noms de variables :\n ils sont sensibles à la casse (minuscule ou majuscule) ils peuvent contenir n\u0026rsquo;importe quelles lettres ou chiffres et le tiret-bas \u0026ldquo;_\u0026rdquo; mais ne doivent pas commencer par un chiffre. certains noms sont interdits (attention en particulier à lambda) :  and assert break class continue def del elif else except finally for from global if import in is lambda nonlocal not or pass print raise return try while yield\nIl est important pour la lisibilité de son code de donner les noms les plus explicites possibles aux variables. Les rapports de jury le répète tous les ans\u0026hellip;\n Rapport 2019 de l\u0026rsquo;épreuve de Centrale par exemple :\n Des noms de variables explicites aident à la compréhension du code. De trop nombreux candidats utilisent des noms de variables quelconques (a, b, c\u0026hellip;) ce qui nuit à la compréhension du programme. La clarté du programme (en particulier le choix des noms de variables) ainsi que la présence de commentaires opportuns sont prises en compte dans l’évaluation.\n  Une affectation ne retourne rien (c\u0026rsquo;est une instruction) mais a un effet sur la mémoire : l\u0026rsquo;adresse de la variable est modifiée à chaque nouvelle affectation. C\u0026rsquo;est ce qui rend possible les réaffectations à partir de la variable elle-même.\nid(a) 4304751488\nid(a+1) 4304751520\na = a + 1 id(a) 4304751520\nCes types de réaffectation sont si fréquents qu\u0026rsquo;il existe une notation raccourcie : +=, -=, *=, /=, //=, %=.\nAinsi, a += 1 équivaut à a = a + 1 et b /= 5 équivaut à b = b/5.\n Python permet d'affecter plusieurs variables simultanément (en parallèle) :\na , b = 3.2 , -2 a 3.2\nb -2\nComment faire si on veut permuter les valeurs auxquelles sont liées deux variables ? Dès qu\u0026rsquo;on écrit a = b, la valeur initiale de a est perdue et si on commence par b = a, c\u0026rsquo;est la valeur initiale de b qui est perdue. Il faudrait donc utiliser une variable temporaire et écrire : tmp = a, a = b et b = tmp.\nMais l\u0026rsquo;affectation parallèle de Python va nous permettre d\u0026rsquo;être plus élégants. Il suffit en effet d\u0026rsquo;une petite ligne :\na , b = b , a a -2\nb 3.2\nL\u0026rsquo;affectation parallèle repose sur le packing et l\u0026rsquo;unpacking de tuples, mais on verra ça dans un prochain cours.\n  Comparaison et logique Les différents comparateurs utilisables en Python sont :\n   comparateur signification     == égal à   != différent de   \u0026gt; supérieur à   \u0026lt; inférieur à   \u0026gt;= supérieur ou égal à   \u0026lt;= inférieur ou égal à    Le résultat d\u0026rsquo;une comparaison est un objet booléen (type bool) qui a deux valeurs possibles : True ou False.\n7 == 8 False\n4 \u0026gt;= 3.8 True\na = 4 \u0026lt; 3 type(a) bool\nIl faut bien noter la différence entre = qui affecte une valeur à une variable et == qui compare deux valeurs.\nLa précision finie des nombres flottants rend leur comparaison dangereuse :\n a , b = 0.01 , 0.1**2 a == b False\nEn effet :\na 0.01\nb 0.010000000000000002\nLes comparaisons peuvent être modifiées et enchaînées grâce aux opérateurs logiques and (et), or (ou inclusif), et not (non).\n7.0 \u0026gt; 4 and -1 \u0026gt;= 0 False\n5 \u0026lt; 4 or 1 != 0 True\nDans des expressions composées comme celles-ci, les opérateurs de comparaison sont évalués en premier puis vient le tour des opérateurs logiques.\nnot 7.5 \u0026lt; 0.9 or 4 == 4 True\nnot (7.5 \u0026lt; 0.9 or 4 == 4) False\nUn nombre entier ou décimal peut être considéré comme un booléen dans des expressions logiques. Dans ce cas, tout nombre différent de zéro est considéré comme vrai.\n18.7 and 5 \u0026lt; 8 True\nOn parle d'égalité de valeurs (testée par l\u0026rsquo;opérateur ==) lorsque deux variables référencent la même valeur et d'égalité physique lorsqu\u0026rsquo;il s\u0026rsquo;agit du même objet ayant un emplacement mémoire unique. L\u0026rsquo;égalité physique implique bien sûr l\u0026rsquo;égalité de valeurs.\n Pour tester l\u0026rsquo;égalité physique de deux variables, on utilise l\u0026rsquo;opérateur is.\na = 257 b = 257 a == b True\na is b False\na is 257 False\nid(a) 4396188400\nid(b) 4396188144\nid(257) 4396188272\nc = 256 d = 256 c is d True\nc is 256 True\nid(c) 4304759584\nid(d) 4304759584\nid(256) 4304759584\nPython garde en cache les petits entiers (de -5 à 256 généralement), souvent utilisés, pour améliorer les performances. a et b sont alors tout deux liés à l\u0026rsquo;espace mémoire de l\u0026rsquo;objet 256. Ils correspondent donc bien au même objet physique.\n  Type None Enfin, pour nous aider à traiter les cas où aucune valeur définie n\u0026rsquo;est possible (soit parceque la valeur conduirait à une erreur où n\u0026rsquo;aurait pas de sens), Python propose d\u0026rsquo;utiliser la valeur None de type NoneType.\nC\u0026rsquo;est particulièrement utile pour éviter des valeurs par défaut arbitraireS comme 0 ou -99 pour des données manquantes ou corrompues.\nOn en verra un exemple d\u0026rsquo;utilisation dans le TP 3.\n"
},
{
	"uri": "https://cordier-info.github.io/tp_python/tp2/",
	"title": "TP2 : Bases et Chaînes",
	"tags": [],
	"description": "",
	"content": "TP2 : Cours 1 et 2 Lien vers le repository GitHub du TP : https://classroom.github.com/a/Prcpdubn\nExercice 1 Expliquer le résultat surprenant du code suivant dans exo_1.md :\nd = 8 e = 2 from math import * sqrt(d ** e) 16.88210319127114\n Exercice 2 Combien de fois une feuille de papier d\u0026rsquo;épaisseur $e = 0,1$ mm doit-elle être pliée pour atteindre la Lune ?\nÉcrire dans exo_2.py un script Python qui calcule et imprime la réponse sans utiliser de boucle.\n  Exercice 3 Le world geodesic system (WGS) ou système géodésique mondial établit des références pour les coordonnées et dimensions du globe utilisées par le système de positionnement par satellite GPS.\nDans sa version WGS-84, la géoïde terrestre est approximée par un ellipsoïde de révolution aplati dont le demi grand axe $a$ et le demi petit axe $c$ vallent :\n$a = 6378137,0\\text{ m}$\n$c = 6356752,314245\\text{ m}$.\nLa formule donnant la surface d\u0026rsquo;un sphéroïde aplati est :\n$ S=2\\pi a^2\\left(1+\\frac{1-e^2}{e}\\text{artanh}(e)\\right) $ avec $e^2=1-\\frac{c^2}{a^2}$\nUtiliser cette formule dans un script Python (exo_3.py) pour déterminer et imprimer la superficie de la Terre et comparer au résultat obtenu en approximant la Terre comme une sphère de rayon 6371 km.\nExercice 4 Écrire dans exo_4.py une expression d\u0026rsquo;une seule ligne permettant de déterminer si une chaîne de caractère est un palindrome.\n Exercice 5 Les variables suivantes ont été définies dans exo_5.py :\nk = 1.380649E-23 k_unité = \u0026#39;J/K\u0026#39; e = 1.602176634E-19 e_unité = \u0026#39;C\u0026#39; N_A = 6.02214076E23 N_A_unité = \u0026#39;mol-1\u0026#39; c = 299792458 c_unité = \u0026#39;m/s\u0026#39; Compléter le code pour afficher les résultats ci-dessous (utiliser la méthode de formattage) :\ne = 0.0000000000000000001602176634 C\nk = 1.381e-23 J/K\nN_A = 602214075999999987023872 mol-1\nc = 000299792458 m/s\n"
},
{
	"uri": "https://cordier-info.github.io/cours_python/cours2/",
	"title": "Chaînes de caractères",
	"tags": [],
	"description": "",
	"content": "Les chaînes de caractères Définir une chaîne de caractères Une chaîne de caractères (type str pour l\u0026rsquo;anglais string) est une suite ordonnée de caractères.\nPour définir une variable de ce type, il suffit d\u0026rsquo;encadrer des caractères par ' ou \u0026quot; :\nsalutation = \u0026#34;Bonjour, monsieur \u0026#34; nom = \u0026#39;Raoul\u0026#39; Des chaînes de caractères peuvent être concaténées (= assemblées) en utilisant l\u0026rsquo;opérateur + :\n\u0026#34;abc\u0026#34; + \u0026#39;def\u0026#39; 'abcdef'\nsalutation + nom 'Bonjour, monsieur Raoul'\nOn peut aussi utiliser l\u0026rsquo;opérateur * pour répéter plusieurs fois la même chaîne (dupliquer) :\n\u0026#39;a\u0026#39;*10 'aaaaaaaaaa'\n\u0026#39;-o-\u0026#39;*5 '-o--o--o--o--o-'\nEt on peut combiner * et + (en utilisant des parenthèses) :\n(\u0026#39;a\u0026#39; * 4 + \u0026#39;B\u0026#39;) * 3 'aaaaBaaaaBaaaaB'\n Une chaîne vide est définie simplement comme '' ou \u0026quot;\u0026quot;.\nEnfin, la fonction str() convertit un objet (nombre entier, nombre décimal, liste, etc.) en chaîne de caractères :\nstr(42) '42'\nstr(3.4e5) '340000.0'\nstr(3.4e20) '3.4e+20'\n La fonction native len() permet de connaître le nombre de caractère d\u0026rsquo;une chaîne de caractères (bien noter que les espaces, les fins de ligne ou encore la ponctuation sont aussi des caractères) :\nlen(salutation) 18\n  Caractères d\u0026rsquo;échappement Comme on peut utiliser '' ou \u0026quot;\u0026quot; pour définir une chaîne, on peut intégrer une citation dans une citation :\n\u0026#39;Et il cria : \u0026#34;Mais pourquoi ?\u0026#34;\u0026#39; 'Et il cria : \u0026quot;Mais pourquoi ?\u0026quot;'\nEt pour ajouter encore un niveau de citation, ou pour sauter une ligne, ou pour mettre une apostrophe si notre chaîne est déjà encadrée par des apostrophes, ou pour\u0026hellip; ?\nOn utilise les caractères d\u0026rsquo;échappement, introduits par un backslash \u0026ldquo;\\\u0026quot; !\nExemples :\nphrase = \u0026#34;Et il cria : \\\u0026#34;Mais pourquoi ?\\\u0026#34;\u0026#34; phrase 'Et il cria : \u0026quot;Mais pourquoi ?\u0026quot;'\nprint(phrase) Et il cria : \u0026quot;Mais pourquoi ?\u0026quot;\n\u0026#39;C\\\u0026#39;est donc pour ça...\u0026#39; \u0026quot;C'est donc pour ça...\u0026quot;\nmatières = \u0026#39;Maths\\nPhysique\\nAnglais\u0026#39; matières 'Maths\\nPhysique\\nAnglais'\nprint(matières) Maths\nPhysique\nAnglais\n   Caractères d\u0026rsquo;échappement courants Signification     \\' apostrophe (')   \\\u0026quot; guillemets (\u0026quot;)   \\n fin de ligne (LF)   \\r retour chariot (CR)   \\t tabulation   \\b retour arrière (backspace)   \\\\ le caractère backslash   \\u,\\U,\\N{} caractère unicode   \\x caractères codés sur un seul byte    Si vous voulez pouvoir écrire une chaîne de caractères sans qu\u0026rsquo;un caractère d\u0026rsquo;échappement n\u0026rsquo;ait d\u0026rsquo;effet :\nchainebrute = r\u0026#34;Pour une nouvelle ligne, on utilise \\n.\u0026#34; chainebrute 'Pour une nouvelle ligne, on utilise \\\\n.'\nprint(chainebrute) Pour une nouvelle ligne, on utilise \\n.\nCela peut s\u0026rsquo;avérer pratique pour écrire le chemin d\u0026rsquo;un fichier sous windows mais écrire des slash à la place (comme sous Unix) est une autre possibilité :\nr\u0026#39;C:\\repertoire\\fichier.txt\u0026#39; 'C:\\\\repertoire\\\\fichier.txt'\nSi on doit utiliser \\n de manière répétée, le triple guillemet peut nous sauver. Encadré par ''' ou \u0026quot;\u0026quot;\u0026quot;, plus besoin de \\n pour une nouvelle ligne :\na = \u0026#34;\u0026#34;\u0026#34;un deux trois\u0026#34;\u0026#34;\u0026#34; print(a) un\ndeux\ntrois\nLes strings sont composés de caractères Unicode dans Python 3. Unicode est un standard décrivant plus de 100 000 caractères. Chaque caractère se voit assigner un nombre qui est ensuite encodé comme une suite de bytes (qui peuvent être de 8 bits pour le codage UTF-8 le plus répandu et utilisé par Python, de 16 bits, ou de 32 bits). On a ainsi :\n\u0026#39;\\u00E9\u0026#39; == \u0026#39;\\N{LATIN SMALL LETTER E WITH ACUTE}\u0026#39; == \u0026#39;\\xE9\u0026#39; True\n\\x permet d\u0026rsquo;appeler par leur code les 256 premiers caractères (premier byte).\n\u0026#39;\\x43\\x61\\x66\\xE9\u0026#39; 'Café'\nCela permet de comprendre ce que Python retourne lorsqu\u0026rsquo;on entre l\u0026rsquo;expression suivante :\n\u0026#39;prépa ST\\b\\bTSI\u0026#39; 'prépa ST\\x08\\x08TSI'\nEn effet, le retour arrière \\b a le code \\x08 (c\u0026rsquo;est le huitième caractère).\nprint(\u0026#39;prépa ST\\b\\bTSI\u0026#39;) prépa TSI\n  Indexation et slicing Indexer une chaîne permet d\u0026rsquo;accéder à un caractère individuel de la chaîne. L\u0026rsquo;indice correspond à la position du caractère. Une chaîne de caractère est un exemple de séquence et comme pour toutes les séquences, l'indice du premier élément est 0 et l\u0026rsquo;indice du dernier élément d\u0026rsquo;une chaîne de n caractères est donc n-1.\nLe caractère est retourné dans une chaîne de longueur 1.\na = \u0026#39;Lycée Vieljeux\u0026#39; a[0] 'L'\na[6] 'V'\nLes indices positifs comptent dans le sens de la lecture. Mais on peut aussi compter à partir de la fin en utilisant des indices négatifs commençant par -1.\na[-1] 'x'\na[-4] 'j'\nEssayer d\u0026rsquo;indexer en dehors de la chaîne lève une exception IndexError qui stoppe l\u0026rsquo;interprète.\nlen(a) 14\na[14] IndexError: string index out of range\n Le slicing (découpage) s[i:j] permet d\u0026rsquo;extraire des éléments de la chaîne ; il extrait une sous-chaîne limitée par les caractères ciblés par les deux indices, incluant l\u0026rsquo;indice i et excluant l\u0026rsquo;indice j.\nSi le premier indice est omis s[:j], il est supposé valoir 0. Si le deuxième est omis, le slicing s\u0026rsquo;étend jusqu\u0026rsquo;à la fin de la chaîne.\na[2:9] 'cée Vie'\na[:5] 'Lycée'\na[6:] 'Vieljeux'\na[:] 'Lycée Vieljeux'\nCes règles assurent qu\u0026rsquo;une sous-chaîne est longue de j-i caractères (pour des j et i positifs) et que s[:i] + s[i:] == s.\nOn peut alors récupérer une tranche de longueur r avec s[i:i+r].\nb = \u0026#39;PrépaTSIdeVieljeux\u0026#39; b[:5] 'Prépa'\nb[5:8] 'TSI'\nb[10:] 'Vieljeux'\n Contrairement à l\u0026rsquo;indexation, un slicing en dehors des limites ne lève pas d\u0026rsquo;erreur.\n b[10:20] 'Vieljeux'\nb[20:] ''\n Un troisième nombre (optionnel) dans un découpage donne un pas (qui vaut par défaut 1 s\u0026rsquo;il est omis) :\nb[::2] 'PéaSdVeju'\nb[1::2] 'rpTIeilex'\nb[-1:9:-1] 'xuejleiV'\nLe pas de -1 dans cette dernière expression correspond à une progression de droite à gauche. Cette découpe commence donc au dernier caractère (-1 en première position), avance vers la gauche caractère par caractère (-1 en dernière position) et s\u0026rsquo;arrête au caractère précédant le 9 dans ce sens, donc le caractère 10.\nRenverser une chaîne de caractères devient très simple :\na[::-1] 'xuejleiV eécyL'\n Pour tester si une chaîne contient une certaine sous-chaîne, on utilise l\u0026rsquo;opérateur in (attention à la casse).\n\u0026#39;Vie\u0026#39; in b True\n\u0026#39;vie\u0026#39; in b False\n  Méthodes liées aux chaînes Les chaînes sont des objets Python immuables, c.-à-d. qu\u0026rsquo;on ne peut pas réaffecter un caractère de la chaîne.\na[0] = \u0026#39;l\u0026#39; TypeError: 'str' object does not support item assignment\nOn peut \u0026ldquo;augmenter\u0026rdquo; une chaîne mais cela crée systématiquement une nouvelle chaîne.\na += \u0026#34; de la Rochelle\u0026#34; print(a) Lycée Vieljeux de la Rochelle\nb = \u0026#39;Léonce \u0026#39; + a[6:14] print(b) Léonce Vieljeux\n Beaucoup de méthodes permettent de manipuler et transformer les chaînes. On y a accès par la notation point \u0026ldquo;.\u0026rdquo;. Quelques méthodes utiles :\n   méthode description     center(longueur,sous-chaîne) Complète de part et d\u0026rsquo;autre la chaîne par la sous-chaîne pour que le résultat ait la taille longueur.   endswith(suffixe) Retourne True si la chaîne finit par la sous-chaîne suffixe.   startwith(préfixe) Retourne True si la chaîne commence par la sous-chaîne préfixe.   index(sous-chaîne) Retourne l\u0026rsquo;indice de début de la sous-chaîne dans le chaîne.   strip(cars) Retourne une copie de la chaîne où les éventuels caractères précisés par cars en début ou fin de chaîne sont retirés. Si cars est omis, ce sont les espaces éventuels qui sont retirés.   upper() Retourne une copie de la chaîne avec tous les caractères en majuscule.   lower() Retourne une copie de la chaîne avec tous les caractères en minuscule.   title() Retourne une copie de la chaîne où tous les mots commencent par une capitale et les autres caractères sont en minuscule.   replace(old,new) Retourne une copie de la chaîne où chaque sous-chaîne old est remplacée par la sous-chaîne new.   split(sep) Retourne une liste de sous-chaînes obtenues par découpe de la chaîne à chaque séparateur sep. Si sep n\u0026rsquo;est pas précisé, la découpe se fait sur les espaces.   join([list]) Utilise la chaîne comme un séparateur pour joindre les différentes chaînes inclues dans la liste.   isalpha() Retourne True si tous les caractères de la chaîne sont alphabétiques.   isdigit() Retourne True si tous les caractères de la chaîne sont des chiffres.     Comme ces méthodes retournent toutes une nouvelle chaîne, on peut les enchaîner.\nc = \u0026#39;--Prépa TSI du lycée Léonce Vieljeux\u0026#39; c.strip(\u0026#39;--\u0026#39;).upper().replace(\u0026#39;LÉONCE \u0026#39;,\u0026#39;\u0026#39;).center(51,\u0026#39;-\u0026#39;) '------------PRÉPA TSI DU LYCÉE VIELJEUX------------'\n Autres exemples d\u0026rsquo;utilisation des méthodes :\nd = \u0026#39;java python c++ fortran\u0026#39; d.isalpha() False\ne = d.title() e 'Java Python C++ Fortran'\nf = e.replace(\u0026#39; \u0026#39;,\u0026#39; !\\n\u0026#39;) + \u0026#39; !\u0026#39; f 'Java !\\nPython !\\nC++ !\\nFortran !'\nprint(f) Java !\nPython !\nC++ !\nFortran !\nf.index(\u0026#39;Python\u0026#39;) 7\nf[7:].startswith(\u0026#39;Py\u0026#39;) # \u0026#34;\\n\u0026#34; est compté comme un caractère unique.  True\nf[7:13].isalpha() True\ng = d.split(\u0026#39; \u0026#39;) g ['java', 'python', 'c++', 'fortran']\nh = \u0026#39; !\\n\u0026#39;.join(g) print(h, end = \u0026#39; !\u0026#39;) java !\npython !\nc++ !\nfortran !\n  La fonction print La fonction native print() prend en argument une liste d\u0026rsquo;objet et, de manière optionnelle, des arguments end et sep qui spécifient comment doit terminer la chaîne et quels caractères utiliser pour séparer les objets imprimés.\nnom, jour, mois = \u0026#39;Darwin\u0026#39;, 12, \u0026#39;février\u0026#39; print(nom,\u0026#39;est né le\u0026#39;,jour,mois,1809) Darwin est né le 12 février 1809\nprint(\u0026#39;C\\\u0026#39;est\u0026#39;,\u0026#39;tout\u0026#39;,\u0026#39;collé\u0026#39;,sep = \u0026#39;\u0026#39;,end = \u0026#39; !!!\\n\u0026#39;) C'esttoutcollé !!!\nprint(\u0026#39;a\u0026#39;) print(\u0026#39;b\u0026#39;) print() print(\u0026#39;c\u0026#39;) a\nb\n c\nSans argument, print imprime le caractère de fin de ligne \\n car c\u0026rsquo;est la valeur de l\u0026rsquo;argument end par défaut. Donc pour empêcher la fin de ligne après chaque appel de print, il faut donner une autre valeur à end comme end = ''.\nprint(\u0026#39;Pas de nouvelle ligne.\u0026#39;,end = \u0026#39; \u0026#39;) print(\u0026#39;La preuve !\u0026#39;) Pas de nouvelle ligne. La preuve !\nAvec un peu de pratique, on peut même utiliser print pour fabriquer des tableaux de texte :\nentête = \u0026#39;| Indice des prix des tulipes |\u0026#39; ligne = \u0026#39;+\u0026#39; + \u0026#39;-\u0026#39;*16 + \u0026#39;-\u0026#39;*13 + \u0026#39;+\u0026#39; print(ligne, entête, ligne, \u0026#39;| 23 févr. 1636 | 100 |\u0026#39;, \u0026#39;| 25 nov. 1636 | 673 |\u0026#39;, \u0026#39;| 1 févr. 1637 | 1366 |\u0026#39;, ligne, sep=\u0026#39;\\n\u0026#39;) +-----------------------------+ | Indice des prix des tulipes | +-----------------------------+ | 23 févr. 1636 | 100 | | 25 nov. 1636 | 673 | | 1 févr. 1637 | 1366 | +-----------------------------+    Formatage des chaînes de caractères Grâce à la méthode de chaînes de caractères .format(), la chaîne peut contenir la valeur d\u0026rsquo;une variable.\nLa syntaxe la plus simple est :\n\u0026#39;{} plus {} égale {}\u0026#39;.format(2,3,\u0026#39;cinq\u0026#39;) '2 plus 3 égale cinq'\nLes arguments de la méthode str.format() sont insérés à la place des accolades \u0026ldquo;{}\u0026rdquo; dans la chaîne principale str.\nUn nombre entre accolades se réfère à la position de l\u0026rsquo;objet passé à la méthode (on peut aussi utiliser des noms s\u0026rsquo;ils ont été affectés). Cela permet d\u0026rsquo;utiliser plusieurs fois le même argument.\nRq : la zone entre les accolades s\u0026rsquo;appelle champ de formatage.\n\u0026#39;{1} plus {0} égale {2}\u0026#39;.format(2,3,\u0026#39;cinq\u0026#39;) '3 plus 2 égale cinq'\n\u0026#39;{0} plus {0} égale {1}\u0026#39;.format(2,2+2) '2 plus 2 égale 4'\n\u0026#39;{nb1} plus {nb2} égale {rés}\u0026#39;.format(nb1 = 2,nb2 = 3,rés = \u0026#39;cinq\u0026#39;) '2 plus 3 égale cinq'\n On peut aussi spécifier une taille minimale à la chaîne qui sera insérée. Si la chaîne passée à la méthode est plus petite que la taille indiquée, elle est complétée par des espaces. La valeur de cette taille souhaitée est placée après un signe \u0026ldquo;:\u0026rdquo; dans l\u0026rsquo;accolade. La chaîne insérée est naturellement justifiée à gauche, comportement modifiable grâce à l\u0026rsquo;ajout de \u0026ldquo;\u0026gt;\u0026rdquo; ou \u0026ldquo;^\u0026rdquo;.\n\u0026#39;==={0:12}===\u0026#39;.format(\u0026#39;Python\u0026#39;) '===Python ==='\n\u0026#39;==={0:\u0026gt;12}===\u0026#39;.format(\u0026#39;Python\u0026#39;) '=== Python==='\n\u0026#39;==={0:^12}===\u0026#39;.format(\u0026#39;Python\u0026#39;) '=== Python ==='\n\u0026#39;==={0:2}===\u0026#39;.format(\u0026#39;Python\u0026#39;) # Si la taille de la chaîne insérée dépasse la taille allouée, pas de problème... '===Python==='\n Cette méthode est aussi utile pour formater les nombres qui seront affichés.\nUne lettre ajoutée dans l\u0026rsquo;accolade spécifie le système de numération : d pour la base 10, b pour les binaires, x ou X pour les hexadécimaux (en minuscules ou majuscules).\na = 254 print(\u0026#39;a = {0:d} en base 10\u0026#39;.format(a)) print(\u0026#39;a = {0:b} en binaire\u0026#39;.format(a)) print(\u0026#39;a = {0:x} en héxadécimal (minuscules)\u0026#39;.format(a)) print(\u0026#39;a = {0:X} en héxadécimal (majuscules)\u0026#39;.format(a)) a = 254 en base 10 a = 11111110 en binaire a = fe en héxadécimal (minuscules) a = FE en héxadécimal (majuscules)  Si on veut que tous les nombres affichés ait la même taille (pour les aligner, par exemple), on peut ajouter des zéros à gauche pour compléter.\n\u0026#39;a = {a:05d}\u0026#39;.format(a = 254) 'a = 00254'\nPar défaut, seul le signe d\u0026rsquo;un nombre négatif est affiché. C\u0026rsquo;est là encore customisable en ajoutant un signe avant la valeur de la longueur minimum : '+' affiche toujours le signe et '' ajoute un espace devant si le nombre est positif.\na , b = -25 , 12 s = \u0026#39;{0:+5d}\\n{1:+5d}\\n= {2:+3d}\u0026#39;.format(a,b,a + b) print(s)  -25 +12 = -13  Les floats aussi ont leurs formats propres. Ajouter \u0026ldquo;e\u0026rdquo; ou \u0026ldquo;E\u0026rdquo; en fin d\u0026rsquo;accolade impose un affichage en notation scientifique alors que \u0026ldquo;f\u0026rdquo; impose l\u0026rsquo;écriture décimale. Et placer \u0026ldquo;.p\u0026rdquo; (où p est un nombre) après le signe \u0026ldquo;:\u0026rdquo; précise le nombre p de décimales que l\u0026rsquo;on souhaite (la précision).\na = 1.6235e-6 1.6235e-06\nprint(\u0026#39;{0:.1e}\u0026#39;.format(a), end = \u0026#39; \u0026#39;) print(\u0026#39;{0:.8E}\u0026#39;.format(a), end = \u0026#39; \u0026#39;) print(\u0026#39;{0:.8f}\u0026#39;.format(a), end = \u0026#39; \u0026#39;) print(\u0026#39;{0:.5f}\u0026#39;.format(a)) # Attention à ne pas tout tronquer ! 1.6e-06 1.62350000E-06 0.00000162 0.00000\n"
},
{
	"uri": "https://cordier-info.github.io/tp_python/tp3/",
	"title": "TP3 : Listes, Tuples et boucles",
	"tags": [],
	"description": "",
	"content": "TP3 : Listes, tuples et boucles Lien vers le repository GitHub du TP : https://classroom.github.com/a/8UyWSW6k\nExercice 1 Reproduire ces jolies règles de multiplication que l\u0026rsquo;on trouve dans le Talkhys, un traité d’arithmétique d’Ibn Albanna, mathématicien marocain de la première moitié du XIIIe siècle (code à écrire dans exo_1.py)\n 1 × 1 = 1 11 × 11 = 121 111 × 111 = 12321 1111 × 1111 = 1234321 11111 × 11111 = 123454321 111111 × 111111 = 12345654321 1111111 × 1111111 = 1234567654321 11111111 × 11111111 = 123456787654321 111111111 × 111111111 = 12345678987654321   Exercice 2 Une liste peut être utilisée comme une représentation simple d\u0026rsquo;un polynôme, $P(x)$, où les éléments sont les coefficients des puissances de $x$ successives et les indices sont les puissances elles-mêmes. Ainsi le polynôme $P(x)=3+6x+2x^3$ sera représenté par la liste [3,6,0,2].\nPourquoi la tentative suivante pour dériver un polynôme échoue-t-elle (explication à fournir dans exo_2.md) ? Corriger exo_2.py en utilisant le moins de caractères possible.\nP = [3, 6, 0, 2] dPdx = [] for i, c in enumerate(P[1:]): dPdx.append(i*c) dPdx [0, 0, 4]\n Exercice 3 Utiliser une boucle for pour estimer π à partir des 20 premiers termes de la série de Madhava-Leibniz : $\\pi=\\sqrt{12}\\left(1-\\frac{1}{3\\cdot 3}+\\frac{1}{5\\cdot 3^2}-\\frac{1}{7\\cdot 3^3}+\\cdots\\right)$\nCode à écrire dans exo_3.py.\n Exercice 4 Trier une liste de tuples les range dans l\u0026rsquo;ordre des premiers éléments de chaque tuple. Si deux premiers éléments sont identiques, on compare les deuxièmes, etc.\na = (3,1), (2,0), (1,4), (1,-1), (0,2) a = list(a) sorted(a) [(0, 2), (1, -1), (1, 4), (2, 0), (3, 1)]\nCela suggère une méthode utilisant zip pour trier une liste en fonction des éléments d\u0026rsquo;une autre.\nMettre au point et utiliser cette méthode sur les données suivantes donnant le nombre d\u0026rsquo;heures d\u0026rsquo;ensoleillement pendant l\u0026rsquo;année 2018 dans différentes villes afin de trier ces villes de la plus ensoleillée à la moins ensoleillée (les données sont déjà écrites dans exo_4.py).\n   Bordeaux Brest Limoges Lyon Marseille Nantes     2031 1676 1932 2145 2773 2101   Nice Paris Pau La Rochelle Strasbourg Tours   2504 1995 1821 2424 2124 2050     Exercice 5 La loi de Benford prévoit la distribution des fréquences du premier chiffre des nombres présents dans divers ensembles de données. Cette distribution n\u0026rsquo;est pas uniforme : le chiffre 1 est plus souvent en première position que le 2, le 2 que le 3, et ainsi de suite.Cette loi peut par exemple se vérifier sur les prix dans un supermarché et a déjà été utilisée pour déceler des fraudes fiscales.\nLa probabilité pour que le chiffre $d$ soit en première position est donnée par la loi suivante : $P(d)=\\log_{10}\\left(\\frac{d+1}{d}\\right)$ La loi est d\u0026rsquo;autant mieux vérifiée que le jeu de données couvre plusieurs ordres de grandeur.\nDémontrer à l\u0026rsquo;aide d\u0026rsquo;un programme (à écrire dans exo_5.py) que les premiers chiffres des 500 premiers éléments de la suite de Fibonacci suivent bien la loi.\nAide : pour récupérer le premier chiffre, on pourra transformer les éléments de la suite en chaîne de caractères puis transformer le premier caractère en entier avec int().\n"
},
{
	"uri": "https://cordier-info.github.io/cours_python/cours3/",
	"title": "Séquences et itérables",
	"tags": [],
	"description": "",
	"content": "Séquences et itérables Séquences Listes Python connaît différents types de données combinées, utilisés pour regrouper plusieurs valeurs. La plus souple est la liste, qui peut être écrite comme une suite, placée entre crochets, de valeurs (éléments) séparées par des virgules. Les éléments d\u0026rsquo;une liste ne sont pas obligatoirement tous du même type, bien qu\u0026rsquo;à l\u0026rsquo;usage ce soit souvent le cas.\nliste1 = [1, \u0026#39;deux\u0026#39;, 3.14, 0] liste1 [1, 'deux', 3.14, 0]\na = 4 liste2 = [-2.5, a, liste1, a==2, True] liste2 [-2.5, 4, [1, 'deux', 3.14, 0], False, True]\nPour créer une liste vide :\nliste0 = [] liste0 []\n  Indexation Comme les chaînes de caractères, les listes peuvent être indicées et découpées (slicing) :\n liste1[1] 'deux'\nliste2[-1] True\nliste2[2][1] 'deux'\nCe dernier exemple permet de retrouver le deuxième (indice 1) élément du troisième (indice 2) élément de la liste2. Cela marche car il se trouve que liste2[2] est une liste et liste1[1] est la chaîne de caractère 'deux'. Et une chaîne de caractère étant elle-même indiçable, on peut écrire :\nliste2[2][1][-1] 'x'\nOn peut utiliser l\u0026rsquo;opérateur in pour tester l\u0026rsquo;appartenance à une liste :\n 1 in liste1 True\n\u0026#39;deux\u0026#39; in liste2 False\nOn voit dans ce deuxième exemple que l\u0026rsquo;opérateur in ne regarde pas à l\u0026rsquo;intérieur des listes contenues dans les listes (on dit qu\u0026rsquo;il n\u0026rsquo;agit pas récursivement).\nLes listes sont concaténables :\n liste1 + liste2 [1, 'deux', 3.14, 0, -2.5, 4, [1, 'deux', 3.14, 0], False, True]\nLa fonction len() permet de connaître la taille d\u0026rsquo;une liste :\n len(liste1) 4\nlen() ne compte que les éléments au premier niveau de la liste et non ceux des sous-listes :\nlen(liste2) 5\nlen(liste2[2]) 4\n  Slicing On découpe les listes comme on a découpé les chaînes de caractères :\nL = [0., 0.1, 0.2, 0.3, 0.4, 0.5] L[1:4] [0.1, 0.2, 0.3]\nOn peut obtenir une copie renversée d\u0026rsquo;une liste en la découpant avec un pas de -1 :\nL[::-1] [0.5, 0.4, 0.3, 0.2, 0.1, 0.0]\nGrâce au pas, on peut aussi sélectionner des éléments périodiquement :\nL[1::2] [0.1, 0.3, 0.5]\n  Mutabilité des listes Contrairement aux chaînes de caractères, les listes sont des objets mutables, c\u0026rsquo;est-à-dire qu\u0026rsquo;on peut modifier leur contenu.\n On peut ainsi réaffecter des éléments :\nL1 = [1, 2, 3] L1[2] = \u0026#39;oups\u0026#39; L1 [1, 2, 'oups']\nL2 = L1 L1[1] = -99 L2 [1, -99, 'oups']\nOn remarque que modifier L1 a modifié L2. En effet, L1 et L2 référencent la même liste, stockée dans un unique espace mémoire.\nPour créer une nouvelle liste, copie de la liste de départ, mais indépendante, il y a plusieurs solutions :\nL2 = L1.copy() L3 = L1[:] L4 = list(L1) L2[1]=L3[1]=L4[1]=\u0026#39;ok\u0026#39; print(L1,L2,L3,L4) [1, -99, 'oups'] [1, 'ok', 'oups'] [1, 'ok', 'oups'] [1, 'ok', 'oups']\nSi une liste contient une variable affectée à une certaine valeur et que cette variable est réaffectée, la liste garde l\u0026rsquo;ancienne valeur car au moment de la définition de la liste, c\u0026rsquo;est la valeur de la variable et non la variable elle-même qui est stockée en mémoire.\na = 3 L3 = [1, 2, a] a = 4 L3 [1, 2, 3]\nQue deviendrait la liste2 du début après l\u0026rsquo;instruction a=2 ?\nDes affectations de tranches sont également possibles, ce qui peut modifier la taille de la liste ou même la vider complètement :\nlettres = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;] lettres[2:5] = [\u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;] lettres ['a', 'b', 'C', 'D', 'E', 'f', 'g']\nlettres[2:5] = [] lettres ['a', 'b', 'f', 'g']\nlettres[:] = [] # pour vider entièrement la liste lettres []\n  Méthodes Le type list dispose, comme le type string, de méthodes supplémentaires, accessibles avec la notation point \u0026ldquo;.\u0026rdquo;.\nEt comme les listes sont des objets muables, elles peuvent être agrandies ou rétrécies \u0026ldquo;sur place\u0026rdquo; (sans avoir à copier le contenu dans un nouvel objet).\nPour cela, on utilise les méthodes suivantes :\n append(x) : ajoute l\u0026rsquo;élément x à la fin d\u0026rsquo;une liste. extend(liste_b) : étend la liste en y ajoutant tous les éléments de la liste_b. insert(i,x): insère l\u0026rsquo;élément x à la position i. remove(x): supprime de la liste le premier élément dont la valeur est égale à x. Une exception ValueError est levée s\u0026rsquo;il n\u0026rsquo;existe aucun élément avec cette valeur.  q = [] q.append(4) q [4]\nq.extend([6,7,8]) q [4, 6, 7, 8]\nq.insert(1,5) q [4, 5, 6, 7, 8]\nq.remove(7) q [4, 5, 6, 8]\n   méthodes utiles description     index(x) retourne l\u0026rsquo;indice de l\u0026rsquo;élément x (le plus petit s\u0026rsquo;il est là plusieurs fois)   pop() retire et retourne le dernier élément de la liste   reverse() inverse l\u0026rsquo;ordre des éléments (directement dans la liste et non dans une copie comme liste[::-1])   sort() ordonne les éléments dans la liste   copy() retourne une copie de la liste (équivaut à liste[:])   count(x) renvoie le nombre d\u0026rsquo;éléments ayant la valeur x dans la liste    q.index(8) 3\nq = [2, 0, -1, 3] q.sort() q [-1, 0, 2, 3]\nPour obtenir une copie triée d\u0026rsquo;une liste sans modifier la liste originale, on peut utiliser la fonction native sorted() :\nq = [\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;] sorted(q) ['A', 'a', 'b', 'c', 'e']\nq ['a', 'e', 'A', 'c', 'b']\nOn peut aussi utiliser cette fonction pour qu\u0026rsquo;elle retourne une liste inversée :\nsorted(q, reverse=True) ['e', 'c', 'b', 'a', 'A']\nLes méthodes append() et pop() sont adaptées pour des données structurées en piles (stack en anglais) où le principe est \u0026ldquo;dernier arrivé, premier sorti\u0026rdquo; (LIFO pour l\u0026rsquo;anglais \u0026ldquo;last in, first out\u0026rdquo;). Cela sert en particulier pour la gestion de la mémoire. Vous en réentendrez parler.\nstack = [] stack.append(1) stack.append(2) stack.append(3) stack.append(4) print(stack) [1, 2, 3, 4]\nstack.pop() 4\nprint(stack) [1, 2, 3]\nLa méthode des chaînes de caractères split() permet de créer une liste à partir d\u0026rsquo;une chaîne donnée (si non indiqué, le séparateur est l\u0026rsquo;espace).\nmois = \u0026#39;jan. févr. avr. mai juin\u0026#39; mois.split() ['jan.', 'févr.', 'avr.', 'mai', 'juin']\nnoms = \u0026#39;Alphonse et Dudule et Raoul et Ursula\u0026#39; noms.split(\u0026#39; et \u0026#39;) \u001c['Alphonse', 'Dudule', 'Raoul', 'Ursula']\n  Tuples Nous avons vu que les listes et les chaînes de caractères ont beaucoup de propriétés en commun, comme l\u0026rsquo;indexation et le slicing. Ce sont des exemples de séquences. Les séquences sont une des principales structure de données native en Python. Ce sont des collections ordonnées d\u0026rsquo;objets qui peuvent être indicées et découpées.\n Il existe également un autre type standard de séquence : le tuple.\nUn tuple consiste en différentes valeurs séparées par des virgules (avec ou sans parenthèses autour) :\nt = 1, \u0026#39;deux\u0026#39;, 3.0, 4 t \u001c(1, 'deux', 3.0, 4)\nComme un tuple est une séquence, il peut être indexé ou découpé.\nt[1] 'deux'\nt[1:3] ('deux', 3.0)\nt[0] = \u0026#39;essai de réaffectation\u0026#39; TypeError: 'tuple' object does not support item assignment\nLe dernier exemple montre que les tuples sont des objets immuables.\nPour créer un tuple vide, pas de problèmes :\nt = () Par contre, c\u0026rsquo;est plus compliqué de créer un tuple ne contenant qu\u0026rsquo;un élément (un singleton) :\nt = (1,) Si les tuples peuvent sembler similaires aux listes, ils sont généralement utilisés dans des cas et pour des raisons particulières du fait de leur principale différence : Les tuples sont immuables !\n Les tuples sont donc utiles lorsqu\u0026rsquo;une séquence ne peut ou ne devrait pas être modifiée.\nOn place souvent dans des tuples des collections hétérogènes d\u0026rsquo;éléments auxquelles on accèder par \u0026ldquo;déballage\u0026rdquo;.\nL\u0026rsquo;instruction t = 1, 'deux', 3.0 est un exemple d\u0026rsquo;emballage de tuple : les valeurs 1, 'deux', 3.0 sont \u0026ldquo;emballées\u0026rdquo; ensemble.\nOn peut ensuite déballer le tuple. Comme on l\u0026rsquo;a déjà vu, cela permet des affectations multiples.\nt = 1, \u0026#39;deux\u0026#39;, 3.0 x , y, z = t print(x,y,z) 1 deux 3.0\n  Objets itérables Les chaînes de caractères, les listes et les tuples sont des exemple d\u0026rsquo;objets itérables : des objets composés d\u0026rsquo;un ensemble d\u0026rsquo;éléments qui peuvent être sélectionnés un par un (= déballés ou unpacked en anglais).\n Toutes les séquences sont des itérables, mais l\u0026rsquo;inverse n\u0026rsquo;est pas vrai (les ensembles (sets), par exemple, sont des itérables mais pas des séquences).\n L\u0026rsquo;opérateur * permet de déballer un itérable (unpack). Cela peut s\u0026rsquo;avérer pratique lorsqu\u0026rsquo;une fonction prend en argument plusieurs éléments.\nPrenons l\u0026rsquo;exemple de la fonction math.hypot(x,y) qui calcule $\\sqrt{a^2+b^2}$ :\nimport math c = [3, 4] math.hypot(c) TypeError: hypot expected 2 arguments, got 1\nmath.hypot(*c) 5.0\nC\u0026rsquo;est bien plus simple que d\u0026rsquo;aller récupérer les éléments de la liste en les indexant (math.hypot(c[0],c[1])).\n  Boucle for C\u0026rsquo;est souvent utile de récupérer et d\u0026rsquo;utiliser un à un chacun des éléments d\u0026rsquo;un objet itérable.\nLa syntaxe Python pour une telle opération est plutôt naturelle :\nfor élément in objet itérable :\nliste_de_fruits = [\u0026#39;pomme\u0026#39;, \u0026#39;banane\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;pamplemousse\u0026#39;] for fruit in liste_de_fruits : print(fruit) pomme\nbanane\norange\npamplemousse\nChacun son tour, un élément de l\u0026rsquo;objet itérable liste_de_fruits est affecté à la variable fruit dans le block d\u0026rsquo;instructions qui suit le signe :.\nChaque ligne de ce bloc, le corps de la boucle, doit être indentée par le même nombre d\u0026rsquo;espaces (c\u0026rsquo;est recommandé d\u0026rsquo;utiliser 4 espaces ou une tabulation par niveau d\u0026rsquo;indentation). C\u0026rsquo;est cette indentation qui permet, en Python, de savoir qu\u0026rsquo;on est ou non toujours dans la boucle.\nLa structuration du code par indentation est une des principales caractéristiques du langage Python (et un des principaux griefs contre lui).\nUne boucle peut très bien être imbriquée dans une autre boucle (il faut indenter le corps de la boucle intérieure d\u0026rsquo;un niveau de plus) :\nfor fruit in liste_de_fruits : for lettre in fruit : print(lettre,end =\u0026#39;.\u0026#39;) print() p.o.m.m.e.\nb.a.n.a.n.e.\no.r.a.n.g.e.\np.a.m.p.l.e.m.o.u.s.s.e.\nLe end = '.' du print dans la boucle intérieure permet de placer un point après chaque lettre tout en évitant la nouvelle ligne à chaque appel de la fonction.\nLe print() de la boucle extérieure permet d\u0026rsquo;aller à la ligne à la fin de chaque mot.\n  range() Si vous devez itérer sur une suite d\u0026rsquo;entiers, la fonction native range() est faite pour cela. Elle génère un objet de type séquence qui permet de créer des suites arithmétiques :\nfor i in range(5) : print(i, end = \u0026#39; \u0026#39;) 0 1 2 3 4\nfor i in range(1,5) : print(i, end = \u0026#39; \u0026#39;) 1 2 3 4\nfor i in range(0,6,2) : print(i, end = \u0026#39; \u0026#39;) 0 2 4\nfor i in range(10,0,-2) : print(i, end = \u0026#39; \u0026#39;) 10 8 6 4 2\nrange() prend donc trois arguments (entier de départ, entier de fin, le pas) dont deux optionnels (range commence à zéro et le pas vaut 1 par défaut).\nLe dernier entier produit par range est celui précédant la valeur de l\u0026rsquo;entier de fin.\n Exemple : écrire les 20 premiers termes de la suite de Fibonacci définie par $a_1=1$, $a_2=1$ et la relation de récurrence $a_i = a_{i-1}+a_{i-2}$.\nPremière méthode : ajouter des éléments à une liste\nn = 20 fib = [1,1] for i in range(2,n) : fib.append(fib[i-1]+fib[i-2]) print(*fib) 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765\nDeuxième méthode (moins consommatrice de mémoire) : on peut se débrouiller pour ne stocker à tout moment que deux éléments.\nn = 20 a, b = 1, 1 print(a, b, end = \u0026#34; \u0026#34;) for i in range (2,n) : a, b = b, a+b print(b, end = \u0026#34; \u0026#34;) 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765\n  enumerate Comme range() produit une suite d\u0026rsquo;entiers, on peut l\u0026rsquo;utiliser pour afficher l\u0026rsquo;indice de l\u0026rsquo;élément d\u0026rsquo;une liste à chaque itération dans une boucle for :\nmarsupiaux = [\u0026#39;kangooroo\u0026#39; , \u0026#39;koala\u0026#39; , \u0026#39;wombat\u0026#39;] for i in range(len(marsupiaux)) : print(i, \u0026#39; : \u0026#39;, marsupiaux[i]) 0 : kangooroo\n1 : koala\n2 : wombat\nOn peut réaliser la même chose plus efficacement en utilisant enumerate().\nCette fonction prend un objet itérable en argument et produit, pour chaque élément de l\u0026rsquo;objet, un tuple (numéro, élément) associant un numéro à l\u0026rsquo;élément lui-même.\nfor i, marsupial in enumerate(marsupiaux) : print(i, \u0026#39; : \u0026#39;, marsupial) 0 : kangooroo\n1 : koala\n2 : wombat\nChaque tuple (numéro, élément) a été déballé dans la boucle for en les affectant aux variables i et marsupial.\nOn peut faire commencer la numérotation d'enumerate à une autre valeur que 0 (mais le numéro ne correspondra alors plus à l\u0026rsquo;indice).\nfor i, marsupial in enumerate(marsupiaux,1) : print(i, \u0026#39; : \u0026#39;, marsupial) 1 : kangooroo\n2 : koala\n3 : wombat\n  zip Pour faire des boucles sur plusieurs séquences en même temps, on peut utiliser la fonction zip() afin d’associer les éléments des différentes séquences entre eux.\nElle crée un objet itérable composé de tuples couplant les termes de même indice des différentes séquences en argument.\na = [1, 2, 3, 4] b = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] for pair in zip(a,b) : print(pair) (1, 'a')\n(2, 'b')\n(3, 'c')\n(4, 'd')\nCe n\u0026rsquo;est donc pas grave que les listes n\u0026rsquo;aient pas la même taille, zip les associe tant qu\u0026rsquo;elle peut.\nOn peut aussi utiliser zip pour dézipper des séquences de tuples :\nz = ((1,\u0026#39;a\u0026#39;),(2,\u0026#39;b\u0026#39;),(3,\u0026#39;c\u0026#39;),(4,\u0026#39;d\u0026#39;)) A , B = zip(*z) print(A, B, sep = \u0026#39;\\n\u0026#39;) (1, 2, 3, 4) \n('a', 'b', 'c', 'd')\nComme zip ne copie pas les éléments vers un nouvel objet, cette méthode est rapide et économe en mémoire ; mais cela signifie aussi qu\u0026rsquo;on ne peut itérer sur les éléments zippés qu\u0026rsquo;une seule fois et qu\u0026rsquo;on ne peut pas les indicer.\n  Dictionnaires \u0026ldquo;dictionnary\u0026rdquo; est le nom en Python a une structure de données très pratique : la table de hachage.\nUn dictionnaire est un contenant, comme une liste ou un tuple, mais au lieu d\u0026rsquo;indicer les objets s\u0026rsquo;y trouvant (appelés valeurs) par un nombre, on utilise une clé.\nUne clé peut être n\u0026rsquo;importe quel objet immuable, mais il s\u0026rsquo;agit le plus souvent d\u0026rsquo;une chaîne de caractères.\nExemple où les clés sont des prénoms et les valeurs, des notes :\nnote = {\u0026#39;Giselle\u0026#39; : 7.5, \u0026#39;Alphonse\u0026#39; : 12, \u0026#39;Dudule\u0026#39; : 7.5, \u0026#39;Berthe\u0026#39; : 16.5} Chaque valeur peut être récupérée grâce à la clé, comme s\u0026rsquo;il s\u0026rsquo;agisait d\u0026rsquo;un indice :\nnote[\u0026#39;Dudule\u0026#39;] 7.5\nprenom = \u0026#39;Berhe\u0026#39; note[prenom] 16.5\nOn peut ajouter une entrée au dictionnaire de la même façon :\nnote[\u0026#39;Raoul\u0026#39;] = 14 note {'Giselle': 7.5, 'Alphonse': 12, 'Dudule': 7.5, 'Berthe': 16.5, 'Raoul': 14}\nLes dictionnaires sont des objets mutables.\nnote[\u0026#39;Berthe\u0026#39;] = 18 note {'Giselle': 7.5, 'Alphonse': 12, 'Dudule': 7.5, 'Berthe': 18, 'Raoul': 14}\nLe constructeur dict() permet de fabriquer un dictionnaire à partir d\u0026rsquo;une séquence de paires (clé, valeur) :\nchiffres_romain = dict([(1,\u0026#39;I\u0026#39;),(2,\u0026#39;II\u0026#39;),(3,\u0026#39;III\u0026#39;),(4,\u0026#39;IV\u0026#39;),(5,(\u0026#39;V\u0026#39;))]) chiffres_romain[4] 'IV'\nAttention, 4 n\u0026rsquo;est pas un indice, ici, mais bien une clé.\nSi les clés utilisées peuvent constituer des noms de variables, la construction d\u0026rsquo;un dictionnaire devient encore plus simple :\nmasse = dict(Mercure = 3.301e23, Vénus = 4.867e24, Terre = 5.972e24) masse[\u0026#39;Terre\u0026#39;] 5.972e+24\nChaque clé doit être unique, mais les valeurs peuvent être identiques (comme les notes de Dudule et Giselle).\n Tenter d\u0026rsquo;indicer un dictionnaire par une clé inexistante se solde par une erreur. Pour y échapper, on utilise la méthode get(clé). Un second argument permet de retourner une valeur par défaut en cas d\u0026rsquo;absence de la clé (sans ce deuxième argument, get retournera None).\nExemple d\u0026rsquo;utilisation : fabriquons une liste de 12 éléments pris au hasard parmi les entiers de 1 à 10 et mettons au point une méthode pour compter les occurrences de chacun des 10 entiers :\nfrom random import randint L = [] for i in range(12) : L += [randint(1,10)] effectifs = dict() for e in L : effectifs[e] = effectifs.get(e,0) + 1 print(effectifs) {3: 1, 6: 1, 8: 3, 2: 1, 10: 2, 7: 2, 1: 1, 9: 1}\nLes méthodes keys et values permettents de récupérer les clés et valeurs d\u0026rsquo;un dictionnaire sous forme d\u0026rsquo;itérables, ce qui peut s\u0026rsquo;avérer pratique pour un tracer, par exemple.\nimport matplotlib.pyplot as plt clés = effectifs.keys() valeurs = effectifs.values() plt.bar(clés, valeurs) plt.show() Les dictionnaires sont des ensemble de paires clé-valeur qui n\u0026rsquo;ont aucun ordre particulier. Les dictionnaires ne sont donc pas des séquences.\n   Ensembles Un ensemble (set en anglais) est une collection non ordonnée d\u0026rsquo;objets uniques. Les ensembles sont très pratiques pour retirer des éléments dupliqués d\u0026rsquo;une séquence et pour déterminer l\u0026rsquo;union, l\u0026rsquo;intersection ou la différence entre deux collections.\nComme ils ne sont pas ordonnées, les ensembles ne peuvent pas être indicés ou découpés. Ce ne sont pas des séquences.\n On crée un ensemble en listant ses éléments à l\u0026rsquo;intérieur d\u0026rsquo;accolades {...} ou en utilisant le constructeur set() :\ns = {1,\u0026#39;Coucou !\u0026#39;,1,4,3,1,\u0026#39;Coucou !\u0026#39;,2,3} s {1, 2, 3, 4, 'Coucou !'}\nEn transformant la liste L de la section précédente (sur les dictionnaires) en ensemble, on peut facilement déterminer le nombre d\u0026rsquo;éléments dupliqués contenus dans L et les éliminer par la même occasion :\nS = set(L) print(S) nb_duplicata = len(L) - len(S) print(\u0026#39;Nombre de redondances dans L :\u0026#39;,nb_duplicata) {1, 2, 3, 6, 7, 8, 9, 10}\nNombre de redondances dans L : 4\nMéthodes s\u0026rsquo;appliquant aux ensembles :\n   Méthode Description     A.isdisjoint(B,...) Est-ce que A et B (et autres) sont disjoints ($A \\cap B = \\emptyset$) ?   A.issubset(B) (ou A \u0026lt;= B) Est-ce que A est inclus dans B (au sens large) ($A \\subseteq B$) ?   A \u0026lt; B Est-ce que A est inclus dans B (au sens strict) ($A \\subset B$) ?   A.union(B,...) (ou A | B | ...) Union de A et B (et autres) $A\\cup B$   A.intersection(B,...) (ou A \u0026amp; B \u0026amp; ...) Intersection de A et B (et autres) $A\\cap B$   A.difference(B,...) (ou A - B - ...) Différence entre A et B (et autres) $A\\backslash B$   A.symmetric_difference(B,...) (ou A ^ B ^ ...) Différence symémtrique entre A et B (et autres) $A\\Delta B$    Pour illustrer l\u0026rsquo;utilité des ensembles, voyons comment ils rendent simplissime le passage du crible d\u0026rsquo;Ératosthène sur les nombres entiers inférieurs à 100 pour y isoler les nombres premiers :\nn = 100 P = set(range(2,n)) # ensemble des entiers de 2 à 99 for i in range(2,n//2) : M = set(range(2*i,n,i)) # ensemble des multiples de i (autres que i) P = P - M # on retire ces multiples de la liste de départ print(P) {2, 3, 67, 5, 7, 71, 73, 11, 13, 79, 17, 19, 83, 23, 89, 29, 31, 97, 37, 41, 43, 47, 53, 59, 61}\n  Listes par compréhension La construction de listes par compréhension permet de créer une liste à partir d\u0026rsquo;un autre objet itérable en une seule ligne de code.\nPar exemple, étant donné une liste de nombres, une liste des carrés de ces nombres peut être créée ainsi :\nxliste = [1, 2, 3, 4, 5, 6] x2liste = [x**2 for x in xliste] La méthode classique prend un peu plus de temps pour s\u0026rsquo;exécuter et sa syntaxe est plus lourde :\nx2liste = [] for x in xliste : x2liste.append(x**2) x2liste [1, 4, 9, 16, 25, 36]\nComme on le voit, une construction d\u0026rsquo;une liste par compréhension est analogue à une définition mathématique.\nOn peut aussi placer des conditions dans la définition :\n[x**2 if x % 2 else x**3 for x in xliste] [1, 8, 9, 64, 25, 216]\nOn a ici mis au carré les nombres impairs et au cube les nombres pairs de xliste.\nOn l\u0026rsquo;a dit, la construction par compréhension se base sur n\u0026rsquo;importe quel itérable, pas forcément une liste :\n[x**3 for x in range(1,10)] [1, 8, 27, 64, 125, 216, 343, 512, 729]\n[w.upper() for w in \u0026#39;abc xyz\u0026#39;] ['A', 'B', 'C', ' ', 'X', 'Y', 'Z']\nEnfin, une liste construite par compréhension peut être imbriquée.\nLe code suivant va permettre d\u0026rsquo;applatir une liste de listes :\nvliste = [[1, 2, 3],[4, 5, 6],[7, 8, 9]] [c for v in vliste for c in v] [1, 2, 3, 4, 5, 6, 7, 8, 9]\nLa première boucle parcourt les différentes listes intérieurs de vliste et la deuxième boucle parcourt les éléments de ces listes intérieures.\n Exemple : supposons que l\u0026rsquo;on veuille transposer une matrice M 3 × 3.\n Sans compréhension de liste :  M = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] MT = [[0,0,0],[0,0,0],[0,0,0]] for i in range(3) : for j in range(3) : MT[i][j] = M[j][i] for l in MT : print(l) [1, 4, 7] [2, 5, 8] [3, 6, 9]  Avec compréhension de liste :  MT = [] for i in range(3) : MT.append([col[i] for col in M]) for l in MT : print(l) [1, 4, 7] [2, 5, 8] [3, 6, 9] Notons toutefois que le package de programmation scientifique NumPy (étudié plus tard) propose une méthode bien meilleure pour gérer les matrices.\n Les dictionnaires aussi ont droit à leur construction par compréhension. Dans l\u0026rsquo;exemple suivant, on crée un dictionnaire reportant le nombre de fois que chaque mot apparaît dans un texte.\ntexte = \u0026#34;\u0026#34;\u0026#34;texte avec répétitions servant de test pour déterminer le nombre de répétitions de chaque mot dans le texte\u0026#34;\u0026#34;\u0026#34; decompte = {mot: texte.split().count(mot) for mot in set(texte.split())} decompte {'pour': 1, 'déterminer': 1, 'avec': 1, 'servant': 1, 'texte': 2, 'le': 2, 'chaque': 1, 'test': 1, 'mot': 1, 'nombre': 1, 'répétitions': 2, 'de': 3, 'dans': 1}\n "
},
{
	"uri": "https://cordier-info.github.io/tp_python/tp4/",
	"title": "TP4 : Structures de contrôle",
	"tags": [],
	"description": "",
	"content": "TP4 : Structures de contrôle Lien vers le repository GitHub du TP : https://classroom.github.com/a/_smX5cgY\nExercice 0 Compléter le programme exo_0.py pour qu\u0026rsquo;il ne cesse de demander le nom de l\u0026rsquo;utilisateur tant que sa réponse ne fait pas partie de la liste de noms autorisés. Exercice 1 Le ROT13 (rotate by 13 places) est un cas particulier du chiffre de César, un algorithme simpliste de chiffrement de texte.\nComme son nom l’indique, il s’agit d’un décalage de 13 caractères de chaque lettre du texte à chiffrer. Son principal aspect pratique est que le codage et le décodage se font exactement de la même manière.\nIndications :\n utiliser la chaîne de caractères \u0026lsquo;abcdefghijklmnopqrstuvwxyz\u0026rsquo;. l\u0026rsquo;opérateur in ou la méthode isalpha permettront de savoir si un caractère est alphabétique. transformer le caractère (l\u0026rsquo;opérateur % peut s\u0026rsquo;avérer utile). les caractères accentués et les majuscules n\u0026rsquo;ont pas été modifiés.  Écrire un programme (dans exo_1.py) permettant de décoder l\u0026rsquo;énoncé de l\u0026rsquo;exercice 2.\n Exercice 2 Épever ha cebtenzzr dhv genafsbezr ha grkgr qr znavèer à pr dhr yn cerzvèer rg yn qreavèer yrgger qr pundhr zbg erfgr vapunatér nybef dhr yrf yrggerf qr zvyvrh fbag zéynatérf nh unfneq. Ln cbapghngvba qbvg erfgre ra cynpr. Oa cbheen hgvyvfre yn sbapgvba enaqbz.fuhssyr() qh cnpxntr enaqbz dhv zéynatr yrf qvsséeragf éyézragf dh\u0026rsquo;ba yhv qbaar ra nethzrag.\nTexte à modifier (voir exo_2.py) :\n On avale à pleine gorgée le mensonge qui nous flatte, et on boit goutte à goutte une vérité qui nous est amère.\n On pourra utiliser la fonction random.shuffle() du package random qui mélange les différents éléments qu\u0026rsquo;on lui donne en argument en se rappelant que les chaînes de caractères sont immuables, il faut donc les transformer en listes (grâce à list(chaîne)) si on veut les modifier.\n Exercice 3 Les alcanes linéaires sont les hydrocarbures de formule brute $C_nH_{2n+2}$ dont les carbones forment une chaîne linéaire.\nÉcrire (dans exo_3.py) un programme donnant la formule semi-développée d\u0026rsquo;un tel alcane à partir d\u0026rsquo;une formule brute.\nPar exemple : si brut = 'C4H10' alors le programme doit afficher CH3-CH2-CH2-CH3.\n Exercice 4 L\u0026rsquo;algorithme de Luhn est une formule de somme de contrôle permettant de valider un numéro de carte bancaire.\nOn considère le numéro de carte comme une suite de nombres à 1 chiffre.\n Renverser la liste. Prendre tous les chiffres en position paire dans la liste renversée (2e chiffre, 4e chiffre, etc.) et doubler leur valeur,\nsi le résultat dépasse 10, on ajoute les deux chiffres du résultat (par exemple $6\\rightarrow 12 \\rightarrow 3$). Sommer tous les nombres de la nouvelle liste (les modifiés et les non-modifiés) Si cette somme vaut 0 modulo 10. Le numéro de carte est valide.  Écrire (dans exo_4.py) un programme permettant de vérifier un numéro de carte.\nExercice 5 Que fait ce programme et comment ? (Écrire votre réponse dans exo_5.md)\nnmax = 5 x = [1] for n in range(1, nmax+2) : print(x) x = [([0]+x)[i] + (x+[0])[i] for i in range(n+1)]  Exercice 6 Dans la série \u0026ldquo;The Wire\u0026rdquo;, les dealers codent les numéros de téléphone en utilisant une méthode (\u0026ldquo;jump the five\u0026rdquo;) qui repose sur la disposition des touches sur le clavier.\nChaque numéro (sauf le 5 et le 0) permute avec celui qui se trouve de l\u0026rsquo;autre côté du 5. Le 5 et le 0 sont intervertis.\nÉcrire (dans exo_6.py) un programme qui crypte et décrypte les numéros de téléphone.\nCrypter le numéro de Vieljeux : \u0026ldquo;05 46 34 79 32‬\u0026rdquo;.\nExercice 7 La distance de Hamming entre deux chaînes de caractères de même longueur est le nombre de positions où les caractères sont différents. C\u0026rsquo;est une notion très importante en théorie du signal puisqu\u0026rsquo;elle mesure la corruption d\u0026rsquo;un message transmis.\nÉcrire (dans exo_7.py) un programme pour calculer la distance de Hamming entre deux chaînes.\n Exercice 8 La suite de Syracuse est une suite d\u0026rsquo;entiers naturels définie de la manière suivante : on part d\u0026rsquo;un nombre entier plus grand que zéro ;\n s’il est pair, on le divise par 2 ; s’il est impair, on le multiplie par 3 et on ajoute 1.  En répétant l’opération, on obtient une suite d\u0026rsquo;entiers positifs dont chacun ne dépend que de son prédécesseur.Lorsque 1 est atteint, un cycle de longueur 3 se répète sans fin : 1, 4, 2, 1, 4, 2, 1,\u0026hellip;\nOn ajoute donc une nouvelle règle :\n si 1 est atteint, la suite s\u0026rsquo;arrête.   Construire un programme qui calcule la suite de syracuse du nombre 27 (exo_8a.py). Appelons temps de vol le nombre de termes de la suite. Modifier le programme pour qu\u0026rsquo;il donne le temps de vol plutôt que les différents termes (exo_8b.py).  La conjecture de Syracuse (ou Collatz) dit que toutes les suites de Syracuse ont une fin.\nProuver que la conjecture est vérifiée pour tous les entiers inférieurs à 100 (exo_8c.py).  "
},
{
	"uri": "https://cordier-info.github.io/cours_python/cours4/",
	"title": "Structures de contrôle",
	"tags": [],
	"description": "",
	"content": "Structures de contrôle Python étant un langage impératif, il possède des structures de contrôle permettant de dévier le flot d\u0026rsquo;exécution. Les structures de contrôle travaillent sur des blocs d\u0026rsquo;instructions contigües qui sont repérés par leur indentation en Python.\nLes deux grandes familles de commandes de blocs sont :\n les alternatives : exécuter un bloc d\u0026rsquo;instructions si une certaine condition est réunie (si \u0026hellip; sinon si \u0026hellip; sinon) ; les boucles : exécuter un bloc d\u0026rsquo;instructions à plusieurs reprises (boucle \u0026ldquo;tant que\u0026rdquo; et les boucles avec compteur for déjà rencontrées).    if \u0026hellip; elif \u0026hellip; else La structure if ... elif ... else permet d\u0026rsquo;exécuter des instructions seulement si une condition, donnée par le résultat d\u0026rsquo;un ou plusieurs tests logiques, est vérifiée.\nif \u0026lt;expression logique 1\u0026gt; :\n\u0026lt;bloc d\u0026rsquo;instructions 1\u0026gt;\nelif \u0026lt;expression logique 2\u0026gt; :\n\u0026lt;bloc d\u0026rsquo;instructions 2\u0026gt;\n\u0026hellip;\nelse :\n\u0026lt;bloc d\u0026rsquo;instructions\u0026gt;\nSi l'\u0026lt;expression logique 1\u0026gt; est évaluée comme vraie, le \u0026lt;bloc d\u0026rsquo;instructions 1\u0026gt; est exécuté ; dans le cas contraire, si l'\u0026lt;expression logique 2\u0026gt; est évaluée comme vraie, le \u0026lt;bloc d\u0026rsquo;instructions 2\u0026gt; est exécuté, et ainsi de suite ; et si aucune des expressions logiques précédentes n\u0026rsquo;est vraie, le bloc d\u0026rsquo;instructions faisant suite au else: est exécuté.\nPar exemple :\nfor x in range(10) : if x\u0026lt;= 3 : print(x,\u0026#39;est inférieur ou égal à 3\u0026#39;) elif x \u0026gt; 5 : print(x,\u0026#39;est plus grand que 5\u0026#39;) else : print(x,\u0026#39;doit être 4 ou 5\u0026#39;) 0 est inférieur ou égal à 3 1 est inférieur ou égal à 3 2 est inférieur ou égal à 3 3 est inférieur ou égal à 3 4 doit être 4 ou 5 5 doit être 4 ou 5 6 est plus grand que 5 7 est plus grand que 5 8 est plus grand que 5 9 est plus grand que 5  Python reconnaît comme vrai n\u0026rsquo;importe quel type de donnée (même pas besoin d\u0026rsquo;expression logique) du moment qu\u0026rsquo;il ne s\u0026rsquo;agit ni de l\u0026rsquo;entier 0, du décimal 0., de la chaîne de caractères vide '', du tuple vide (), de la liste vide [], ou encore de la valeur None.\n for x in range(10) : if x : # vrai pour tout x ≠ 0 print(\u0026#39;, \u0026#39;,end = \u0026#39;\u0026#39;) if x % 2 : # vrai pour tout x impair print(x,\u0026#39;est impair\u0026#39;, end = \u0026#39;\u0026#39;) else : print(x,\u0026#39;est pair\u0026#39;, end = \u0026#39;\u0026#39;) print(\u0026#39;\u0026#39;,end = \u0026#39;.\u0026#39;) # pour le point final 0 est pair, 1 est impair, 2 est pair, 3 est impair, 4 est pair, 5 est impair, 6 est pair, 7 est impair, 8 est pair, 9 est impair.  Exemple :\nDans le calendrier grégorien, une année est bissextile si elle est divisible par 4 sauf si elle est aussi divisible par 100 à part les années divisibles par 400 qui sont bien bissextiles.\nLe programme suivant détermine si une année est bissextile :\nannée = 2020 if not année % 400 : est_bissextile = True elif not année % 100 : est_bissextile = False elif not année % 4 : est_bissextile = True else : est_bissextile = False s = \u0026#39;est une\u0026#39; if est_bissextile else \u0026#34;n\u0026#39;est pas une\u0026#34; print(\u0026#34;L\u0026#39;année\u0026#34;, année , s ,\u0026#34;année bissextile.\u0026#34;) L'année 2020 est une année bissextile.\n  Boucles while Alors qu\u0026rsquo;une boucle for tourne un nombre de fois fixé à l\u0026rsquo;avance, une boucle while exécute son bloc d\u0026rsquo;instructions tant qu\u0026rsquo;une certaine condition est validée.\ni = 0 while i \u0026lt; 10 : i += 1 print(i,end =\u0026#39;.\u0026#39;) print(\u0026#39;\\nLa boucle est finie...\u0026#39;) 1.2.3.4.5.6.7.8.9.10. La boucle est finie...  Le compteur i est initialisé à 0 et comme 0 est inférieur à 10, la boucle while démarre. À chaque itération, i est incrémenté de 1 et sa valeur affichée. Puis i atteint 10 et à l\u0026rsquo;itération suivante i \u0026lt; 10 devient faux, la boucle s\u0026rsquo;arrête et l\u0026rsquo;éxécution reprend après la boucle.\nOn voit avec cet exemple qu\u0026rsquo;un équivalent de boucle for peut facilement être construit avec une boucle while.\nUn exemple plus intéressant :\nimplémentons l\u0026rsquo;algorithme d\u0026rsquo;Euclide permettant de déterminer le plus grand diviseur commun de deux entiers.\na , b = 1920 , 1080 print(\u0026#39;pgcd({},{}) = \u0026#39;.format(a,b),end = \u0026#39;\u0026#39;) while b : a , b = b, a % b print(a) pgcd(1920,1080) = 120\nLa boucle continue jusqu\u0026rsquo;à ce que b divise a. À chaque itération, b prend la valeur du reste de la division euclidienne de a par b et a prend l\u0026rsquo;ancienne valeur de b.\nwhile b est équivalent à while b != 0 puisque la valeur 0 est évaluée comme fausse.\n  break, continue et else Python propose 3 instructions supplémentaires pour contrôler le flux d\u0026rsquo;un programme.\nbreak L\u0026rsquo;instruction break, placée dans le bloc d\u0026rsquo;instructions d\u0026rsquo;une boucle, met immédiatement fin à cette boucle lorsqu\u0026rsquo;arrive son tour d\u0026rsquo;être exécutée.\nL\u0026rsquo;exécution reprend à l\u0026rsquo;instruction suivant la boucle.\nx = 0 while True : x += 1 if not (x % 15 or x % 25) : break print(x,\u0026#39;est divisible à la fois par 15 et 25.\u0026#39;) 75 est divisible à la fois par 15 et 25.\nLa condition du while est ici littéralement toujours vraie donc la seule sortie possible de la boucle passe par une exécution de l\u0026rsquo;instruction break, ce qui ne peut arriver que si x est à la fois divisible par 15 et 25.\nDe la même manière, pour trouver l\u0026rsquo;indice de la première occurrence d\u0026rsquo;un nombre négatif dans une liste :\nliste = [5, 2, 99, 0, 100, -2, 37, 43, -124] for i, a in enumerate(liste) : if a \u0026lt; 0 : break print(\u0026#34;L\u0026#39;élément d\u0026#39;indice\u0026#34;,i,\u0026#34;valant\u0026#34;,a,\u0026#34;est le premier élément négatif.\u0026#34;) L'élément d'indice 5 valant -2 est le premier élément négatif.\nAprès la sortie de la boucle, les variables i et a gardent les valeurs qu\u0026rsquo;elles ont au moment de l\u0026rsquo;instruction break.\n  continue continue marche comme break mais au lieu de sortir de la boucle, l\u0026rsquo;instruction force immédiatement la prochaine itération de la boucle sans accomplir le reste des instructions du bloc pour l\u0026rsquo;itération en cours.\nfor i in range(1,11) : if i % 2 : continue print(i,\u0026#39;est pair\u0026#39;) 2 est pair 4 est pair 6 est pair 8 est pair 10 est pair  Si i n\u0026rsquo;est pas divisible par 2 et donc que i % 2 = 1, ce qui est considéré comme True, continue est appelé et on passe alors directement au i suivant, et donc l\u0026rsquo;instruction print est sautée.\n else On peut faire suivre une boucle for ou while d\u0026rsquo;un bloc introduit par une instruction else. Ce bloc n\u0026rsquo;est exécuté que si la boucle se termine \u0026ldquo;normalement\u0026rdquo;, i.e. sans rencontrer un break.\nPour voir son utilité, reprenons le code repérant la première occurrence d\u0026rsquo;un nombre négatif.\nliste = [5, 2, 99, 0, 100, 2, 37, 43, 124] for i, a in enumerate(liste) : if a \u0026lt; 0 : break print(\u0026#34;L\u0026#39;élément d\u0026#39;indice\u0026#34;,i,\u0026#34;valant\u0026#34;,a,\u0026#34;est le premier élément négatif.\u0026#34;) L'élément d'indice 8 valant 124 est le premier élément négatif.\nOn constate que le programme se comporte bizarrement si la liste ne contient que des nombres positifs.\nUn else va nous sauver :\nliste = [5, 2, 99, 0, 100, 2, 37, 43, 124] for i, a in enumerate(liste) : if a \u0026lt; 0 : print(\u0026#34;L\u0026#39;élément d\u0026#39;indice\u0026#34;,i,\u0026#34;valant\u0026#34;,a,\u0026#34;est le premier élément négatif.\u0026#34;) break else : print(\u0026#34;Aucun élément négatif\u0026#34;) Aucun élément négatif\nAutre exemple d\u0026rsquo;utilisation : une manière peu élégante de déterminer le plus grand diviseur d\u0026rsquo;un nombre.\na = 2019 b = a - 1 while b != 1 : if not a % b : print(\u0026#39;le plus grand diviseur de\u0026#39;,a,\u0026#39;est\u0026#39;,b) break b -= 1 else : print(a,\u0026#39;est premier !\u0026#39;) le plus grand diviseur de 2019 est 673\n  La gestion des exceptions Python distingue deux types d\u0026rsquo;erreurs :\n les erreurs de syntaxe : elles correspondent à des erreurs dans la grammaire du langage et sont toujours fatales. Elles se soldent par un pénible Syntaxerror : invalid syntax ou encore un IndentationError: expected an indented block. Exemple typique : if a = 2 : (au lieu de if a == 2). les exceptions : erreurs non syntaxiques rencontrées pendant l\u0026rsquo;exécution. Exemples : ZeroDivisionError, NameError, TypeError. Elles nes sont pas forcément fatales si on les gère en amont.  Gestion des exceptions : on peut indiquer à l\u0026rsquo;interprète quoi faire s\u0026rsquo;il rencontre une exception lors de l\u0026rsquo;exécution. Pour cela, on utilise les instructions try : et except :.\nLe bloc introduit par try correspond à ce qui doit être exécuté en l\u0026rsquo;absence d\u0026rsquo;exception, et celui introduit par except permet de gérer une exception donnée.\nPrenons l\u0026rsquo;exemple de la gestion d\u0026rsquo;une division par zéro :\nfor i in range(-2,3) : y = 1 / i print(\u0026#39;1 /\u0026#39;,i,\u0026#39;=\u0026#39;,y) 1 / -2 = -0.5\n1 / -1 = -1.0 L\u0026rsquo;exécution a été interrompue\u0026hellip; Mais si on utilise try / except :\nfor i in range(-2,3) : try : y = 1 / i print(\u0026#39;1 /\u0026#39;,i,\u0026#39;=\u0026#39;,y) except ZeroDivisionError : print(\u0026#39;1 / 0 : Division par zéro impossible !\u0026#39;) 1 / -2 = -0.5\n1 / -1 = -1.0\n1 / -1 = -1.0 1 / 0 : Division par zéro impossible !\n1 / 1 = 1.0\n1 / 2 = 0.5\nL\u0026rsquo;exécution va à son terme.\nAutre exemple classique : gérer les entrées farfelues de l\u0026rsquo;utilisateur.\nwhile True: try : x = int(input(\u0026#34;Entrez un nombre svp : \u0026#34;)) break except ValueError : print(\u0026#34;Oops! Pas un nombre valide. Essayez à nouveau... \u0026#34;) On verra un dernier exemple un peu plus touffu dans le chapitre 6 sur la manipulation de fichier.\n"
},
{
	"uri": "https://cordier-info.github.io/tp_python/tp5/",
	"title": "TP5 : Fonctions et Fichiers",
	"tags": [],
	"description": "",
	"content": "TP5 : Fonctions et Fichiers Lien vers le repository GitHub du TP : https://classroom.github.com/a/qRVUwdoz\nExercice 1 Le code suivant essaye de calculer le solde d\u0026rsquo;un compte épargne ayant un taux d\u0026rsquo;intérêt de 5% et un solde initial de 100 € après quatre années.\nsolde = 100 def ajoute_intérêt(solde,taux) : solde += solde * taux/100 for année in range(4) : ajoute_intérêt(100,5) print(\u0026#39;Solde après l\\\u0026#39;année {} : {:.2f} €\u0026#39;.format(année+1,solde)) Solde après l'année 1 : 100.00 € Solde après l'année 2 : 100.00 € Solde après l'année 3 : 100.00 € Solde après l'année 4 : 100.00 €  Expliquer pourquoi cela ne marche pas et trouver une alternative (exo_1.md et exo_1.py)\nQuestion subsidiaire : dans Futurama, Fry a été cryogénisé alors qu\u0026rsquo;il avait 93 cts sur son compte en banque. 1000 ans plus tard, il retourne dans sa banque. Combien lui ont rapporté les 2,25% d\u0026rsquo;intérêt ?Faire afficher le résultat par exo_1.py.\nExercice 2 La portée d\u0026rsquo;un projectile lancé avec un angle $\\alpha$ et une vitesse $v$ depuis le sol sur un terrain plat vaut (si on néglige les frottements, la courbure et la rotation de la Terre) :$d = \\frac{v^2 \\sin 2\\alpha}{g}$où $g$ est la pesanteur ($g = 9,81\\text{ m.s}^{-2}$).La hauteur maximale atteinte par le projectile (la flèche) est :$h = \\frac{v^2 \\sin ^2 \\alpha}{2g}$\nÉcrire dans exo_2.py une fonction qui renvoie la portée et la hauteur atteinte par un projectile en prenant $\\alpha$ et $v$ en argument. Tester la fonction pour $\\alpha = 30°$ et $v=10\\text{ m.s}^{-1}$.\n Exercice 3 Écrire dans exo_3.py deux fonctions prenant chacune en argument deux listes de trois nombres représentant les coordonnées de deux vecteurs et qui renvoient le produit scalaire et le produit vectoriel de ces deux vecteurs.\n Exercice 4 Écrire dans exo_4.py un testeur de tautologie :\n  Écrire d\u0026rsquo;abord une fonction rel_1(a,b) (de signature rel_1(bool,bool)$\\rightarrow$ bool) qui retourne $\\neg(a\\lor b)$ et une fonction rel_2(a,b) (de signature rel_2(bool,bool)$\\rightarrow$ bool) qui retourne $\\neg a \\land \\neg b$.\n  Puis écrire une fonction test_tauto(fct_1,fct_2) (de signature test_tauto(fonction,fonction)$\\rightarrow$ bool) qui teste si l\u0026rsquo;équivalence matérielle (correspondant à l\u0026rsquo;opérateur Python ==) entre deux fonctions logiques (à deux entrées chacune) $\\text{fct}_1(a,b)\\leftrightarrow \\text{fct}_2(a,b)$ est une tautologie (cela revient à déterminer si les deux fonctions sont d\u0026rsquo;accord dans tous les cas possibles, donc si leurs tables de vérité sont les mêmes).\nLa fonction test_tauto prouve donc l\u0026rsquo;équivalence logique entre les deux fonctions logiques : $\\text{fct}_1\\equiv \\text{fct}_2$\n  Prouvez alors la premiere loi de De Morgan : $\\neg(a\\lor b)\\equiv \\neg a\\land\\neg b$.\n  Petit cours sur l\u0026rsquo;algèbre booléenne dans cette vidéo.\n  Exercice 5 De nombreuses données scientifiques se présentent sous forme de tableaux ; une façon simple de les transmettre est de les représenter par un fichier CSV (pour comma-separated value) : il s’agit d’un simple fichier texte, chaque ligne de texte correspondant à une ligne du tableau et un caractère spécial (virgule ou point-virgule le plus souvent) aux séparations entre les colonnes.Le fichier meteo.csvdonne le cumul des précipitations (en mm) et l\u0026rsquo;ensoleillement (en h) pour différentes villes pour l\u0026rsquo;année 2018.Écrire dans exo_5.py un programme qui récupère les données et affiche les villes de la plus pluvieuse à la moins pluvieuse puis les villes de la plus ensoleillée à la moins ensoleillée.Attention, le séparateur décimal de ces données n\u0026rsquo;est pas le point anglo-saxon (utilisé par Python) mais la virgule. Il faudra les remplacer par des points grâce à la méthode de chaine de caractères .replace('ancien','nouveau'). Le séparateur de colonne est, lui, le point-virgule.\n Exercice 6 Compléter le programme exo_6.py pour que le fichier texte créé ( samedi_censure.txt) soit une copie censurée du texte dans samedi.txt; les noms propres \u0026ldquo;Françoise\u0026rdquo;, \u0026ldquo;Mirougrain\u0026rdquo;, \u0026ldquo;Eulalie\u0026rdquo;, \u0026ldquo;Octave\u0026rdquo; et \u0026ldquo;Legrandin\u0026rdquo; devront être remplacés par des astérisques.Ajouter ensuite le texte censuré samedi_censure.txt au repository.\n Exercice 7 En utilisant la librairie PIL, créer un programme (exo_7.py) qui importe l\u0026rsquo;image ascii.jpget la convertit en \u0026ldquo;ASCII art\u0026rdquo; en imprimant à l\u0026rsquo;écran des caractères différents en fonction de la valeur de l\u0026rsquo;intensité moyenne d\u0026rsquo;un pixel.\nExercice 8 Modifier le fichier exo_8.py pour qu\u0026rsquo;il affiche le graphique des patients en réa pour toute la France lorsque l\u0026rsquo;utilisateur tape 0 lors du choix du département.\n"
},
{
	"uri": "https://cordier-info.github.io/cours_python/cours5/",
	"title": "Fonctions",
	"tags": [],
	"description": "",
	"content": "Fonctions Une fonction consiste en un bloc d\u0026rsquo;instructions qui peut être appelé et exécuté à différents endroits et à plusieurs reprises dans le programme.\nDeux avantages à l\u0026rsquo;utilisation de fonctions :\n elles permettent de réutiliser du code sans avoir à le réécrire, elles permettent de décomposer un problème complexe en différentes procédures plus simples, chacune prise en charge par sa propre fonction.  Le code est rendu plus clair et plus facile à débuguer.\n  Définir et appeler une fonction L\u0026rsquo;instruction def initialise la définition d\u0026rsquo;une fonction en lui donnant un nom et des arguments, s\u0026rsquo;il y en a, que la fonction s\u0026rsquo;attendra à recevoir lorsqu\u0026rsquo;elle sera appelée.\nLes instructions de la fonction sont écrites dans un bloc indenté qui suit le def.\nSi à un point quelconque de l\u0026rsquo;exécution du bloc, une instruction return est rencontrée, la valeur spécifiée est renvoyée.\nPar exemple :\ndef carré(x) : x_carré = x**2 return x_carré nombre = 2 nombre_au_carré = carré(nombre) print(nombre,\u0026#39;au carré vaut\u0026#39;,nombre_au_carré) print(\u0026#39;8 au carré vaut\u0026#39;,carré(8)) 2 au carré vaut 4\n8 au carré vaut 64\nPour que la fonction renvoie plus d\u0026rsquo;une valeur, on les emballe dans un tuple.\nExemple : le programme suivant donne les racines d\u0026rsquo;un trinôme du second degré.\nimport math def racines(a,b,c) : d = b**2 - 4*a*c r1 = (-b - math.sqrt(d))/2/a r2 = (-b + math.sqrt(d))/2/a return r1, r2 print(racines(1.,-1.,-6.)) (-2.0, 3.0)\nUne fonction n\u0026rsquo;est pas obligée de renvoyer explicitement un objet. Si la fin du code est atteinte sans rencontrer un return, la valeur spéciale None est renvoyée.\n La définition d\u0026rsquo;une fonction peut être écrite n\u0026rsquo;importe où dans un programme mais une fonction ne peut pas être appelée avant sa définition.\n Les fonctions peuvent aussi être imbriquées mais une fonction définie à l\u0026rsquo;intérieur d\u0026rsquo;une autre fonction ne peut pas être appelée à l\u0026rsquo;extérieur de cette fonction.\n   Chaîne de documentation La première ligne du bloc d\u0026rsquo;une fonction peut servir à la documenter par une chaîne de caractères.\nPour cette chaîne, appelée docstring, il est recommandé d\u0026rsquo;utiliser le triple guillemet qui permet d\u0026rsquo;écrire simplement sur plusieurs lignes.\nExemple :\ndef racines(a,b,c) : \u0026#34;\u0026#34;\u0026#34;Retourne les racines de ax^2 + bx + c.\u0026#34;\u0026#34;\u0026#34; d = b**2 - 4*a*c r1 = (-b - math.sqrt(d))/2/a r2 = (-b + math.sqrt(d))/2/a return r1, r2 Ce docstring devient alors un attribut spécial de la fonction accessible par __doc__.\nracines.__doc__ 'Retourne les racines de ax^2 + bx + c.'\nUne chaîne de documentation devrait expliquer comment utiliser la fonction (quels arguments lui donner et quels objets elle retourne) mais pas détailler son implémentation.\nOn peut à tout moment renommer une fonction :\nrac = racines rac.__doc__ 'Retourne les racines de ax^2 + bx + c.'\n  Argument nommé Dans l\u0026rsquo;exemple précédent, les arguments sont passés à la fonction dans l\u0026rsquo;ordre dans lequel ils apparaissent dans la définition. Si on veut pouvoir les passer dans un ordre arbitraire, on nomme explicitement les arguments :\nracines(a=1., c=-6., b =-1.) (-2.0, 3.0)\nracines(b=-1., c=-6., a =1) (-2.0, 3.0)\n  Valeur par défaut des arguments On peut aussi donner à une fonction un argument \u0026lsquo;optionnel\u0026rsquo; : si l\u0026rsquo;appel de la fonction ne précise pas l\u0026rsquo;argument, une valeur par défaut est fournie.\ndef exprime_longueur(mesure, unité=\u0026#39;m\u0026#39;) : return \u0026#39;La longueur vaut {:.2f} {}\u0026#39;.format(mesure,unité) exprime_longueur(32.831,\u0026#39;cm\u0026#39;) 'La longueur vaut 32.83 cm'\nexprime_longueur(10.1) 'La longueur vaut 10.10 m'\nAttention, les arguments par défaut sont affectés dès que l\u0026rsquo;interprète rencontre la définition pour la première fois. Cela peut amener à des résultats inattendus, en particulier avec des objets muables.\nExemple :\ndef fonc(une_liste = []) : une_liste.append(7) return une_liste print(fonc()) print(fonc()) print(fonc()) [7]\n[7, 7]\n[7, 7, 7]\nComme une variable prenant la valeur d\u0026rsquo;un argument par défaut est affectée au moment de la définition, changer l\u0026rsquo;affectation de la variable ensuite est sans effet sur l\u0026rsquo;argument par défaut.\nunité_par_défaut = \u0026#39;m\u0026#39; def exprime_longueur(mesure, unité = unité_par_défaut) : return \u0026#39;La longueur vaut {:.2f} {}\u0026#39;.format(mesure,unité) exprime_longueur(10.1) 'La longueur vaut 10.10 m'\nunité_par_défaut = \u0026#39;année lumière\u0026#39; exprime_longueur(10.1) 'La longueur vaut 10.10 m'\n  Portée des variables Une fonction peut définir et utiliser ses propres variables. Ces variables sont alors dites locales.\nÀ l\u0026rsquo;inverse, les variables affectées en dehors du bloc d\u0026rsquo;une fonction peuvent être utilisées partout et sont dites globales.\n Exemple :\ndef fct() : a = 5 print(a,b) b = 6 fct() 5 6\nComme b n\u0026rsquo;est pas définie dans la bloc de la fonction, Python va la chercher dans le champ global. Mais il faut que b soit affectée avant l\u0026rsquo;appel de la fonction.\nQue se passe-t-il si une fonction définit une variable locale avec le même nom qu\u0026rsquo;une variable globale ?\nLe champ local est scruté en premier.\nExemple :\ndef fct() : a = 5 print(a) a = 6 fct() print(a) 5\n6\nNotons bien que la variable locale a n\u0026rsquo;existe que dans le bloc de définition, qu\u0026rsquo;elle ait ou non le même nom qu\u0026rsquo;une variable globale ne change rien. Elle disparait quand l\u0026rsquo;interprète sort de la fonction et n\u0026rsquo;écrase donc pas la variable globale a.\nDans l\u0026rsquo;ordre, Python regarde d\u0026rsquo;abord le champ local, puis non local (le champ englobant la fonction intérieure dans le cas de fonctions imbriquées), puis global, puis built-in (les fonctions natives qu\u0026rsquo;il convient donc de ne pas redéfinir).\nUne fonction ne peut pas modifier une variable globale sans préciser qu\u0026rsquo;elle le souhaite.\n Exemple :\nx = 2 def fct1() : print(x) def fct2() : x += 1 print(x) fct1() # pas de problème 2\nfct2() # aïe UnboundLocalError: local variable 'x' referenced before assignment\nPour régler le problème, il faut utiliser le mot clé global pour réaffecter la variable globale dans la fonction.\ndef fct2() : global x x += 1 print(x) fct2() 3\nCe type de réaffectation est néanmoins à éviter, car il amène pas mal de confusion. C\u0026rsquo;est souvent plus logique de passer x en argument de la fonction.\n  Illsutration avec des listes de parts de pizza :\nIl peut être intéressant d\u0026rsquo;utiliser une fonction pour construire une liste des différents termes d\u0026rsquo;une suite définie par récurrence :\n\u0026ldquo;The lazy caterer sequence\u0026rdquo; (la suite du traiteur paresseux en français) est une suite donnant le nombre maximum de morceaux de pizza pouvant être obtenus avec un certain nombre de coupes droites.\nIl est simple de voir que $f(0)=1$, $f(1)=2$ et $f(2)=4$.\nEt on peut déterminer la relation de récurrence suivante :\n$f(n)=f(n-1)+n$\nPour afficher les différents éléments consécutifs de la suite dans une même liste :\ndef f(suite) : suite.append(suite[n-1]+n) suite = [1] for n in range(1,16) : f(suite) # n et suite sont définis dans le champ global print(suite) [1, 2, 4, 7, 11, 16, 22, 29, 37, 46, 56, 67, 79, 92, 106, 121]\n  Fonctions lambda : des fonctions anonymes Avec le mot-clé lambda, vous pouvez créer de petites fonctions anonymes très pratiques pour définir des fonctions mathématiques.\nCes fonctions ne doivent contenir que des expressions. Ainsi, les instructions conditionnelles ou les boucles ou même un print sont interdits.\nExemple :\nf = lambda x : x**2 - 3*x + 2 print(f(4.)) 6.0\nOn peut passer plus d\u0026rsquo;un argument à une fonction lambda grâce à un tuple :\nf = lambda x,y : x**2 + 2*x*y + y**2 f(2.,3.) 25.0\nL\u0026rsquo;explication du terme \u0026ldquo;fonction anonyme\u0026rdquo; prend son sens avec l\u0026rsquo;utilisation de listes de fonctions.\nExemple de construction d\u0026rsquo;une liste de fonctions sans utiliser lambda :\ndef const(x) : return 1. def lin(x) : return x def carré(x) : return x**2 def cube(x) : return x**3 fliste = [const,lin,carré,cube] fliste[3](5) 125\nfliste[3] correspond à la fonction cube et on lui passe l\u0026rsquo;argument 5.\nOn peut aller plus vite avec les fonctions lambda (ici réellement anonymes) :\nfliste = [lambda x : 1, lambda x : x, lambda x : x**2, lambda x : x**3] fliste[3](5) 125\nLes fonctions lambda peuvent aussi se montrer pratiques lorsqu\u0026rsquo;on les associe avec la fonction native sorted().\nEn effet, sorted(liste, key = fonction) peut prendre en argument une fonction via le mot clé key. Cette fonction agit alors sur chaque élément de la liste à trier et sorted() trie la liste en fonction du résulat.\nExemple :\nhalogènes = [(\u0026#39;At\u0026#39;,85),(\u0026#39;Br\u0026#39;,35),(\u0026#39;Cl\u0026#39;,17),(\u0026#39;F\u0026#39;,9),(\u0026#39;I\u0026#39;,53)] Si on veut trier cette liste de tuples contenant le symbole d\u0026rsquo;un élément halogène et son numéro atomique par numéro atomique croissant on peut utiliser une fonction lambda dont le rôle est de récupérer le 2e élément de chaque tuple (= chaque élément de la liste) :\nsorted(halogènes, key = lambda e : e[1]) [('F', 9), ('Cl', 17), ('Br', 35), ('I', 53), ('At', 85)]\n  Les assertions Les assertions sont un moyen simple de s\u0026rsquo;assurer, avant de continuer, qu\u0026rsquo;une condition est respectée.\nOn utilise la syntaxe : assert test. Si le test renvoie True, l\u0026rsquo;exécution se poursuit normalement. Sinon, une exception AssertionError est levée. On peut utiliser les assertions pour s\u0026rsquo;assurer que les arguments d\u0026rsquo;une fonction vont permettre son exécution.\nOn peut par exemple reprendre la définition de la fonction racines pour s\u0026rsquo;assurer que les arguments passés sont bien des nombres (et renvoyer un message explicatif si ce n\u0026rsquo;est pas le cas) :\ndef racines(a,b,c) : \u0026#34;\u0026#34;\u0026#34;Retourne les racines de ax^2 + bx + c.\u0026#34;\u0026#34;\u0026#34; assert (type(a) is (float or int)) and (type(b) is (float or int)) and (type(c) is (float or int)),\\ \u0026#34;les arguments de la fonction \u0026#39;racines\u0026#39; doivent être des nombres !\u0026#34; d = b**2 - 4*a*c r1 = (-b - math.sqrt(d))/2/a r2 = (-b + math.sqrt(d))/2/a return r1, r2 racines(1,6,'-1') AssertionError: les arguments de la fonction racines doivent être des nombres !\n"
},
{
	"uri": "https://cordier-info.github.io/tp_python/tp6/",
	"title": "TP6 : Projets",
	"tags": [],
	"description": "",
	"content": "TP6 - Projets Lien vers le repository GitHub du TP : https://classroom.github.com/a/v7xsQyLB\nProjet 1 : Jeu de Nim Avec l\u0026rsquo;aide de la première partie de cette vidéo ou de toute autre source, découvrir l\u0026rsquo;algorithme de Bouton permettant de gagner au jeu de Nim. Construire ensuite un programme qui :\n propose au joueur de construire le jeu de Nim qu\u0026rsquo;il souhaite (nombre de lignes et nombre de jetons par ligne), choisit de commencer ou non pour s\u0026rsquo;assurer une position gagnante (la machine doit gagner), laisse l\u0026rsquo;humain décider des jetons qu\u0026rsquo;il veut retirer (choix de la ligne, choix du nombre de jetons) lorsque c\u0026rsquo;est son tour puis joue de manière optimale lorsque c\u0026rsquo;est le tour de la machine… Jusqu\u0026rsquo;à gagner, affiche la disposition des jetons à chaque tour.  Le corps du programme doit contenir (cf. projet_1.py) :\nnim = initialise() affiche(nim) while sum(nim) != 0 : ns = nim_somme(nim) if ns == 0 : nim = tour_humain(nim) else : nim = tour_machine(nim,ns) affiche(nim) print(\u0026#34;Vous avez perdu...\\n\u0026#34;) Reste à écrire les différentes fonctions\u0026hellip;\nProjet 2 : Compression Les fichiers image portable bitmap file format .pbm sont extrèmement simples. C\u0026rsquo;est juste un texte ASCII qui comporte :\n un nombre magique indiquant le format : P1 la largeur $L$ et la hauteur $H$ de l\u0026rsquo;image : 5 3 dans l\u0026rsquo;exemple puis une suite de $L\\times H$ (= 15 dans notre cas) 1 et 0 correspondants à des pixels noirs ou blancs.  Le fichier exemple.pbm contient ainsi le texte :\nP1 5 6 11111 10101 11111 10101 10001 11111 Et il ressemble à :\n Première mission : Vous allez écrire un programme dans projet_2a.py qui convertit l\u0026rsquo;image jpeg couleur Darwin.jpg en fichier .pbm. Il faudra au préalable convertir chaque pixel de l\u0026rsquo;image d\u0026rsquo;origine en un pixel noir ou blanc (s\u0026rsquo;inspirer du cours).\nEnregistrer le fichier créé sous le nom imageNB.pbm et le copier dans le repository.\nCertes, ce format est simple et universel mais il a le défaut de prendre beaucoup plus de place mémoire que nécessaire. La raison en est l\u0026rsquo;utilisation de caractères texte pour encoder l\u0026rsquo;information. Les caractères \u0026quot;1\u0026quot; et \u0026quot;0\u0026quot; par exemple utilisent 8 bits plutôt que 1.\nMais l\u0026rsquo;objectif est d\u0026rsquo;aller plus loin que cette simple substitution en implémentant une réelle compression (quasi optimale) du fichier imageNB.pbm créé.\n Deuxième mission : Commencer par lire l'article de Tangente sur l'algorithme glouton et/ou regarder cette vidéo.\nFaire un premier programme projet_2b.py qui détermine les fréquences des différents caractères utilisés dans le fichier imageNB.pbm ('0', '1', 'P', '7', '9', 6, \\n et ' '\u0026hellip; Attention, le retour à la ligne et l\u0026rsquo;espace sont des caractères comme les autres).\nConstruire à la main l\u0026rsquo;arbre de Huffman pour ces 8 caractères en suivant la méthode indiquée dans l\u0026rsquo;article ou la vidéo et en déduire les 8 codes binaires qui remplaceront les 8 caractères dans le fichier compressé. Les noter dans le fichier projet_2b.md.\nConstruire un programme projet_2c.py qui remplace chaque caractère du fichier à compresser par son code binaire puis qui écrit ce code binaire dans un fichier de données imageNB_comp.dat.Méthode pour écrire dans un fichier en binaire :\nf = open(\u0026#39;imageNB_comp.dat\u0026#39;,\u0026#39;wb\u0026#39;) # s : chaîne de caractères obtenue en remplaçant chaque caractère # du fichier original par son code issu de l\u0026#39;arbre s = \u0026#39;1001110011...\u0026#39; # b est la transcription de ce code en bytes b = bytes(int(s[i : i + 8], 2) for i in range(0, len(s), 8)) # puis on l\u0026#39;écrit dans f f.write(b) f.close() Comparer et commenter les tailles des fichiers imageNB.pbm et imageNB_comp.dat. Comment se fait-il que le fichier jpeg de départ ait une taille comparable au fichier compressé alors qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;une image couleur (émettre une ou des hypothèses) ? Vous noterez tout ça dans projet_2c.md.\nEnfin, écrire un programme projet_2d.py qui décompresse imageNB_comp.dat en un fichier imageNB_decomp.pbm et vérifier à sa taille qu\u0026rsquo;il n\u0026rsquo;y a pas eu perte d\u0026rsquo;information.\nMéthode pour lire un fichier en binaire et récupérer le résultat sous la forme d\u0026rsquo;un chaîne de caractères constituée de '1' et de '0' :\nf = open(\u0026#39;imageNB_comp.dat\u0026#39;,\u0026#39;rb\u0026#39;) code_bytes = f.read() f.close() code_texte = \u0026#39;\u0026#39; for b in code_bytes : code_texte += format(b,\u0026#39;08b\u0026#39;) # on obtient le texte codé (avec seulement des 1 et des 0) "
},
{
	"uri": "https://cordier-info.github.io/cours_python/cours6/",
	"title": "Manipulation de fichiers",
	"tags": [],
	"description": "",
	"content": "Manipulation de fichiers Interaction avec le système d\u0026rsquo;exploitation Le module os offre la possibilité d\u0026rsquo;interagir avec le système d\u0026rsquo;exploitation indépendamment de la plateforme utilisée.\n os.getcwd() renvoie le répertoire courant (répertoire depuis lequel le programme est exécuté) sous forme de chaîne.  import os os.getcwd() '/Users/cordiermarc/Documents/prof/informatique/Python_6'\n os.chdir('répertoire') permet de changer le répertoire courant pour le répertoire donné en argument. On peut soit donner le chemin absolu (qui commence par la racine, / sur un système Unix) soit un chemin relatif (qui commence par . pour désigner le répertoire courant).  os.chdir(\u0026#39;/Users/cordiermarc/Documents\u0026#39;) os.getcwd() '/Users/cordiermarc/Documents'\nos.chdir(\u0026#39;./prof/informatique/Python_6\u0026#39;) os.getcwd() '/Users/cordiermarc/Documents/prof/informatique/Python_6'\n os.listdir('répertoire') permet de connaître le contenu d\u0026rsquo;un répertoire. Le nom raccourci du répertoire courant est '.'.  os.listdir(\u0026#39;.\u0026#39;) ['.DS_Store', 'puissances.txt', 'images', 'monfichier.rtf', 'monfichier.txt', 'cours6.ipynb', 'ensoleillement.txt', '.ipynb_checkpoints']   os.path est un sous-module qui propose plusieurs fonctions permettant de jouer avec les chemins d\u0026rsquo;accès et les noms de fichier. On en verra un exemple d\u0026rsquo;utilisation à la fin du document.    Lecture et écriture de fichiers Jusque-là, les différentes données de nos programmes étaient directement écrites dans le code et les sorties s\u0026rsquo;affichaient sur le shell.\nMais il est souvent plus utile d\u0026rsquo;importer des données ou d\u0026rsquo;écrire les sorties dans des fichiers plutôt que sur l\u0026rsquo;écran. Pour cela, Python utilise l\u0026rsquo;objet file.\n  Ouvrir et fermer un fichier Un objet file est créé par l\u0026rsquo;utilisation de la fonction open(nom du fichier,mode) qui prend deux arguments.\nf = open(\u0026#39;monfichier.txt\u0026#39;,\u0026#39;w\u0026#39;)   Le premier argument, nom du fichier, est une chaîne contenant le nom du fichier. Ce nom peut être donné avec le chemin d\u0026rsquo;accès absolu ou seulement l\u0026rsquo;arborescence relative au dossier dans lequel le programme est exécuté. En écrivant un nom sans chemin, le fichier se trouve dans le répertoire courant.\n  Le deuxième argument, mode, est une chaîne d\u0026rsquo;un ou deux caractères décrivant la façon dont le fichier est utilisé.\nmode peut être r quand le fichier n\u0026rsquo;est accédé qu\u0026rsquo;en lecture, w en écriture seulement (un fichier existant portant le même nom sera alors écrasé) et a ouvre le fichier en mode ajout (toute donnée écrite dans le fichier est automatiquement ajoutée à la fin). r+ ouvre le fichier en mode lecture/écriture. L\u0026rsquo;argument mode est optionnel, sa valeur par défaut est r.\nb collé à la fin du mode indique que le fichier doit être ouvert en mode binaire c\u0026rsquo;est-à-dire que les données sont lues et écrites sous forme d\u0026rsquo;octets (type bytes). Ce mode est à utiliser pour les fichiers contenant autre chose que du texte.\n  Les objets file sont fermés grâce à la méthode close() : f.close() par exemple. Python ferme les fichiers automatiquement lorsque le programme se termine.\n  Écrire dans un fichier La méthode write() d\u0026rsquo;un objet file écrit une chaîne de caractères dans le fichier et renvoie le nombre de caractères inscrits.\nf.write(\u0026#39;Coucou monde !\u0026#39;) 14\nPlus pratique, la fonction native print() peut accepter en argument un objet file. Plutôt que d\u0026rsquo;être affichée sur le shell, la sortie de print() est alors redirigée vers ce fichier.\nprint(\u0026#39;\\n\u0026#39;, 35, \u0026#39;Cl\u0026#39;, 2, sep=\u0026#39;\u0026#39;, file=f) f.close() Exemple : le programme suivant écrit les quatre premières puissances de tous les entiers entre 1 et 1000, chaque champ étant séparé par une virgule, dans le fichier puissances.txt.\nfi = open(\u0026#39;puissances.txt\u0026#39;,\u0026#39;w\u0026#39;) for i in range(1,1001) : print(i, i**2, i**3, i**4, sep=\u0026#39;, \u0026#39;, file=fi) fi.close()   Lire un fichier Pour lire n bytes d\u0026rsquo;un fichier, on utilise f.read(n). En omettant n, tout le fichier est lu.\nreadline() lit une seule ligne d\u0026rsquo;un fichier jusqu\u0026rsquo;au, en l\u0026rsquo;incluant, caractère \\n de nouvelle ligne. Un nouvel appel de readline() lit la ligne suivante et ainsi de suite. read() et readline() renvoie toutes les deux une chaîne vide lorsque la fin du fichier est atteinte.\nPour lire en une fois toutes les lignes dans une liste de chaînes, on utilise f.readlines().\nLes objet file sont itérables. On peut ainsi retourner chaque ligne d\u0026rsquo;un fichier une à une en utilisant une boucle :\nf = open(\u0026#39;monfichier.txt\u0026#39;) for ligne in f : print(ligne, end=\u0026#39;\u0026#39;) f.close() Coucou monde ! 35Cl2  Comme ligne contient déjà le caractère de nouvelle ligne lorsqu\u0026rsquo;elle est lue, on utilise end = '' pour empêcher print d\u0026rsquo;en ajouter un autre.\nCette méthode de lecture ligne à ligne est à privilégier pour les gros fichiers à moins de vraiment vouloir contenir en mémoire l\u0026rsquo;ensemble du fichier.\nPour lire les nombres du fichier 'puissance.txt' écrit précédemment, les colonnes doivent être converties en une liste d\u0026rsquo;entiers.\nPour cela, chaque ligne doit être décomposée en ses différents champs et chaque champ explicitement converti en entier grâce à int() :\nfo = open(\u0026#39;puissances.txt\u0026#39;) carrés, cubes, puiss4 = [],[],[] lignes = fo.readlines() fo.close() for ligne in lignes : champs = ligne.split(\u0026#39;,\u0026#39;) carrés.append(int(champs[1])) cubes.append(int(champs[2])) puiss4.append(int(champs[3])) n = 500 print(n, \u0026#39;au cube vaut\u0026#39;, cubes[n-1]) 500 au cube vaut 125000000  Mais en pratique, il vaut mieux utiliser les bibliothèques NumPy (2e semestre) ou Pandas pour des fichiers de données comme celui-ci.\nVous apprendrez aussi à utiliser les méthodes des bases de données.\n  La fonction suivante permet d\u0026rsquo;ouvrir proprement un fichier en gérant l\u0026rsquo;exception qui serait levée par sa non présence et d\u0026rsquo;afficher quelques informations :\ndef ouverture(nom_du_fichier) : try : fichier = open(nom_du_fichier,\u0026#39;r\u0026#39;) except IOError : print(\u0026#34;Oups ! Fichier absent...\u0026#34;) return else : # bloc exécuté seulement si l\u0026#39;exception n\u0026#39;est pas rencontrée lignes = fichier.readlines() print(\u0026#39;{} contient {} lignes.\u0026#39;.format(nom_du_fichier,len(lignes))) fichier.close() finally : # bloc exécuté dans tous les cas (que le fichier ait été ouvert ou non) print(\u0026#39;Terminé avec le fichier {}\u0026#39;.format(nom_du_fichier)) print(\u0026#39;La première ligne de {} est:\\n{}\u0026#39;.format(nom_du_fichier,lignes[0])) # autres instructions return  Dans cet autre exemple, on va créer un petit gif qui illustre le théorème de La Hire :\nle programme produit un nouveau dossier petitgif dans lequel il crée 40 fichiers svg aux noms incrémentés (de fig00.svg à fig39.svg) décrivant des cercles et des segments.\nLe svg pour Scalable Vector Graphics est un format de données ASCII, donc texte, conçu pour décrire des ensembles de graphiques vectoriels et basé sur le XML, un langage utilisant des balises \u0026lt;...\u0026gt;.\nimport math nfigs = 40 # on crée un répertoire \u0026#39;petigif\u0026#39; à partir du répertoire courant s\u0026#39;il n\u0026#39;existe pas déjà rép_actuel = os.getcwd() nv_rép = os.path.join(rép_actuel, \u0026#39;petitgif\u0026#39;) if not os.path.exists(nv_rép): os.mkdir(nv_rép) hauteur_cadre, largeur_cadre = 500, 500 # positions du centre du grand cercle : cx, cy = hauteur_cadre / 2, largeur_cadre / 2 # rayons des trois cercles r1, r2, r3 = 200, 100, 10 # liste d\u0026#39;angles pour faire tourner le petit disque : alphas = [2*math.pi / nfigs * n for n in range(nfigs)] for n, alpha in enumerate(alphas): filename = os.path.join(nv_rép, \u0026#39;fig{:02d}.svg\u0026#39;.format(n)) image = open(filename, \u0026#39;w\u0026#39;) # En-tête du fichier SVG : print(\u0026#34;\u0026#34;\u0026#34;\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; width=\u0026#34;{}\u0026#34; height=\u0026#34;{}\u0026#34; style=\u0026#34;background: {}\u0026#34;\u0026gt;\u0026#34;\u0026#34;\u0026#34;.format(hauteur_cadre, largeur_cadre, \u0026#39;#ffffff\u0026#39;), file=image) # grand cercle bleu : print(\u0026#39;\u0026lt;circle cx=\u0026#34;{}\u0026#34; cy=\u0026#34;{}\u0026#34; r=\u0026#34;{}\u0026#34; style=\u0026#34;stroke: blue; stroke-width: 2px; fill: none;\u0026#34;/\u0026gt;\u0026#39;.format(cx, cy, r1),file=image) # grands diamètres 1 à 4 : print(\u0026#39;\u0026lt;line x1=\u0026#34;{}\u0026#34; y1=\u0026#34;{}\u0026#34; x2=\u0026#34;{}\u0026#34; y2=\u0026#34;{}\u0026#34; stroke=\u0026#34;blue\u0026#34; /\u0026gt;\u0026#39;.format(cx,cy-r1,cx,cy+r1), file=image) print(\u0026#39;\u0026lt;line x1=\u0026#34;{}\u0026#34; y1=\u0026#34;{}\u0026#34; x2=\u0026#34;{}\u0026#34; y2=\u0026#34;{}\u0026#34; stroke=\u0026#34;blue\u0026#34; /\u0026gt;\u0026#39;.format(cx-r1,cy,cx+r1,cy), file=image) print(\u0026#39;\u0026lt;line x1=\u0026#34;{}\u0026#34; y1=\u0026#34;{}\u0026#34; x2=\u0026#34;{}\u0026#34; y2=\u0026#34;{}\u0026#34; stroke=\u0026#34;blue\u0026#34; /\u0026gt;\u0026#39;.format(cx+r1*math.cos(math.pi/4),cy+r1*math.sin(math.pi/4),cx-r1*math.cos(math.pi/4),cy-r1*math.sin(math.pi/4)), file=image) print(\u0026#39;\u0026lt;line x1=\u0026#34;{}\u0026#34; y1=\u0026#34;{}\u0026#34; x2=\u0026#34;{}\u0026#34; y2=\u0026#34;{}\u0026#34; stroke=\u0026#34;blue\u0026#34; /\u0026gt;\u0026#39;.format(cx+r1*math.cos(-math.pi/4),cy+r1*math.sin(-math.pi/4),cx-r1*math.cos(-math.pi/4),cy-r1*math.sin(-math.pi/4)), file=image) # cercle rouge à l\u0026#39;intérieur du cercle bleu déplacé d\u0026#39;un angle alpha à chaque itération  cx2, cy2 = cx + (r1-r2) * math.cos(alpha), cy + (r1-r2) * math.sin(alpha) print(\u0026#39;\u0026lt;circle cx=\u0026#34;{}\u0026#34; cy=\u0026#34;{}\u0026#34; r=\u0026#34;{}\u0026#34; style=\u0026#34;stroke: red; fill: none; \u0026#34;/\u0026gt;\u0026#39;.format(cx2, cy2, r2), file=image) cx3, cy3 = cx + r1 * math.cos(alpha), cy cx4, cy4 = cx , cy + r1 * math.sin(alpha) cx5, cy5 = cx + r1 * math.cos(alpha+math.pi/4)*math.cos(math.pi/4), cy - r1 * math.cos(alpha+math.pi/4)*math.sin(math.pi/4) cx6, cy6 = cx + r1 * math.sin(alpha+math.pi/4)*math.cos(math.pi/4) , cy + r1 * math.sin(alpha+math.pi/4)*math.sin(math.pi/4) # petits diamètres 1 et 2 : print(\u0026#39;\u0026lt;line x1=\u0026#34;{}\u0026#34; y1=\u0026#34;{}\u0026#34; x2=\u0026#34;{}\u0026#34; y2=\u0026#34;{}\u0026#34; stroke=\u0026#34;red\u0026#34; /\u0026gt;\u0026#39;.format(cx3,cy3,cx4,cy4), file=image) print(\u0026#39;\u0026lt;line x1=\u0026#34;{}\u0026#34; y1=\u0026#34;{}\u0026#34; x2=\u0026#34;{}\u0026#34; y2=\u0026#34;{}\u0026#34; stroke=\u0026#34;red\u0026#34; /\u0026gt;\u0026#39;.format(cx5,cy5,cx6,cy6), file=image) # 4 petits disques :  print(\u0026#39;\u0026lt;circle cx=\u0026#34;{}\u0026#34; cy=\u0026#34;{}\u0026#34; r=\u0026#34;{}\u0026#34; style=\u0026#34;stroke: purple; fill: purple;\u0026#34;/\u0026gt;\u0026#39;.format(cx3, cy3, r3), file=image) print(\u0026#39;\u0026lt;circle cx=\u0026#34;{}\u0026#34; cy=\u0026#34;{}\u0026#34; r=\u0026#34;{}\u0026#34; style=\u0026#34;stroke: purple; fill: purple;\u0026#34;/\u0026gt;\u0026#39;.format(cx4, cy4, r3), file=image) print(\u0026#39;\u0026lt;circle cx=\u0026#34;{}\u0026#34; cy=\u0026#34;{}\u0026#34; r=\u0026#34;{}\u0026#34; style=\u0026#34;stroke: purple; fill: purple;\u0026#34;/\u0026gt;\u0026#39;.format(cx5, cy5, r3), file=image) print(\u0026#39;\u0026lt;circle cx=\u0026#34;{}\u0026#34; cy=\u0026#34;{}\u0026#34; r=\u0026#34;{}\u0026#34; style=\u0026#34;stroke: purple; fill: purple;\u0026#34;/\u0026gt;\u0026#39;.format(cx6, cy6, r3), file=image) print(\u0026#39;\u0026lt;/svg\u0026gt;\u0026#39;, file=image) On peut utiliser ensuite le logiciel libre ImageMagick software qui permet de créer un gif à partir d\u0026rsquo;une série d\u0026rsquo;images via la ligne de commande (une fois dans le répertoire petitgif) :\nconvert -delay 5 -loop 0 fig*.svg animation.gif\n  Fichiers image Grâce à la librairie PIL (python imaging library) Python permet aussi de manipuler des fichiers image.\nLes fonctions de ce module permettent d\u0026rsquo;avoir accès aux pixels d\u0026rsquo;une image par leurs coordonnées cartésiennes (colonne,ligne) :\nfrom PIL import Image image = Image.open(\u0026#39;images/Darwin.jpg\u0026#39;) largeur, hauteur = image.size print(\u0026#39;largeur : {} pixels, hauteur : {} pixels\u0026#39;.format(largeur,hauteur)) largeur : 700 pixels, hauteur : 967 pixels\npixels_image = image.load() pixels_image[23,102] (90, 78, 66)\nChaque pixel contient un tuple de 3 éléments codant sa couleur au format RGB : chacune des 3 couleurs primaires, rouge, vert et bleu, est codée par un byte de 8 bits autorisant donc 256 valeurs (0 pour le noir, 255 pour la couleur saturée). Cela fait en tout une palette de $256^3$ soit plus de 16 millions de couleurs.\n Supposons que l\u0026rsquo;on souhaite transformer une photo en couleur en une photo noir et blanc (ou plutôt en niveaux de gris).\nOn peut commencer par définir une fonction intensité_moyenne(pixel) qui fait la moyenne des intensités des 3 couleurs de chaque pixel. Puis on affecte cette valeur unique à chacune des intensités des 3 couleurs dans une nouvelle image (cela donne une teinte plus ou moins foncée de gris).\ndef intensité_moyenne(pixel) : Imoy = (pixel[0]+pixel[1]+pixel[2])/3 return int(Imoy) image_NB = Image.new(\u0026#34;RGB\u0026#34;, (largeur, hauteur), \u0026#34;black\u0026#34;) pixels_image_NB = image_NB.load() for i in range(largeur) : for j in range(hauteur) : Imoy = intensité_moyenne(pixels_image[i,j]) pixels_image_NB[i,j] = (Imoy,Imoy,Imoy) print(pixels_image[23,102],pixels_image_NB[23,102]) image_NB.save(\u0026#39;images/Darwin_N\u0026amp;B.jpg\u0026#39;) (90, 78, 66) (78, 78, 78)\nOn peut aussi créer une image à partir de rien comme dans cet exemple où la couleur des pixels dépend de leurs positions :\nimg = Image.new( \u0026#39;RGB\u0026#39;, (250,250), \u0026#34;black\u0026#34;) pixels = img.load() for i in range(img.size[0]): for j in range(img.size[1]): pixels[i,j] = (i, j, 100) img   Interaction avec l\u0026rsquo;utilisateur : la fonction input() La plupart des scripts élaborés nécessitent à un moment ou à un autre une intervention de l\u0026rsquo;utilisateur (entrée d\u0026rsquo;un paramètre, clic de souris sur un bouton, etc.). Dans un script en mode texte (comme ceux que nous avons créés jusqu\u0026rsquo;à présent), la méthode la plus simple consiste à employer la fonction native input(). Cette fonction provoque une interruption dans le programme courant. L\u0026rsquo;utilisateur est invité à entrer des caractères au clavier et à terminer avec \u0026lt;Enter\u0026gt;. Lorsque cette touche est enfoncée, l\u0026rsquo;exécution du programme se poursuit, et la fonction fournit en retour une valeur correspondant à ce que l\u0026rsquo;utilisateur a entré. Cette valeur peut alors être assignée à une variable quelconque.\nSi un argument est donné, il est affiché à l\u0026rsquo;écran :\nprint(\u0026#34;Quel est votre film préféré ?\u0026#34;) s = input(\u0026#39;--\u0026gt;\u0026#39;) Quel est votre film préféré ?\n--\u0026gt; La Vie de Brian\ns 'La Vie de Brian'\ninput() convertit ce qui a été entré au clavier en chaîne de caractères. Si on attend d\u0026rsquo;autres types de données, il faut utiliser les fonctions de conversion int() ou float :\na = int(input(\u0026#39;Choisir un chiffre :\u0026#39;)) a*2 Choisir un chiffre : 4\n8\na = float(input(\u0026#39;Choisir un chiffre :\u0026#39;)) a*2 Choisir un chiffre : 2\n4.0\n  Récupérer des données sur le web Exemple de programme :\nimport requests import matplotlib.pyplot as plt import matplotlib.dates as mdates from dateutil.parser import parse dep = input(\u0026#34;Numéro du département ? \u0026#34;) # données gouvernementales covid url = \u0026#34;https://www.data.gouv.fr/fr/datasets/r/63352e38-d353-4b54-bfd1-f1b3ee1cabd7\u0026#34; download = requests.get(url) brut = download.content.decode(\u0026#39;utf-8\u0026#39;) # pour transformer les bytes récupérés en string lignes = brut.split(\u0026#39;\\n\u0026#39;) date, hosp = [],[] for ligne in lignes[1:-1:3] : # on saute l\u0026#39;en-tête et ne garde que les sexes 0 correspondant à la somme féminin+masculin champs = ligne.split(\u0026#39;;\u0026#39;) if champs[0] == \u0026#39;\u0026#34;{}\u0026#34;\u0026#39;.format(dep) : date.append(parse(champs[2].strip(\u0026#39;\u0026#34;\u0026#39;))) # parse() sert à convertir la chaîne de caractères en une date hosp.append(int(champs[4])) # liste noms des départements url2 = \u0026#34;https://static.data.gouv.fr/resources/departements-et-leurs-regions/20190815-175403/departements-region.csv\u0026#34; download2 = requests.get(url2) brut2 = download2.content.decode(\u0026#39;utf-8\u0026#39;) lignes2 = brut2.split(\u0026#39;\\n\u0026#39;) for li in lignes2 : ch = li.split(\u0026#39;,\u0026#39;) if ch[0]==str(dep) : nom_dep = ch[1] fig, ax = plt.subplots(figsize=(15,10)) ax.plot(date,hosp) plt.title(\u0026#34;Patients Covid en réa en {}\u0026#34;.format(nom_dep), fontsize=16) ax.xaxis.set_major_formatter(mdates.DateFormatter(\u0026#39;%d/%m\u0026#39;)) ax.xaxis.set_major_locator(mdates.DayLocator(interval=10)) fig.autofmt_xdate() plt.show() "
},
{
	"uri": "https://cordier-info.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cordier-info.github.io/cours_python/",
	"title": "Cours Python",
	"tags": [],
	"description": "",
	"content": "Cours Python Les bases (et un peu plus\u0026hellip;)\n"
},
{
	"uri": "https://cordier-info.github.io/",
	"title": "Sommaire",
	"tags": [],
	"description": "",
	"content": "flowchart TB A00(Résumé cours 1) subgraph cours1 [Cours 1 : Bases] A1(Shell et IDE) \u0026 A2(Installation) \u0026 A3(Types de nombres) \u0026 A4(Arithmétique de base) \u0026 A5(Méthodes et attributs) \u0026 A6(Fonctions mathématiques) \u0026 A7(Variables) \u0026 A8(Comparaison et logique) \u0026 A9(type None) end B00(Résumé cours 2) subgraph cours2 [Cours 2 : Chaînes de caractères] B1(Définir une chaîne de caractères) \u0026 B2(Caractères d'échappement) \u0026 B3(Indexation et slicing) \u0026 B4(Méthodes liées aux chaînes) \u0026 B5(La fonction print) \u0026 B6(Formatage) end TP2(TP2) A00 -.- cours1 -- TP2 B00-.-cours2 -- TP2 C00(Résumé cours 3) subgraph cours3 [Cours 3 : Séquences et itérables] C1(Séquences) \u0026 C2(Objets itérables) C1 -.- C11(Listes) \u0026 C12(Tuples) C2 -.- C21(range) \u0026 C22(enumerate) \u0026 C23(zip) \u0026 C24(Ensembles) \u0026 C25(Dictionnaires) C11-.- C111(Indexation) \u0026 C112(Slicing) \u0026 C113(Mutablité) \u0026 C114(Méthodes) C1 -.- C2 C3(Boucle for) C3 -.- C2 C4(Listes par compréhension) end TP3(TP3) C00-.-cours3 -- TP3 D00(Résumé cours 4) subgraph cours4 [Cours 4 : Structures de contrôle] D1(if, elif, else) \u0026 D2(Boucles while) \u0026 D3(break, continue et else) \u0026 D4(Gestion des exceptions) end TP4(TP4) D00-.-cours4-- TP4 E00(Résumé cours 5) subgraph cours5 [Cours 5 : Fonctions] E1(Définir et appeler) \u0026 E2(Chaîne de documentation) \u0026 E3(Argument nommé) \u0026 E4(Valeur par défaut des arguments) \u0026 E5(Portée des variables) \u0026 E6(Fonctions lambda) \u0026 E7(Les assertions) end subgraph cours6 [Cours 6 : Manipulation de fichiers] F1(Interaction avec l'OS) \u0026 F2(Lecture et écriture) \u0026 F3(Fichiers images) \u0026 F4(Interaction avec l'utilisateur) \u0026 F5(Récupérer des données sur le web) F2-.- F21(Ouvrir et fermer un fichier) \u0026 F22(Ecrire dans un fichier) \u0026 F23(Lire un fichier) end TP5(TP5) E00-.-cours5 cours5 \u0026 cours6 -- TP5 TP2 \u0026 TP3 \u0026 TP4 \u0026 TP5 -- TP6(TP6 : Projets) click A1 \"/cours_python/cours1/\" click A2 \"/cours_python/cours1/#installation\" click A3 \"/cours_python/cours1/#types-de-nombres\" click A4 \"/cours_python/cours1/#arithmetique\" click A5 \"/cours_python/cours1/#methodes\" click A6 \"/cours_python/cours1/#fmathematiques\" click A7 \"/cours_python/cours1/#variables\" click A8 \"/cours_python/cours1/#comparaison-et-logique\" click A9 \"/cours_python/cours1/#type-none\" click B1 \"/cours_python/cours2/\" click B2 \"/cours_python/cours2/#echappement\" click B3 \"/cours_python/cours2/#indexation-et-slicing\" click B4 \"/cours_python/cours2/#methodeschaines\" click B5 \"/cours_python/cours2/#la-fonction-print\" click B6 \"/cours_python/cours2/#formatage\" click C1 \"/cours_python/cours3/\" click C11 \"/cours_python/cours3/\" click C111 \"/cours_python/cours3/#indexation\" click C112 \"/cours_python/cours3/#slicing\" click C113 \"/cours_python/cours3/#mutabilite\" click C114 \"/cours_python/cours3/#methodes\" click C12 \"/cours_python/cours3/#tuples\" click C2 \"/cours_python/cours3/#iterables\" click C21 \"/cours_python/cours3/#range\" click C22 \"/cours_python/cours3/#enumerate\" click C23 \"/cours_python/cours3/#zip\" click C24 \"/cours_python/cours3/#ensembles\" click C25 \"/cours_python/cours3/#dictionnaires\" click C3 \"/cours_python/cours3/#boucle-for\" click C4 \"/cours_python/cours3/#comprehension\" click D1 \"/cours_python/cours4/\" click D2 \"/cours_python/cours4/#boucles-while\" click D3 \"/cours_python/cours4/#break-continue-et-else\" click D4 \"/cours_python/cours4/#la-gestion-des-exceptions\" click E1 \"/cours_python/cours5/\" click E2 \"/cours_python/cours5/#chainededocumentation\" click E3 \"/cours_python/cours5/#argumentnomme\" click E4 \"/cours_python/cours5/##valeurpardefaut\" click E5 \"/cours_python/cours5/#porteedesvariables\" click E6 \"/cours_python/cours5/#fonctions-lambda--des-fonctions-anonymes\" click E7 \"/cours_python/cours5/#les-assertions\" click F1 \"/cours_python/cours6/\" click F2 \"/cours_python/cours6/#lectureetecriture\" click F21 \"/cours_python/cours6/#lectureetecriture\" click F22 \"/cours_python/cours6/#ecrire\" click F23 \"/cours_python/cours6/#lire-un-fichier\" click F3 \"/cours_python/cours6/#fichiers-image\" click F4 \"/cours_python/cours6/#interaction-avec-lutilisateur--la-fonction-input\" click F5 \"/cours_python/cours6/#web\" click TP2 \"/tp_python/tp2/\" click TP3 \"/tp_python/tp3/\" click TP4 \"/tp_python/tp4/\" click TP5 \"/tp_python/tp5/\" click TP6 \"/tp_python/tp6/\" click A00 \"http://cordier-phychi.toile-libre.org/Info/cours1_pres\" click B00 \"http://cordier-phychi.toile-libre.org/Info/cours2_pres\" click C00 \"http://cordier-phychi.toile-libre.org/Info/cours3_pres\" click D00 \"http://cordier-phychi.toile-libre.org/Info/cours4_pres\" click E00 \"http://cordier-phychi.toile-libre.org/Info/cours5_pres\" classDef important fill:#f88,stroke:#f66,stroke-width:2px,color:#fff; classDef resume fill:#5af,stroke:#66f,stroke-width:2px,color:#fff; classDef TP fill:#cfc,stroke:#2a2,stroke-width:2px; class A00,B00,C00,D00,E00 resume; class A7,B3,C11,C3,D1,D2,E1,E5 important; class TP2,TP3,TP4,TP5,TP6 TP;  "
},
{
	"uri": "https://cordier-info.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cordier-info.github.io/tp_python/",
	"title": "TP Python",
	"tags": [],
	"description": "",
	"content": "TP Python Les exercices couvrent à peu près l\u0026rsquo;ensemble des chapitres.\n"
}]