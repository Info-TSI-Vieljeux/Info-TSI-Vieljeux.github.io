[
{
	"uri": "http://example.org/semestre_2/bonnes_pratiques/",
	"title": "Les bonnes pratiques",
	"tags": [],
	"description": "",
	"content": "Les bonnes pratiques ¬†Prot√©ger ses blocs en commentant son code Un bloc de code utilise g√©n√©ralement un ou plusieurs param√®tres appel√©s param√®tres d\u0026rsquo;entr√©es et construit √† partir d\u0026rsquo;eux un ou plusieurs param√®tres de sortie.\nDans l\u0026rsquo;id√©al, on commente chaque bloc de code (boucles et fonctions) via l\u0026rsquo;utilisation de # en pr√©cisant dans la mesure du possibles les 3 √©l√©ments suivants :\n pr√©conditions postconditions invariant  pr√©conditions Ce sont les conditions que doivent v√©rifier imp√©rativement les param√®tres d\u0026rsquo;entr√©e pour que le code fasse ce qui est attendu.\npostconditions Ce sont les conditions que doivent v√©rifier imp√©rativement les param√®tres de sortie (apr√®s le bloc).\nPar exemple, si le bloc de code calcule une note sur 20, le param\n¬†Utiliser des fonctions ¬†Documenter ses fonctions On indique les types attendus des entr√©es (les param√®tres) et des sorties (les retours) ainsi que les pr√©conditions et les postconditions.\n¬†Contraindre les sp√©cifications avec des assertions ¬†"
},
{
	"uri": "http://example.org/semestre_1/tp1recherche/",
	"title": "TP 1 : recherche simple",
	"tags": [],
	"description": "",
	"content": "TP 1 : Recherche s√©quentielle dans un tableau unidimensionnel. Dictionnaires. Recherche d\u0026rsquo;un √©l√©ment dans une liste  √âcrire une fonction recherche qui prend pour argument un √©l√©ment et une liste et qui retourne True si l\u0026rsquo;√©l√©ment est pr√©sent et False sinon.\nLe corps de la fonction devra comprendre une boucle.\n  Dans le pire des cas (√©l√©ment ne se trouvant pas dans la liste), combien de comparaisons doit-on op√©rer pour savoir si un √©l√©ment est pr√©sent dans une liste de taille 400 ?\n  Construisez une fonction dico qui prend en argument une liste L de $n$ entiers inf√©rieurs √† $n$ et qui retourne un dictionnaire de longueur $n$ dont les cl√©s sont les $n$ premiers entiers (de 0 √† $n$-1) et les valeurs comptent le nombre de fois que la cl√© est pr√©sente dans la liste.\nExemple : s\u0026rsquo;il y a 2 fois l\u0026rsquo;√©l√©ment 18 dans la liste L, alors dico(L)[18]=2, et si l\u0026rsquo;√©l√©ment 97 n\u0026rsquo;est pas pr√©sent dans la liste, alors dico(L)[97]=0.\n D√©finissons une fonction recherche_dico qui v√©rifie si un entier est bien pr√©sent :\ndef recherche_dico(e,dic) : \u0026#39;\u0026#39;\u0026#39; recherche_dico(e:int,dic:dict)-\u0026gt;bool \u0026#39;\u0026#39;\u0026#39; if dic[e] == 1 : return True else : return False # Exemple d\u0026#39;utilisation : L = [5,2,3,1,2,0,2] dic = dico(L) (recherche_dico(3,dic),recherche_dico(4,dic)) (True, False)\nL\u0026rsquo;int√©r√™t de recherche-dico est d\u0026rsquo;aller beaucoup plus vite que recherche comme le montre le graphe suivant (l\u0026rsquo;execution du code peut prendre quelques secondes) :\nfrom time import time from random import randint import matplotlib.pyplot as plt plt.style.use(\u0026#39;ggplot\u0026#39;) I, T_ch, T_dico = [], [], [] try : for i in range(1000,200000,1000) : L = [] L = [randint(0,i-1) for k in range(i)] # randint(i,j) retourne un entier dans {i;...;j} # la liste L contient i √©l√©ments tir√©s au hasard entre 0 et i-1 dic = dico(L) # on cr√©e un dictionnaire √† partir de L gr√¢ce √† la fonction \u0026#39;dico\u0026#39; element = randint(0,i-1) # \u0026#39;element\u0026#39; est un entier tir√© au hasard entre 0 et i-1 start = time() # on note l\u0026#39;heure exacte recherche(element,L) stop1 = time() recherche_dico(element,dic) stop2 = time() T_ch.append(stop1-start) T_dico.append(stop2-stop1) I.append(i) plt.figure(figsize = (15,5)) plt.plot(I,T_dico,label=\u0026#34;recherche_dico\u0026#34;) plt.plot(I,T_ch,label=\u0026#34;votre fonction \u0026#39;recherche\u0026#39;\u0026#34;) plt.xlabel(\u0026#39;taille de la liste\u0026#39;) plt.ylabel(\u0026#34;temps d\u0026#39;ex√©cution (s)\u0026#34;) plt.legend() except : print(\u0026#34;Vous n\u0026#39;avez pas encore impl√©ment√© correctement les fonctions \u0026#39;recherche\u0026#39; et \u0026#39;dico\u0026#39;... (Pensez √† bien ex√©cuter les cellules contenant les fonctions \u0026#39;recherche\u0026#39;, \u0026#39;dico\u0026#39; et \u0026#39;recherche_dico\u0026#39;)\u0026#34;) Recherche d\u0026rsquo;un maximum  √âcrire une fonction maximum qui prend pour argument une liste et qui retourne le plus grand √©l√©ment de la liste.(Interdiciton d\u0026rsquo;utiliser la fonction native max √©videmment)\n Que se passera-t-il si on passe la liste suivante [1,3,'a',-2] en argument √† maximum ?\nmaximum([1,3,\u0026#39;a\u0026#39;,-2])  Pour √©viter cela, vous devrez vous assurez en amont que la liste donn√©e en argument contient bien que des nombres.\nRappel : type(3) renvoie int et type(2.8) renvoie float.\nVous placerez un assert en d√©but de fonction pr√©venant l\u0026rsquo;utilisateur que la liste contient des types farfelus.\n  Construisez maintenant une fonction max_2 qui retourne le deuxi√®me maximum d√©fini comme le plus grand √©l√©ment strictement inf√©rieur au maximum (s\u0026rsquo;il y a plusieurs √©l√©ments ayant la valeur maximale, il ne faut pas retourner un de ceux-l√†).\nVotre fonction max_2 devra utiliser votre ancienne fonction maximum.\n Ci-dessous est repr√©sent√©e l\u0026rsquo;√©volution du temps d\u0026rsquo;ex√©cution de la fonction native max ainsi que de la fonction maximum (si vous avez r√©ussi √† l\u0026rsquo;impl√©menter) en fonction de la taille de la liste en argument.\nOn remarque que cette √©volution est lin√©aire : l\u0026rsquo;augmentation du temps d\u0026rsquo;ex√©cution semble proportionnelle √† l\u0026rsquo;augmentation de la taille de la liste.\nRq : les blocs introduit par try et except ne sont l√† que pour g√©rer l\u0026rsquo;√©ventualit√© que vous n\u0026rsquo;ayez pas une fonction maximum op√©rationnelle.\nfrom time import time from random import randint import matplotlib.pyplot as plt plt.style.use(\u0026#39;ggplot\u0026#39;) I, T_max, T_maximum = [], [], [] for i in range(50000,1000000,50000) : L = [] for k in range(i) : L += [randint(0,k)] # randint(i,j) retourne un entier dans {i;...;j} start = time() max(L) stop1 = time() T_max.append(stop1-start) try : maximum(L) stop2 = time() T_maximum.append(stop2-stop1) except : pass I.append(i) plt.figure(figsize = (15,5)) plt.plot(I,T_max,label=\u0026#34;la fonction Python \u0026#39;max\u0026#39;\u0026#34;) try : plt.plot(I,T_maximum,label=\u0026#34;votre fonction \u0026#39;maximum\u0026#39;\u0026#34;) except : pass plt.xlabel(\u0026#39;taille de la liste\u0026#39;) plt.ylabel(\u0026#34;temps d\u0026#39;ex√©cution (s)\u0026#34;) plt.legend()  Ajoutez la fonction max_2 √† ce graphe et r√©pondre dans la cellule suivante si oui ou non, le temps d\u0026rsquo;ex√©cution de max_2 semble d√©pendre lin√©airement de la taille de la liste.\n ¬†Code myst√®re et dictionnaire L = [randint(0,15) for i in range(30)] stats = {} for i in L: if i in stats: stats[i] += 1 else: stats[i] = 1 cles = stats.keys() valeurs = stats.values() plt.figure(figsize=(15,5)) plt.bar(cles, valeurs)  Que fait le code pr√©c√©dent ? (la question vaut 2 pts et doit √™tre valid√©e pendant le TP)\n "
},
{
	"uri": "http://example.org/semestre_1/tp2imbrication/",
	"title": "TP 2 : boucles imbriqu√©es",
	"tags": [],
	"description": "",
	"content": "Algorithmes op√©rant sur une structure s√©quentielle par boucles imbriqu√©es Chercher un mot dans un texte  √âcrire une fonction cherche_mot qui recherche si un mot est pr√©sent dans un texte.\nVous devrez vous assurez (gr√¢ce √† des assertions) que le mot et le texte sont bien des cha√Ænes de caract√®res et que le mot n\u0026rsquo;est pas plus long que le texte.\n # importation de la classique liste de mots de passe rockyou (cela prend quelques secondes) from urllib.request import urlopen url = \u0026#39;http://cordier-phychi.toile-libre.org/Info/github/rockyou.txt\u0026#39; rockyou = urlopen(url).read().decode(\u0026#39;latin-1\u0026#39;) print(f\u0026#34;Le fichier rockyou contient {len(rockyou.split())} mots de passe !\u0026#34;) `Le fichier rockyou contient 14445388 mots de passe !\n# vous pouvez tester la pr√©sence de votre mot de passe dans la liste mot_de_passe = \u0026#39;...\u0026#39; cherche_mot(mot_de_passe,rockyou)  Sans ce soucier de l\u0026rsquo;impl√©mentation, combien faudra-t-il faire au minimum de comparaisons pour s\u0026rsquo;assurer qu\u0026rsquo;un mot de 3 caract√®res est absent d\u0026rsquo;une cha√Æne de 10 caract√®res ?\n Tra√ßons l\u0026rsquo;√©volution du temps d\u0026rsquo;ex√©cution de cherche_mot en fonction de la taille du texte (cela peut prendre quelques secondes\u0026hellip;).\nfrom time import time from random import randint import matplotlib.pyplot as plt plt.style.use(\u0026#39;ggplot\u0026#39;) I, T_in, T_ch = [], [], [] for i in range(10000,500000,10000) : mot = \u0026#39;\u0026amp;\u0026#39;*(i//2) texte = rockyou[:i] start = time() cherche_mot(mot,texte) stop = time() try : T_ch.append(stop-start) except : pass I.append(i) plt.figure(figsize = (15,5)) try : plt.plot(I,T_ch) except : pass plt.xlabel(\u0026#34;longeur du texte (longueur mot = moiti√© longueur texte)\u0026#34;) plt.ylabel(\u0026#34;temps d\u0026#39;ex√©cution (s)\u0026#34;) plt.title(\u0026#34;Temps d\u0026#39;excution de \u0026#39;cherche_mot\u0026#39; en fonction de la taille du texte\u0026#34;) Chercher un doublon La fonction suivante cherche si un √©l√©ment d\u0026rsquo;une liste se trouve en double et le cas √©ch√©ant, le retourne.\ndef cherche_duplicata(liste) : N = len(liste) for i in range(N) : for j in range(N) : if i != j and liste[i] == liste[j] : print(\u0026#39;Un √©l√©ment en double a √©t√© trouv√© :\u0026#39;) return liste[i] return \u0026#39;Pas de doublons trouv√©s üòû\u0026#39; liste_fruits = [\u0026#34;üçì\u0026#34;, \u0026#34;üçê\u0026#34;, \u0026#34;üçä\u0026#34;, \u0026#34;üçå\u0026#34;, \u0026#34;üçç\u0026#34;, \u0026#34;üçë\u0026#34;, \u0026#34;üçé\u0026#34;, \u0026#34;üçà\u0026#34;, \u0026#34;üçä\u0026#34;, \u0026#34;üçá\u0026#34;] a = cherche_duplicata(liste_fruits) print(a) Un √©l√©ment en double a √©t√© trouv√© :\\ üçä\n Combien de comparaisons sont op√©r√©es au maximum si la liste contient 200 √©l√©ments ?\n On peut ais√©ment am√©liorer la fonction en √©vitant de doubler les comparaisons :\ndef cherche_duplicata_bis(liste) : N = len(liste) for i in range(N-1) : for j in range(i+1,N) : if liste[i] == liste[j] : print(\u0026#39;Un √©l√©ment en double a √©t√© trouv√© :\u0026#39;) return liste[i] return \u0026#39;Pas de doublons trouv√©s üòû\u0026#39; liste_fruits = [\u0026#34;üçì\u0026#34;, \u0026#34;üçê\u0026#34;, \u0026#34;üçä\u0026#34;, \u0026#34;üçå\u0026#34;, \u0026#34;üçç\u0026#34;, \u0026#34;üçë\u0026#34;, \u0026#34;üçé\u0026#34;, \u0026#34;üçà\u0026#34;, \u0026#34;üçä\u0026#34;, \u0026#34;üçá\u0026#34;] a = cherche_duplicata(liste_fruits) print(a) Un √©l√©ment en double a √©t√© trouv√© :\\ üçä\n Combien de comparaisons sont op√©r√©es au maximum avec cette nouvelle fonction si la liste contient 200 √©l√©ments ?\n # Pour vous aider √† raisonner N = 10 for i in range(N-1) : L = [] for j in range(i+1,N) : L.append((i,j)) print(L) [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9)]\n[(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9)]\n[(2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9)]\n[(3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9)]\n[(4, 5), (4, 6), (4, 7), (4, 8), (4, 9)]\n[(5, 6), (5, 7), (5, 8), (5, 9)]\n[(6, 7), (6, 8), (6, 9)]\n[(7, 8), (7, 9)]\n[(8, 9)]\nfrom random import randint I, T_dup, T_dup_bis = [], [], [] for i in range(200,5000,200) : L = [i for i in range(i)] start = time() cherche_duplicata(L) stop1 = time() cherche_duplicata_bis(L) stop2 = time() I.append(i) T_dup.append(stop1-start) T_dup_bis.append(stop2-stop1) fig,axs = plt.subplots(3,figsize = (15,15)) axs[0].plot(I,T_dup) axs[0].set_title(\u0026#34;cherche_duplicata\u0026#34;) axs[1].plot(I,T_dup_bis,c=\u0026#39;#3388BB\u0026#39;,label=\u0026#34;cherche_duplicata_bis\u0026#34;) axs[1].set_title(\u0026#34;cherche_duplicata_bis\u0026#34;) axs[2].plot(I,T_dup,label=\u0026#34;cherche_duplicata\u0026#34;) axs[2].plot(I,T_dup_bis,c=\u0026#39;#3388BB\u0026#39;,label=\u0026#34;cherche_duplicata_bis\u0026#34;) axs[2].set_title(\u0026#34;Comparaison\u0026#34;) axs[2].legend() On constate que m√™me si l\u0026rsquo;am√©lioration est visible entre les deux fonctions, le comportement g√©n√©ral (la classe de complexit√© comme on le verra plus tard) est identique.\n¬†Int√©gration num√©rique def trapeze(f, a, b): return (f(a) + f(b))/2 * (b - a) def rect_gauche(f, a, b): return f(a)*(b-a) def integrale(f, a, b, n, methode): p = (b-a)/n s = 0 for i in range(n) : s += methode(f,a+i*p,a+(i+1)*p) return s def f(x) : return np.cos(x)*x**2 + 5 import numpy as np import matplotlib.patches as patches a = -np.pi b = 3/2*np.pi x = np.linspace(a,b,2000) y = f(x) n_possibles = (6,10,20,50,200) fig,axs = plt.subplots(5,2,figsize=(20,20)) for k in range(5) : n = n_possibles[k] p = (b-a)/n I_rect = integrale(f,a,b,n,rect_gauche) I_trap = integrale(f,a,b,n,trapeze) for i in range(n) : rect = plt.Polygon(((a+i*p,0),(a+i*p,f(a+i*p)),(a+(i+1)*p,f(a+i*p)),(a+(i+1)*p,0),(a+i*p,0)),alpha=0.5,facecolor=\u0026#39;#9988DD\u0026#39;,edgecolor=\u0026#39;#9988DD\u0026#39;) trap = plt.Polygon(((a+i*p,0),(a+i*p,f(a+i*p)),(a+(i+1)*p,f(a+(i+1)*p)),(a+(i+1)*p,0),(a+i*p,0)),alpha=0.5,edgecolor=\u0026#39;#3388BB\u0026#39;) for j in range(2) : axs[k][j].plot(x,y,c=\u0026#39;#EE6666\u0026#39;) axs[k][0].add_patch(rect) axs[k][1].add_patch(trap) axs[k][0].text(0,4,s=f\u0026#39;I = {I_rect:.2f}\u0026#39;,fontsize=18,c=\u0026#39;w\u0026#39;,horizontalalignment=\u0026#39;center\u0026#39;) axs[k][1].text(0,4,s=f\u0026#39;I = {I_trap:.2f}\u0026#39;,fontsize=18,c=\u0026#39;w\u0026#39;,horizontalalignment=\u0026#39;center\u0026#39;) √Ä comparer √† : $$ \\int_{-\\pi}^{3\\pi/2}(x^2\\cos(x)+10)dx = 2+23\\pi-9\\frac{\\pi^2}{4}\\approx 52,05$$\n Pour quelle valeur de $n$, la valeur de $I$ atteint-elle 52,05 avec la m√©thode des rectangles √† gauche ?\nVous appelerez cette valeur n_cible et votre code devra l\u0026rsquo;afficher.\n "
},
{
	"uri": "http://example.org/semestre_1/tp4dicho/",
	"title": "TP 2 : boucles imbriqu√©es",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/semestre_1/tp5recu/",
	"title": "TP 2 : boucles imbriqu√©es",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/semestre_1/tp6tri/",
	"title": "TP 2 : boucles imbriqu√©es",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/semestre_1/tp7image/",
	"title": "TP 2 : boucles imbriqu√©es",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/semestre_1/tp3data/",
	"title": "TP 3 : utilisation de modules/biblioth√®ques",
	"tags": [],
	"description": "",
	"content": "On va se placer dans le champ le plus porteur de la science informatique actuelle, l\u0026rsquo;analyse de donn√©es (data science) pour constater comment l\u0026rsquo;utilisation de modules adapt√©s peut simplifier le travail.\nExploration d\u0026rsquo;un jeu de donn√©es Statistiques simples import pandas as pd # biblioth√®ques d√©di√©e au traitement de jeux de donn√©es import matplotlib.pyplot as plt # biblioth√®que graphique import seaborn as sns # biblioth√®que graphique reposant sur matplotlib et d√©di√©e plus particuli√®rement √† la repr√©sentation de jeux de donn√©es import numpy as np # biblioth√®que puissante permettant de g√©rer des tableaux multidimensionnels import plotly.express as px # libraire permettant des graphes interactifs import plotly.graph_objects as go # compl√©mentaire √† la premi√®re (seulement utile dans les cas complexes) # param√®tres par d√©faut pour les graphes plt.rcParams[\u0026#39;figure.figsize\u0026#39;] = (15, 6) plt.rcParams[\u0026#39;font.family\u0026#39;] = \u0026#34;serif\u0026#34; plt.rcParams[\u0026#39;font.size\u0026#39;] = 13 sns.set_style(\u0026#34;white\u0026#34;) Le jeu de donn√©es est issu du World Happiness report (une publication annuelle de l\u0026rsquo;ONU mesurant le degr√©s de bonheur de la population mondiale par pays √† partir de sondages).\nurl = \u0026#34;https://raw.githubusercontent.com/Info-TSI-Vieljeux/s1-tp3/main/2020.csv\u0026#34; data_monde = pd.read_csv(url,sep=\u0026#34;;\u0026#34;,index_col=0) # data_monde est une dataframe Pandas Une dataframe est une sorte de dictionnaire dont les cl√©s sont les en-t√™tes des colonnes et dont les lignes sont index√©es.\ndata_monde   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur d√©viation standard PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue Score de bonheur en Distopie   Pays               Finland Western Europe 7.8087 0.031156 10.639267 0.954330 71.900825 0.949172 -0.059482 0.195445 1.972317   Denmark Western Europe 7.6456 0.033492 10.774001 0.955991 72.402504 0.951444 0.066202 0.168489 1.972317   Switzerland Western Europe 7.5599 0.035014 10.979933 0.942847 74.102448 0.921337 0.105911 0.303728 1.972317   Iceland Western Europe 7.5045 0.059616 10.772559 0.974670 73.000000 0.948892 0.246944 0.711710 1.972317   Norway Western Europe 7.4880 0.034837 11.087804 0.952487 73.200783 0.955750 0.134533 0.263218 1.972317   ... ... ... ... ... ... ... ... ... ... ...   Central African Republic Sub-Saharan Africa 3.4759 0.115183 6.625160 0.319460 45.200001 0.640881 0.082410 0.891807 1.972317   Rwanda Sub-Saharan Africa 3.3123 0.052425 7.600104 0.540835 61.098846 0.900589 0.055484 0.183541 1.972317   Zimbabwe Sub-Saharan Africa 3.2992 0.058674 7.865712 0.763093 55.617260 0.711458 -0.072064 0.810237 1.972317   South Sudan Sub-Saharan Africa 2.8166 0.107610 7.425360 0.553707 51.000000 0.451314 0.016519 0.763417 1.972317   Afghanistan South Asia 2.5669 0.031311 7.462861 0.470367 52.590000 0.396573 -0.096429 0.933687 1.972317    153 rows √ó 10 columns\n Pr√©cisions sur ces donn√©es :\n le score de bonheur est un score sur 10 correspondant √† la moyenne des r√©ponses des sond√©s (0 correspond √† la pire vie possible et 10 √† la meilleure) ce n\u0026rsquo;est pas le PIB par habitant mais son logarithme qui est utilis√© pour ne pas avoir des valeurs sur des ordres de grandeur trop diff√©rents d\u0026rsquo;une colonne √† l\u0026rsquo;autre entraide sociale : moyenne des r√©ponses √† la question binaire \u0026ldquo;en cas de difficult√©s, pouvez-vous compter sur de la famille ou des amis pour vous aider ?\u0026rdquo; (0 : non, 1 : oui) libert√© des choix de vie : moyenne des r√©ponses √† la question binaire \u0026ldquo;√™tes-vous satisfait ou non de votre libert√© √† choisir ce que vous voulez faire de votre vie ?\u0026rdquo; (0 : non, 1 : oui) g√©n√©rosit√© : moyenne des r√©ponses √† \u0026ldquo;Avez-vous donn√© √† une association caritative le mois dernier ?\u0026rdquo; ajust√©e par rapport au PIB par habitant (valeur r√©siduelle) corruption per√ßue : moyenne des r√©ponses √† la question binaire \u0026ldquo;la corruption est-elle r√©pandue dans le gouvernement ?\u0026rdquo; (0 : non, 1 : oui)  On simplifie un peu le jeu de donn√©es en retirant la colonne \u0026lsquo;D√©viation standard\u0026rsquo; et \u0026lsquo;Score de bonheur en distopie\u0026rsquo; (score minimal obtenu).\ndata_monde.drop(columns=[\u0026#39;d√©viation standard\u0026#39;,\u0026#39;Score de bonheur en Distopie\u0026#39;], inplace=True) data_monde.head(3)   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue   Pays             Finland Western Europe 7.8087 10.639267 0.954330 71.900825 0.949172 -0.059482 0.195445   Denmark Western Europe 7.6456 10.774001 0.955991 72.402504 0.951444 0.066202 0.168489   Switzerland Western Europe 7.5599 10.979933 0.942847 74.102448 0.921337 0.105911 0.303728     data_monde.tail(3)   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue   Pays             Zimbabwe Sub-Saharan Africa 3.2992 7.865712 0.763093 55.61726 0.711458 -0.072064 0.810237   South Sudan Sub-Saharan Africa 2.8166 7.425360 0.553707 51.00000 0.451314 0.016519 0.763417   Afghanistan South Asia 2.5669 7.462861 0.470367 52.59000 0.396573 -0.096429 0.933687     Tra√ßons un histogramme brut du jeu de donn√©es complet pour y voir plus clair (la librairie Seaborn rend cela tr√®s simple).\nsns.histplot(data=data_monde) La m√©thode describe s\u0026rsquo;appliquant √† des dataframe pandas retourne un r√©sum√© statistique tr√®s pratique des donn√©es de chaque colonne :\ndata_monde.describe()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue     count 153.00000 153.000000 153.000000 153.000000 153.000000 153.000000 153.000000   mean 5.47324 9.295706 0.808721 64.445529 0.783360 -0.014568 0.733120   std 1.11227 1.201588 0.121453 7.057848 0.117786 0.151809 0.175172   min 2.56690 6.492642 0.319460 45.200001 0.396573 -0.300907 0.109784   25% 4.72410 8.350645 0.737217 58.961712 0.714839 -0.127015 0.683019   50% 5.51500 9.456313 0.829204 66.305145 0.799805 -0.033665 0.783122   75% 6.22850 10.265124 0.906747 69.289192 0.877709 0.085429 0.849151   max 7.80870 11.450681 0.974670 76.804581 0.974998 0.560664 0.935585      Pour confirmer certaines des valeurs, vous allez construire diff√©rentes fonctions :\n une fonction decompte qui retourne le nombre d\u0026rsquo;√©l√©ments d\u0026rsquo;une liste, une fonction moyenne qui retourne la moyenne des √©l√©ments d\u0026rsquo;une liste, une fonction mediane qui retourne la m√©diane des √©l√©ments d\u0026rsquo;une liste tri√©e en ordre croissant. L\u0026rsquo;utilisation de fonctions statistiques d√©j√† existantes est bien s√ªr prohib√©e.    Calculez , pour les 3 formes d\u0026rsquo;importation du module, la d√©viation standard des √©l√©ments de la liste Liste_scores en utilisant la fonction stdev du module statistics.\nIl s\u0026rsquo;agit d\u0026rsquo;√©valuer directement l\u0026rsquo;expresion (le nombre dois s\u0026rsquo;afficher sous la cellule sans utiliser de print).\n Tracons maintenant un diagramme en batons des scores de bonheur des 60 premiers pays.\nfig,ax = plt.subplots(figsize=(20,4)) sns.barplot(ax = ax,x = data_monde.index[:60], y = data_monde[\u0026#39;Score de bonheur\u0026#39;].head(60)) plt.xticks(rotation=90) ax.set_xlabel(\u0026#39;\u0026#39;) On remarque que les pays sont class√©s par score de bonheur d√©croissant dans le jeu de donn√©es d\u0026rsquo;origine.\nMais on peut √©videmment choisir un autre crit√®re de classement si on le d√©sire :\ndata_monde.sort_values(by=\u0026#34;PIB par habitant (log)\u0026#34;,ascending=True).head(10)   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue   Pays             Burundi Sub-Saharan Africa 3.7753 6.492642 0.490326 53.400002 0.626350 -0.017552 0.606935   Central African Republic Sub-Saharan Africa 3.4759 6.625160 0.319460 45.200001 0.640881 0.082410 0.891807   Congo (Kinshasa) Sub-Saharan Africa 4.3110 6.694256 0.672159 52.900002 0.700794 0.083638 0.809404   Niger Sub-Saharan Africa 4.9096 6.842167 0.617435 53.500095 0.759772 0.013861 0.722530   Liberia Sub-Saharan Africa 4.5579 7.054380 0.709281 56.096313 0.735269 0.042273 0.856376   Malawi Sub-Saharan Africa 3.5380 7.062226 0.544007 57.592888 0.803223 0.021433 0.731701   Mozambique Sub-Saharan Africa 4.6236 7.069346 0.723874 54.205822 0.864452 0.032376 0.683019   Sierra Leone Sub-Saharan Africa 3.9264 7.268803 0.636142 50.865143 0.715315 0.088661 0.861331   Madagascar Sub-Saharan Africa 4.1656 7.281686 0.668196 59.105427 0.557574 -0.011824 0.817486   Gambia Sub-Saharan Africa 4.7506 7.321815 0.693169 55.012016 0.733163 0.343199 0.690718     data_monde.sort_values(by=\u0026#34;Corruption per√ßue\u0026#34;,ascending=False).head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue   Pays             Bulgaria Central and Eastern Europe 5.1015 9.869319 0.937840 66.803978 0.745178 -0.143908 0.935585   Romania Central and Eastern Europe 6.1237 10.107584 0.825162 67.207237 0.842823 -0.197815 0.934300   Bosnia and Herzegovina Central and Eastern Europe 5.6741 9.455817 0.829204 67.808136 0.651353 0.098275 0.933769   Afghanistan South Asia 2.5669 7.462861 0.470367 52.590000 0.396573 -0.096429 0.933687   Kosovo Central and Eastern Europe 6.3252 9.204430 0.820727 63.885555 0.861536 0.190934 0.922328     data_monde.sort_values(by=\u0026#34;G√©n√©rosit√©\u0026#34;,ascending=False).iloc[[45]]   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue   Pays             Denmark Western Europe 7.6456 10.774001 0.955991 72.402504 0.951444 0.066202 0.168489     D\u0026rsquo;apr√®s la cellule pr√©c√©dente, le 46e(le 1erest √† l\u0026rsquo;indice 0) meilleur score de g√©n√©rosit√© appartient au Danemark.\n Quel pays correspond √† la 59eplus courte esp√©rance de vie en bonne sant√© ?\n On peut aussi ais√©ment filtrer le jeu de donn√©es en fonction de n\u0026rsquo;importe quel crit√®re :\ndata_monde[(data_monde[\u0026#34;Esp√©rance de vie en bonne sant√©\u0026#34;]\u0026gt;60) \u0026amp; (data_monde[\u0026#34;Esp√©rance de vie en bonne sant√©\u0026#34;]\u0026lt;61)] # Rq : pandas n√©cessite les op√©rateurs logiques bit √† bit \u0026#39;\u0026amp;\u0026#39; (et) et \u0026#39;|\u0026#39; (ou)  # plut√¥t que les op√©rateurs √©l√©ment par √©l√©ment \u0026#39;and\u0026#39; et \u0026#39;or\u0026#39; qui l√®veraient une erreur.   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue   Pays             Kenya Sub-Saharan Africa 4.5830 8.029776 0.702652 60.096931 0.829748 0.294682 0.831499   India South Asia 3.5733 8.849824 0.592201 60.215187 0.881445 0.057552 0.772043      Quel pays poss√®de un score de bonheur inf√©rieur √† 5 malgr√© une valeur de corruption per√ßue inf√©rieure √† 0.5 ?\n Pour chaque variable mesur√©e (chaque colonne), on peut facilement tracer des histogrammes illustrant la r√©partition des valeurs.\nsns.displot(data_monde, x=\u0026#34;Score de bonheur\u0026#34;, bins=20, kde=True, height=4, aspect=3) # bins contr√¥le le nombre de classes On peut aussi tirer profit de l\u0026rsquo;interactivit√© pour obtenir les informations voulues directement en survolant le graphe.\nOn utilise pour cela la biblioth√®que Plotly express qui sait (comme seaborn) parler √† une dataframe pandas.On peut zoomer sur ces graphiques interactifs et obtenir des informations en survolant avec le curseur.\npx.histogram(data_monde,\u0026#39;Corruption per√ßue\u0026#39;,nbins=40,title=\u0026#34;Corruption per√ßue\u0026#34;) # Cette fois-ci, le nombre de classes est d√©sign√© par nbins.     Plotly.d3.json(\"/corrup.json\", function(err, fig) { Plotly.plot('\\/corrup.json', fig.data, fig.layout, {responsive: true}); }); \n Modifez le graphe pr√©cedent pour r√©pondre √† cette question : combien la classe la plus peupl√©e de l\u0026rsquo;histogramme de l\u0026rsquo;esp√©rence de vie en bonne sant√© compte-elle de valeurs si l\u0026rsquo;histogramme comporte 30 classes ?\n On peut aussi r√©cup√©rer les donn√©es d\u0026rsquo;un pays en particulier :\ndata_monde.loc[\u0026#39;France\u0026#39;] R√©gion du monde Western Europ\nScore de bonheur 6.663\nPIB par habitant (log) 10.58422\nEntraide sociale 0.93710\nEsp√©rance de vie en bonne sant√© 73.80193\nLibert√© des choix de vie 0.82546\nG√©n√©rosit√© -0.13064\nCorruption per√ßue 0.58352\nName: France, dtype: objec\n¬†Regroupement des donn√©es On remarque que le jeu de donn√©es contient une colonne cat√©gorielle : \u0026ldquo;R√©gion du monde\u0026rdquo;.\\ Cela va nous permettre d\u0026rsquo;explorer de possibles dynamiques r√©gionales : est-ce que les pays d\u0026rsquo;une m√™me zone ont des indicateurs semblables ?\npd.unique(data_monde[\u0026#34;R√©gion du monde\u0026#34;]) # permet d\u0026#39;afficher une seule fois chacune des valeurs diff√©rentes de la colonne array(['Western Europe', 'North America and ANZ','Middle East and North Africa', 'Latin America and Caribbean','Central and Eastern Europe', 'East Asia', 'Southeast Asia','Commonwealth of Independent States', 'Sub-Saharan Africa','South Asia'], dtype=object)\nTra√ßons des diagrammes en bo√Æte √† moustaches repr√©sentant les scores de bonheur pour chacune des r√©gions.\n√Ä nouveau Seaborn rend cela tr√®s simple\u0026hellip;\nsns.set_style(\u0026#34;white\u0026#34;) fig, ax = plt.subplots(figsize=(12,8)) sns.boxplot(ax = ax, x=\u0026#34;Score de bonheur\u0026#34;, y=\u0026#34;R√©gion du monde\u0026#34;, palette=\u0026#34;husl\u0026#34;, data=data_monde) sns.despine(offset=10, trim=True) ax.set_ylabel(\u0026#39;\u0026#39;) Tra√ßons maintenant un graphe plus g√©n√©ral repr√©sentant toutes les relations possibles entre deux axes du jeu de donn√©es pour voir si certaines combinaisons discriminent plus nettement les diff√©rentes r√©gions.\n# Un peu long √† s\u0026#39;ex√©cuter (environ 30 s) g = sns.pairplot(data_monde, hue=\u0026#34;R√©gion du monde\u0026#34;, corner=True) g._legend.set_bbox_to_anchor((0.6, 0.8)) On constate que les groupes r√©gionaux sont relativement homog√®nes pour la plupart des crit√®res.\nZoomons sur un de ces graphes :\nsns.set_style(\u0026#34;whitegrid\u0026#34;) sns.jointplot(data=data_monde,x=\u0026#34;PIB par habitant (log)\u0026#34;, y=\u0026#34;Score de bonheur\u0026#34;, hue=\u0026#34;R√©gion du monde\u0026#34;, kind=\u0026#39;scatter\u0026#39;, height=8, legend=False) Une version interactive du m√™me graphique permet de consulter les informations pour chaque point :\npx.scatter(data_monde,x=\u0026#39;PIB par habitant (log)\u0026#39;, y=\u0026#39;Score de bonheur\u0026#39;, hover_name=data_monde.index, color=\u0026#39;R√©gion du monde\u0026#39;)    Plotly.d3.json(\"/zoompairplot.json\", function(err, fig) { Plotly.plot('\\/zoompairplot.json', fig.data, fig.layout, {responsive: true}); });   Trouver la r√©gion du monde repr√©sent√©e sur le graphe suivant.  Allons maintenant au-del√† de la proximit√© g√©ographique pour regrouper les pays en 3 grands blocs socio√©conomiques : \u0026ldquo;Nord\u0026rdquo;, \u0026ldquo;Sud\u0026rdquo;, \u0026ldquo;Interm√©diaire\u0026rdquo;.\nconditions = [(data_monde[\u0026#39;R√©gion du monde\u0026#39;] == \u0026#39;Western Europe\u0026#39;) | (data_monde[\u0026#39;R√©gion du monde\u0026#39;] == \u0026#39;North America and ANZ\u0026#39;),(data_monde[\u0026#39;R√©gion du monde\u0026#39;] == \u0026#39;South Asia\u0026#39;) | (data_monde[\u0026#39;R√©gion du monde\u0026#39;] == \u0026#39;Sub-Saharan Africa\u0026#39;)] choix = [\u0026#39;\u0026#34;Nord\u0026#34;\u0026#39;, \u0026#39;\u0026#34;Sud\u0026#34;\u0026#39;] data_monde[\u0026#39;Groupe\u0026#39;] = np.select(conditions, choix, default=\u0026#39;Autres\u0026#39;) deux_gpes = data_monde[data_monde[\u0026#34;Groupe\u0026#34;].isin([\u0026#39;\u0026#34;Nord\u0026#34;\u0026#39;,\u0026#39;\u0026#34;Sud\u0026#34;\u0026#39;])] # Un peu long √† s\u0026#39;ex√©cuter (environ 30 s) sns.set_style(\u0026#34;white\u0026#34;) g = sns.PairGrid(data_monde, diag_sharey=False, hue=\u0026#34;Groupe\u0026#34;) g.map_upper(sns.scatterplot) g.map_lower(sns.kdeplot,common_norm=False) g.map_diag(sns.histplot,bins=20,kde=True) g.add_legend(title=\u0026#34;Grands groupes\u0026#34;,adjust_subtitles=True) √Ä nouveau, l\u0026rsquo;homog√©n√©it√© de ces 3 groupes saute aux yeux.\n¬†Corr√©lations Les graphiques pr√©c√©dents mettent en √©vidence des corr√©lations assez fortes entre certaines grandeurs.Creusons un peu.\ng = sns.PairGrid(data_monde, y_vars=[\u0026#34;Score de bonheur\u0026#34;], x_vars=[\u0026#34;PIB par habitant (log)\u0026#34;, \u0026#34;Corruption per√ßue\u0026#34;], height=7, aspect=1.5) g.map(sns.regplot) On constate sur cet exemple que le score de bonheur est corr√©l√© positivement avec le PIB par habitant et n√©gativement avec le degr√© de corruption per√ßue.\nPour avoir un panorama complet, tra√ßons la matrice de corr√©lation donnant, pour chaque couple de variable, la valeur du coefficient de corr√©lation $r$ (valeur entre -1 et 1 traduisant le degr√© de d√©pendance lin√©aire entre deux variables) :\nfig, ax = plt.subplots(figsize=(12,10)) cmap = sns.diverging_palette(0, 230, 90, 60, as_cmap=True).reversed() # choix de la palette de couleurs sns.heatmap(data_monde.iloc[:,1:].corr(), cmap=cmap, center=0, annot=True, fmt=\u0026#34;.2f\u0026#34;, linewidth = 0.5, ax=ax)  Citer les deux variables les moins corr√©l√©es entre elles (donner les noms exacts tels qu\u0026rsquo;ils apparaissent dans les donn√©s, attention √† la casse). L\u0026rsquo;ordre des variables n\u0026rsquo;est pas important.\n ¬†Un chou√Øa d\u0026rsquo;apprentissage automatique (machine learning) On a vu qu\u0026rsquo;un regroupement des donn√©es en 3 grands groupes \u0026ldquo;Nord\u0026rdquo;, \u0026ldquo;Sud\u0026rdquo; et \u0026ldquo;Interm√©diaire\u0026rdquo; semble plut√¥t coh√©rent.Mais pourquoi pas laisser un algorithme d√©cider lui-m√™me de qui va le mieux ensemble ? Ensuite nous pourrons v√©rifier si cela recoupe notre d√©coupage fait √† la main.On appelle cela un apprentissage non supervis√©.\nNous allons utiliser l\u0026rsquo;algorithme des k-moyennes pour partitionner automatiquement nos donn√©es.Il consiste √† placer chaque point de donn√©es dans un espace √† $n$ dimensions o√π $n$ est le nombre de variables (les descripteurs) et chercher √† les regrouper en clusters en fonction de leurs distances.Chaque variable correspondant √† un axe du rep√®re.\nPour aider l\u0026rsquo;algorithme, on peut tenter de r√©duire la dimension de l\u0026rsquo;espace dans lequel chaque point de donn√©es est plong√© en utilisant une analyse en composantes principales.L\u0026rsquo;id√©e est de d√©terminer les combinaisons des diff√©rentes variables expliquant le mieux la variance des donn√©es. Chaque nouvel axe ainsi form√© (les composantes principales) explique une part d√©croissante mais compl√©mentaire de la variance (sur la deuxi√®me composante, les donn√©es sont moins √©tal√©es que sur la premi√®re, mais elles s\u0026rsquo;√©talent dans une direction orthogonale, et ainsi de suite).Projeter les donn√©es sur les premi√®res composantes permet d\u0026rsquo;√©clater le plus possible les donn√©es. On peut ainsi r√©duire l\u0026rsquo;espace √† n dimensions du d√©part √† un espace de seulement 2 ou 3 dimensions expliquant la majorit√© de la variance des donn√©es.\nL\u0026rsquo;animation suivante montre comment serait s√©lectionn√© l\u0026rsquo;axe de la composante principale dans un espace √† deux dimensions : il correspond √† la droite par rapport √† laquelle la distance cumul√©e de tous les points est la plus grande.\nLa biblioth√®que Scikit-learn, destin√©e √† l\u0026rsquo;apprentissage automatique, contient tout ce qu\u0026rsquo;il nous faut :\nfrom sklearn.decomposition import PCA # l\u0026#39;algorithme d\u0026#39;analyse en composantes principales (PCA en anglais) from sklearn.preprocessing import StandardScaler # pour centrer-r√©duire les donn√©es from sklearn.cluster import KMeans # l\u0026#39;algorithme des k-moyennes variables = data_monde.columns.values[1:-1] scaler = StandardScaler() X = scaler.fit_transform(data_monde[variables]) # chaque vecteur correspondant √† chacune des variables est maintenant centr√©-r√©duit pca = PCA() components = pca.fit_transform(X) Quelle combinaison des variables de d√©part utilise la premi√®re composante ?\ndata = data_monde.copy() # pour pouvoir revenir sur le graphe suivant m√™me apr√®s ajout de colonnes √† data_monde n_c = 1 # num√©ro de la composante principale √† d√©crire px.bar(components.T, x=data.columns.values[1:-1], y=n_c-1, labels={f\u0026#34;{n_c-1}\u0026#34;: f\u0026#34;Composante Principale (CP) {n_c}\u0026#34;})    Plotly.d3.json(\"/compppale.json\", function(err, fig) { Plotly.plot('\\/compppale.json', fig.data, fig.layout, {responsive: true}); });   Quelle est le nom de la variable participant le plus √† la composante principale n¬∞34 ?\n Repr√©sentons le pourcentage de variance expliqu√© par chacune des composantes :\nexp_var_cumul = np.cumsum(pca.explained_variance_ratio_) fig = px.bar(x=range(1, exp_var_cumul.shape[0] + 1),y=pca.explained_variance_ratio_,labels={\u0026#34;x\u0026#34;: \u0026#34;composante\u0026#34;, \u0026#34;y\u0026#34;: \u0026#34;% variance expliqu√©e\u0026#34;}) fig.add_scatter(x=list(range(1, exp_var_cumul.shape[0] + 1)), y=exp_var_cumul, name=\u0026#34;\u0026#34;, showlegend=False)    Plotly.d3.json(\"/explvariance.json\", function(err, fig) { Plotly.plot('\\/explvariance.json', fig.data, fig.layout, {responsive: true}); }); \nLes trois premi√®res composantes expliquent presque 90% de la variance !\nPla√ßons les donn√©es dans un espace r√©duit √† ces 3 dimensions :\npx.scatter_3d(components, x=0, y=1, z=2, color=data_monde[\u0026#39;Groupe\u0026#39;], labels={\u0026#39;0\u0026#39;: \u0026#39;CP 1\u0026#39;, \u0026#39;1\u0026#39;: \u0026#39;CP 2\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;CP 3\u0026#39;}, hover_name=data_monde.index)    Plotly.d3.json(\"/scat3Dgpe.json\", function(err, fig) { Plotly.plot('\\/scat3Dgpe.json', fig.data, fig.layout, {responsive: true}); });  On constate √† nouveau que nos 3 groupes discriminent plut√¥t tr√®s bien nos donn√©es m√™me si quelques chevauchements existent.\nC\u0026rsquo;est le moment d\u0026rsquo;utiliser l\u0026rsquo;algorithme des k-moyennes pour essayer de former 3 groupes homog√®nes :\n# on ne garde que les 3 premi√®res composantes principales pca = PCA(n_components = 3) pca.fit(X) score_pca = pca.transform(X) kmeans_pca = KMeans(n_clusters=3,init=\u0026#39;k-means++\u0026#39;,random_state=42) kmeans_pca.fit(score_pca) data_monde[\u0026#34;Cluster\u0026#34;]=kmeans_pca.labels_.astype(str) data_monde.head(3)   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue Groupe Cluster   Pays               Finland Western Europe 7.8087 10.639267 0.954330 71.900825 0.949172 -0.059482 0.195445 \"Nord\" 2   Denmark Western Europe 7.6456 10.774001 0.955991 72.402504 0.951444 0.066202 0.168489 \"Nord\" 2   Switzerland Western Europe 7.5599 10.979933 0.942847 74.102448 0.921337 0.105911 0.303728 \"Nord\" 2     fig = px.scatter_3d(components, x=0, y=1, z=2, color=data_monde[\u0026#39;Cluster\u0026#39;], labels={\u0026#39;0\u0026#39;: \u0026#39;CP 1\u0026#39;, \u0026#39;1\u0026#39;: \u0026#39;CP 2\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;CP 3\u0026#39;}, color_discrete_sequence=px.colors.qualitative.Bold, hover_name=data_monde.index) fig.update_layout(legend_title = \u0026#34;Cluster\u0026#34;)    Plotly.d3.json(\"/scat3Dclust.json\", function(err, fig) { Plotly.plot('\\/scat3Dclust.json', fig.data, fig.layout, {responsive: true}); });  Les 3 clusters cr√©√©s reproduisent √† peu de chose pr√®s les 3 groupes \u0026ldquo;Nord\u0026rdquo;, \u0026ldquo;Sud\u0026rdquo;, \u0026ldquo;Interm√©diaire\u0026rdquo; construits √† la main.\n √Ä quel cluster correspondent approximativement les pays du groupe \u0026ldquo;Nord\u0026rdquo; ?\n Mais l\u0026rsquo;accord n\u0026rsquo;est pas parfait !\n Citer un pays qui appartient au groupe \u0026ldquo;Nord\u0026rdquo; mais qui n\u0026rsquo;appartient pas au cluster lui correspondant.\n Nous allons voir dans la prochaine partie du TP comment repr√©senter ces donn√©es sur une carte pour y voir plus clair.\n¬†Un peu de g√©ographie Le module suivant va permettre d\u0026rsquo;ajouter √† nos donn√©es le code √† 3 lettres (SO 3166-1 alpha-3) de chaque pays.\nMais pourquoi donc ? plotly express permet de tracer la carte d\u0026rsquo;un pays directement √† partir de ce petit code de 3 lettres !\nimport country_converter as coco iso3 = coco.convert(names=data_monde.index, to=\u0026#39;ISO3\u0026#39;, not_found=None) data_monde[\u0026#34;code\u0026#34;] = iso3 data_monde.head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue Groupe Cluster code   Pays                Finland Western Europe 7.8087 10.639267 0.954330 71.900825 0.949172 -0.059482 0.195445 \"Nord\" 2 FIN   Denmark Western Europe 7.6456 10.774001 0.955991 72.402504 0.951444 0.066202 0.168489 \"Nord\" 2 DNK   Switzerland Western Europe 7.5599 10.979933 0.942847 74.102448 0.921337 0.105911 0.303728 \"Nord\" 2 CHE   Iceland Western Europe 7.5045 10.772559 0.974670 73.000000 0.948892 0.246944 0.711710 \"Nord\" 2 ISL   Norway Western Europe 7.4880 11.087804 0.952487 73.200783 0.955750 0.134533 0.263218 \"Nord\" 2 NOR     fig = px.choropleth(data_monde, locations=\u0026#34;code\u0026#34;, color=\u0026#34;Score de bonheur\u0026#34;, projection=\u0026#34;orthographic\u0026#34;, color_continuous_scale=\u0026#34;Spectral_r\u0026#34;, hover_name = data_monde.index, hover_data ={\u0026#34;code\u0026#34; : False}) fig.update_geos( showland=True, landcolor=\u0026#34;LightGrey\u0026#34;, showocean=True, oceancolor=\u0026#34;LightBlue\u0026#34;, showlakes=True, lakecolor=\u0026#34;LightBlue\u0026#34;, showframe = False) fig.update_layout(margin={\u0026#34;r\u0026#34;:0,\u0026#34;t\u0026#34;:0,\u0026#34;l\u0026#34;:0,\u0026#34;b\u0026#34;:0}) fig.show()    Plotly.d3.json(\"/cartechoro1.json\", function(err, fig) { Plotly.plot('\\/cartechoro1.json', fig.data, fig.layout, {responsive: true}); });  On est maintenant par√© pour repr√©senter les 3 clusters obtenus par l\u0026rsquo;algo des k-moyennes du tp3b.\ndata_monde[\u0026#34;Cluster\u0026#34;] = [f\u0026#39;n¬∞{cluster}\u0026#39; for cluster in data_monde[\u0026#34;Cluster\u0026#34;].astype(\u0026#39;int64\u0026#39;) if cluster != \u0026#39;nan\u0026#39;] data_monde.head(1)   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue Groupe Cluster code   Pays                Finland Western Europe 7.8087 10.639267 0.95433 71.900825 0.949172 -0.059482 0.195445 \"Nord\" n¬∞2 FIN     fig = px.choropleth(data_monde, locations=\u0026#34;code\u0026#34;, color=\u0026#34;Cluster\u0026#34;, projection=\u0026#34;natural earth\u0026#34;, color_discrete_sequence = px.colors.qualitative.Set2, hover_name = data_monde.index, hover_data ={\u0026#34;code\u0026#34; : False} ) #fig.update_geos(fitbounds=\u0026#34;locations\u0026#34;, visible=True) fig.update_layout(margin={\u0026#34;r\u0026#34;:0,\u0026#34;t\u0026#34;:0,\u0026#34;l\u0026#34;:0,\u0026#34;b\u0026#34;:0}) fig.update_geos(showframe = False) fig.show()    Plotly.d3.json(\"/cartechoro2.json\", function(err, fig) { Plotly.plot('\\/cartechoro2.json', fig.data, fig.layout, {responsive: true}); });  Terminons en fabriquant une carte r√©gionale.\npd.unique(data_monde[\u0026#34;R√©gion du monde\u0026#34;]) array(['Western Europe', 'North America and ANZ','Middle East and North Africa', 'Latin America and Caribbean','Central and Eastern Europe', 'East Asia', 'Southeast Asia','Commonwealth of Independent States', 'Sub-Saharan Africa','South Asia'], dtype=object)\nregion = data_monde[data_monde[\u0026#34;R√©gion du monde\u0026#34;] == \u0026#34;Middle East and North Africa\u0026#34;] fig = px.choropleth(region, locations=\u0026#34;code\u0026#34;, color=\u0026#34;Score de bonheur\u0026#34;, projection=\u0026#34;natural earth\u0026#34;, color_continuous_scale=\u0026#34;Temps\u0026#34;, hover_name = region.index, hover_data ={\u0026#34;code\u0026#34; : False} ) fig.update_geos(fitbounds=\u0026#34;locations\u0026#34;, visible=True) fig.update_layout(margin={\u0026#34;r\u0026#34;:0,\u0026#34;t\u0026#34;:0,\u0026#34;l\u0026#34;:0,\u0026#34;b\u0026#34;:0}) fig.update_geos(showframe = False, resolution=50) fig.show()    Plotly.d3.json(\"/cartechoro3.json\", function(err, fig) { Plotly.plot('\\/cartechoro3.json', fig.data, fig.layout, {responsive: true}); });   Modifier les cellules qui pr√©c√®dent pour que le graphique ci-dessus affiche la carte du score de g√©n√©rosit√© des pays d\u0026rsquo;Asie du sud-est.\n  De quelle couleur est le Vietnam sur cette carte ?\n ¬†S√©rie temporelle Utilisons un nouveau jeu de donn√©es comprenant des relv√©s de conommation √©lectrique allemands entre 2006 et 2018 :\nurl = \u0026#34;http://cordier-phychi.toile-libre.org/Info/github/elec_allemagne.csv\u0026#34; serie_temp = pd.read_csv(url,sep=\u0026#34;,\u0026#34;) serie_temp.drop(columns=\u0026#34;Wind+Solar\u0026#34;,inplace=True) serie_temp   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    Date Consumption Wind Solar     0 2006-01-01 1069.18400 NaN NaN   1 2006-01-02 1380.52100 NaN NaN   2 2006-01-03 1442.53300 NaN NaN   3 2006-01-04 1457.21700 NaN NaN   4 2006-01-05 1477.13100 NaN NaN   ... ... ... ... ...   4378 2017-12-27 1263.94091 394.507 16.530   4379 2017-12-28 1299.86398 506.424 14.162   4380 2017-12-29 1295.08753 584.277 29.854   4381 2017-12-30 1215.44897 721.247 7.467   4382 2017-12-31 1107.11488 721.176 19.980    4383 rows √ó 4 columns\n Petit toilettage des donn√©es : on transforme les valeurs de la colonne des dates en un type date reconnu par pandas et on les utilise comme index.\nserie_temp[\u0026#39;Date\u0026#39;] = pd.to_datetime(serie_temp[\u0026#39;Date\u0026#39;]) serie_temp = serie_temp.set_index(\u0026#39;Date\u0026#39;) serie_temp.head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    Consumption Wind Solar   Date        2006-01-01 1069.184 NaN NaN   2006-01-02 1380.521 NaN NaN   2006-01-03 1442.533 NaN NaN   2006-01-04 1457.217 NaN NaN   2006-01-05 1477.131 NaN NaN     On francise ensuite les noms de colonne\u0026hellip;\nserie_temp.columns = [\u0026#34;Consommation\u0026#34;,\u0026#34;Vent\u0026#34;,\u0026#34;Solaire\u0026#34;] serie_temp.head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    Consommation Vent Solaire   Date        2006-01-01 1069.184 NaN NaN   2006-01-02 1380.521 NaN NaN   2006-01-03 1442.533 NaN NaN   2006-01-04 1457.217 NaN NaN   2006-01-05 1477.131 NaN NaN     Et enfin, on ajoute des colonnes \u0026ldquo;jour\u0026rdquo;, \u0026ldquo;mois\u0026rdquo; et \u0026ldquo;ann√©e\u0026rdquo;.\nserie_temp[\u0026#39;jour\u0026#39;] = serie_temp.index.day_name() serie_temp[\u0026#39;mois\u0026#39;] = serie_temp.index.month serie_temp[\u0026#39;ann√©e\u0026#39;] = serie_temp.index.year serie_temp[\u0026#34;date\u0026#34;] = serie_temp.index serie_temp[\u0026#34;date\u0026#34;]=serie_temp[\u0026#34;date\u0026#34;].dt.date # pour aider Colab qui a des soucis avec les dates serie_temp.head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    Consommation Vent Solaire jour mois ann√©e date   Date            2006-01-01 1069.184 NaN NaN Sunday 1 2006 2006-01-01   2006-01-02 1380.521 NaN NaN Monday 1 2006 2006-01-02   2006-01-03 1442.533 NaN NaN Tuesday 1 2006 2006-01-03   2006-01-04 1457.217 NaN NaN Wednesday 1 2006 2006-01-04   2006-01-05 1477.131 NaN NaN Thursday 1 2006 2006-01-05     px.line(serie_temp[[\u0026#34;Consommation\u0026#34;,\u0026#34;Vent\u0026#34;,\u0026#34;Solaire\u0026#34;]])    Plotly.d3.json(\"/linecomplet.json\", function(err, fig) { Plotly.plot('\\/linecomplet.json', fig.data, fig.layout, {responsive: true}); });  On constate d\u0026rsquo;importantes variations saisonni√®res.\nzoom = serie_temp[serie_temp[\u0026#39;ann√©e\u0026#39;]==2016] fig1 = px.line(zoom,\u0026#39;date\u0026#39;,\u0026#39;Consommation\u0026#39;) fig2 = px.scatter(zoom,\u0026#39;date\u0026#39;,\u0026#39;Consommation\u0026#39;,color=\u0026#39;jour\u0026#39;) fig = go.Figure() fig.add_traces([fig1.data[0],*[fig2.data[i] for i in range(7)]])    Plotly.d3.json(\"/zoom2016.json\", function(err, fig) { Plotly.plot('\\/zoom2016.json', fig.data, fig.layout, {responsive: true}); });  Gr√¢ce √† la m√©thode des dataframe pandas groupby, on peut facilement grouper les donner de mani√®re √† obtenir les statistiques qui nous int√©ressent.Exemple : trouvons combien d\u0026rsquo;√©lectricit√© d\u0026rsquo;origine √©olienne a √©t√© produite chaque mois en 2016.\nserie_temp[serie_temp[\u0026#39;ann√©e\u0026#39;]==2016].groupby(\u0026#34;mois\u0026#34;)[\u0026#34;Vent\u0026#34;].sum() mois\n1 9264.588\n2 9814.294\n3 6030.177\n4 5910.504\n5 6089.484\n6 3369.069\n7 4651.582\n8 4742.343\n9 4222.315\n10 5585.248\n11 8076.232\n12 9252.290\nName: Vent, dtype: float64\n Sur le mod√®le pr√©c√©dent, d√©terminer le jour de la semaine o√π l\u0026rsquo;Allemagne a consomm√© le plus d\u0026rsquo;√©lectricit√© en moyenne en 2016 (vous pourrez utilisez la m√©thode mean √† la place de sum.\n Une variabilit√© hebdomadaire se superpose √† la tendance saisonni√®re.\nTra√ßons une bo√Æte √† moustaches de la r√©partition des 3 variables mois par mois :\nfig, axes = plt.subplots(3, 1, figsize=(15, 10), sharex=True) for var, ax in zip([\u0026#39;Consommation\u0026#39;, \u0026#39;Solaire\u0026#39;, \u0026#39;Vent\u0026#39;], axes): sns.boxplot(data=serie_temp, x=\u0026#39;mois\u0026#39;, y=var, ax=ax) ax.set_ylabel(\u0026#39;GWh\u0026#39;) ax.set_title(var) if ax != axes[-1]: ax.set_xlabel(\u0026#39;\u0026#39;) On observe que :\n les trois graphes pr√©sentent bien une variabilit√© saisonni√®re ; la consommation √©lectrique est plus forte en hiver ainsi que la production √©olienne (m√™me si l\u0026rsquo;√©cart est moins marqu√©) et la production solaire est beaucoup plus importante en √©t√©. beaucoup de valeurs se retrouvent √† l\u0026rsquo;ext√©rieur des moustaches sup√©rieures pour la production √©olienne, ce qui est probablement d√ª √† des p√©riodes de fort vent.  Regardons maintenant jour par jour :\nserie_temp[\u0026#34;date\u0026#34;]=(serie_temp.index.strftime(\u0026#39;%d%B\u0026#39;)) px.box(serie_temp,x=\u0026#39;jour\u0026#39;, y=\u0026#39;Consommation\u0026#39;,hover_data={\u0026#34;date\u0026#34;})    Plotly.d3.json(\"/jourparjour.json\", function(err, fig) { Plotly.plot('\\/jourparjour.json', fig.data, fig.layout, {responsive: true}); });   Pourquoi y a-t-il autant de points au-del√† des moustaches les jours de semaine ?\n "
},
{
	"uri": "http://example.org/python/traitsgaux/",
	"title": "Traits g√©n√©raux",
	"tags": [],
	"description": "",
	"content": "Traits g√©n√©raux Introduction Shell et IDE Python est un langage de programmation interpr√©t√© d√©velopp√© par Guido van Rossum en 1989. Langage imp√©ratif de haut-niveau dot√© d\u0026rsquo;une syntaxe simple, Python s\u0026rsquo;adapte √† de nombreux contextes gr√¢ce √† sa modularit√© ; une importante librairie de modules et packages permet en effet d\u0026rsquo;√©tendre ses capacit√©s.\nPython poss√®de son propre shell (interface en ligne de commande) : l\u0026rsquo;utilisateur entre une commande Python qui est interpr√©t√©e imm√©diatement lorsque Entr√©e est tap√©e.\nAu lancement, le shell Python, poli, se pr√©sente :\nLes 3 chevrons sont l\u0026rsquo;invite (ou prompt) o√π les commandes seront √©crites.\nIPython, un shell plus √©volu√©, utilise [1] comme invite (o√π le chiffre dans les crochets s\u0026rsquo;incr√©mente √† chaque commande).\nPour sortir du shell classique, il faut taper exit(), et exit ou quit pour sortie du shell IPython.\nOn peut tout √† fait ex√©cuter des commandes Python une √† une dans le shell.\nUne commande qui renvoie un r√©sultat est appel√©e expression, alors qu\u0026rsquo;une commande qui ne renvoie rien est une instruction.\nToute fonction est une expression, mais certaines ont en plus un effet sur l\u0026rsquo;environnement comme print() qui permet d\u0026rsquo;afficher une cha√Æne de caract√®res dans le shell ou dans un fichier (elle retourne aussi la valeur None qui est omise dans ce cas par le shell). Par une mauvaise traduction de l\u0026rsquo;anglais side effect, les fonctions qui modifient un √©tat en dehors de leur environnement local comme une modification de la m√©moire (√©criture d\u0026rsquo;un fichier) ou une modification d\u0026rsquo;un p√©riph√©rique (affichage sur l\u0026rsquo;√©cran par exemple) sont dites √† effet de bord.\n Pour les projets plus complexes n√©cessitant d\u0026rsquo;encha√Æner les instructions, on √©crit l\u0026rsquo;ensemble de ces commandes (le programme) dans un √©diteur de texte et on enregistre le fichier avec une extension .py.\nOn demande alors √† l\u0026rsquo;interpr√®te Python d\u0026rsquo;ex√©cuter l\u0026rsquo;ensemble du script en utilisant la commande python nom_du_fichier.py dans le shell de l\u0026rsquo;OS. Les diff√©rents retours dans le shell ne sont alors plus affich√©s, seuls les effets ont un\u0026hellip; effet.\nLe plus simple pour coder est d\u0026rsquo;utiliser un environnement de travail (IDE pour \u0026ldquo;integrated development environment\u0026rdquo;) qui combine un √©diteur de code et un shell Python permettant d\u0026rsquo;ex√©cuter le script entier ou une partie directement via l\u0026rsquo;interface.Installation L\u0026rsquo;installation d'Anaconda rend disponible les principales biblioth√®ques scientifiques Python ainsi que le preformant IDE Spyder ou encore Jupyterlab (tr√®s int√©ressant pour les pr√©sentations de projets car associant dans une m√™me interface texte et code pour former un notebook). ¬†Passons maintenant en revue quelques caract√©ristiques du langage Python.Typage dynamique Contrairement √† des langages √† typage statique comme le C, le type de la variable n\u0026rsquo;a pas besoin d\u0026rsquo;√™tre d√©clar√©e en Python. On parle alors de typage dynamique.\nL\u0026rsquo;interpr√®te Python d√©termine par lui-m√™me le type en fonction de l\u0026rsquo;objet affect√© √† la variable.\n¬†Principe d\u0026rsquo;indentation Beaucoup de langage de programmation (C++, Java par exemple) utilisent des accolades {} pour d√©finir un bloc de code (boucles,fonctions, instructions conditionnelles). Python utilise l'indentation (d√©calage d\u0026rsquo;un nombre constant d\u0026rsquo;espaces blancs, g√©n√©ralement 4, ou une tabulation).\nfor i in range(3) : i += 1 mot = \u0026#39;\u0026#39; for lettre in (\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;) : mot += lettre*i print(mot)  Qu\u0026rsquo;est-ce qui s\u0026rsquo;affiche ?\n ¬†Port√©e lexicale Les variables d√©finies √† l\u0026rsquo;int√©rieur d\u0026rsquo;une fonction ont une port√©e locale. Elles ne sont pas reconnues dans le code principal (en dehors du bloc de la fonction).\n√Ä l\u0026rsquo;inverse, les variables affect√©es dans le programme principal peuvent √™tre utilis√©es partout (y compris dans la fonction) et sont dites globales.\nExemple :\ndef foo() : a = \u0026#39;locale\u0026#39; print(a) print(b) b = \u0026#39;globale\u0026#39; foo() locale\nglobale\nComme b n\u0026rsquo;est pas d√©finie dans la bloc de la fonction, Python va la chercher dans le champ global. Mais il faut que b soit affect√©e avant l\u0026rsquo;appel de la fonction.\nQue se passe-t-il si une fonction d√©finit une variable locale avec le m√™me nom qu\u0026rsquo;une variable globale ?\nLe champ local est scrut√© en premier.\nExemple :\ndef foo() : a = \u0026#39;locale\u0026#39; print(a) a = \u0026#39;globale\u0026#39; foo() print(a) locale\nglobale\nNotons bien que la variable locale a n\u0026rsquo;existe que dans le bloc de d√©finition, qu\u0026rsquo;elle ait ou non le m√™me nom qu\u0026rsquo;une variable globale ne change rien. Elle disparait quand l\u0026rsquo;interpr√®te sort de la fonction et n\u0026rsquo;√©crase donc pas la variable globale a.\nDans l\u0026rsquo;ordre, Python regarde d\u0026rsquo;abord le champ local, puis non local (le champ englobant la fonction int√©rieure dans le cas de fonctions imbriqu√©es), puis global, puis built-in (les fonctions natives qu\u0026rsquo;il convient donc de ne pas red√©finir).\n Une fonction ne peut pas modifier une variable globale sans pr√©ciser qu\u0026rsquo;elle le souhaite.\nExemple :\nx = 2 def fct1() : print(x) def fct2() : x += 1 print(x)  Que se passe-t-il lorsqu\u0026rsquo;on appelle fct1() ? Et fct2() ?\n Pour r√©gler le probl√®me, il faut utiliser le mot cl√© global qui permet de r√©affecter la variable globale √† l\u0026rsquo;int√©rieur de la fonction.\ndef fct2() : global x x += 1 print(x) L\u0026rsquo;appel de fct2() se fait maintenant sans heurt et 3 s\u0026rsquo;affiche.\nCe type de r√©affectation est n√©anmoins √† √©viter, car il am√®ne pas mal de confusion. C\u0026rsquo;est souvent plus logique de passer x en argument de la fonction.\n ¬†Appel de fonction par valeur Lors de l\u0026rsquo;appel d\u0026rsquo;une fonction, les arguments sont copi√©s et la fonction travaille alors uniquement sur cette copie.\nLa copie dispara√Æt lors du retour au programme principal.\nSi la fonction modifie la valeur d\u0026rsquo;un de ses arguments, seule la copie sera modifi√©e, pas la variable du programme principal.\nOn dit que les arguments d\u0026rsquo;une fonction sont transmis par valeurs (par contraste avec la transmission par r√©f√©rence ou adresse comme dans le langage Java o√π une modification de l\u0026rsquo;argument dans la fonction se r√©percute dans le programme principal).\nExemple :\ndef foo(a) : print(\u0026#34;valeur de \u0026#39;a\u0026#39; au d√©but de la fonction :\u0026#34;,a) a = a*2 print(\u0026#34;valeur de \u0026#39;a\u0026#39; √† la fin de la fonction :\u0026#34;,a) a = 2 print(\u0026#34;valeur de \u0026#39;a\u0026#39; dans le programme principal avant l\u0026#39;appel de la fonction :\u0026#34;,a) foo(a) print(\u0026#34;valeur de \u0026#39;a\u0026#39; dans le programme principal apr√®s l\u0026#39;appel de la fonction :\u0026#34;,a) valeur de 'a' dans le programme principal avant l'appel de la fonction : ...\nvaleur de 'a' au d√©but de la fonction : ...\nvaleur de 'a' √† la fin de la fonction : ...\nvaleur de 'a' dans le programme principal apr√®s l'appel de la fonction : ...\nNotons toute fois\n"
},
{
	"uri": "http://example.org/python/",
	"title": "Python",
	"tags": [],
	"description": "",
	"content": "Python √âl√©ments du langage Python dont la connaissance est exigibles aux concours.\nAucun concept sous-jacent n\u0026rsquo;est exigible ainsi qu\u0026rsquo;aucune connaissance sur un module particulier.\n"
},
{
	"uri": "http://example.org/python/typesbase/",
	"title": "Types de base",
	"tags": [],
	"description": "",
	"content": "Types de base Les types de baseen python (les cat√©gories fondamentales des objets manipul√©s) sont :\n  Les entiers int (en anglais, entier se dit integer).\nExemples : 1, 2, 1012, -18 etc. Leur pr√©cision est infinie et leur taille est illimit√©e en Python.\n   Les flottants float. Ce sont des approximations de nombres r√©els. La m√©thode d\u0026rsquo;√©criture en machine de ces nombres, √©quivalente √† une √©criture scientifique pour nombre binaire, explique leur nom : ce sont des nombres √† virgule flottante.\nExemples : 3.58, -0.0398, 2e-7, 3e4 (les puissances de dix, not√©s e ou E renvoient toujours des nombres flottants). Leur pr√©cision est limit√©e √† 53 bits, soit environ 16 chiffres significatifs en d√©cimal.\n C\u0026rsquo;est le point . qui sert de d√©marcation entre la partie enti√®re et la partie d√©cimale et non la virgule ,.\n   Les bool√©ens bool. Ce sont des variables √† deux √©tats, True ou False, permettant de repr√©senter des propositions logiques vraies ou fausses.\n  On peut convertir d\u0026rsquo;un type en l\u0026rsquo;autre en utilisant les fonctions natives int(), float() et bool().\nExemple :\n\u0026gt;\u0026gt;\u0026gt; int(5.8)\n5 int() donne la partie enti√®re d\u0026rsquo;un nombre flottant.\n \u0026gt;\u0026gt;\u0026gt; float(5)\n5.0\n\u0026gt;\u0026gt;\u0026gt; bool(0)\nFalse\n\u0026gt;\u0026gt;\u0026gt; bool(5.8)\nTrue N\u0026rsquo;importe quel nombre non nul (entier ou flottant) est consid√©r√© comme vrai.\n Op√©rations sur les entiers (int) Les entiers sont stables pour les op√©rations suivantes (le r√©sultat est un entier).\nAddition + \u0026gt;\u0026gt;\u0026gt; 2+3\n5\nSoustraction - \u0026gt;\u0026gt;\u0026gt; 2-3\n-1\nMultiplication * \u0026gt;\u0026gt;\u0026gt; 2*3\n6\nDivision enti√®re // a//b donne le quotient de la division euclidienne de a par b.\n\u0026gt;\u0026gt;\u0026gt; 2//3\n0\nAttention √† ne pas confondre avec la division d√©cimale /. Si on travaille avec des entiers, de pr√©cision infinie, il est contre-productif d\u0026rsquo;introduire des flottants en utilisant / plut√¥t que //.\nModulo % a%b donne le reste de la division euclidienne de a par b.\n\u0026gt;\u0026gt;\u0026gt; 2%3\n1 L\u0026rsquo;op√©rateur modulo sert √©norm√©ment en informatique, notamment pour √©viter de d√©passer des valeurs.\n Les op√©rations suivent les r√®gles de priorit√© habituelles, et on utilise les parenth√®ses pour les modifier :\n\u0026gt;\u0026gt;\u0026gt; 8//2*(2+2)\n16\nQue va donner 5*3%2 ? Et 5*(3%2) ?\nPuissance ** \u0026gt;\u0026gt;\u0026gt; 2**3\n8\n On parle aussi d\u0026rsquo;op√©rateur d\u0026rsquo;exponentiation.\n Les puissances n√©gatives retournent des flottants.\n\u0026gt;\u0026gt;\u0026gt; 2**(-3)\n0.125\n ¬†Op√©rations sur les flottants (float) Du moment qu\u0026rsquo;un des deux nombres est un flottant, les op√©rations +, - et * donnent des flottants.\nExemples :\n\u0026gt;\u0026gt;\u0026gt; 3-1.0\n2.0\n\u0026gt;\u0026gt;\u0026gt; 2e-3*500\n1.0\n\u0026gt;\u0026gt;\u0026gt; 2**(5/2)\n5.656854249492381\nLa pr√©cision limit√©e des flottants et le fait qu\u0026rsquo;ils soient d√©finis en binaire peut donner des r√©sultats surprenants.\nExemple :\n\u0026gt;\u0026gt;\u0026gt; 3*0.1\n0.30000000000000004\n La division d√©cimale / retourne un flottant m√™me avec deux entiers, et m√™me si le r√©sultat est entier :\n\u0026gt;\u0026gt;\u0026gt; 3/2.1\n1.4285714285714286\n\u0026gt;\u0026gt;\u0026gt; 10/5\n2.0\n¬†Op√©rations sur les bool√©ens (bool) N√©gation logique (not) Sert √† nier une proposition :\n   P ¬¨P     F V   V F    a , b = True, False print(not a,not b) False True\nDisjonction logique (or)    P Q P ‚à® Q     V V V   V F V   F V V   F F F    print(True or True,True or False,False or True, False or False) True True True False\nConjonction logique (and)    P Q P ‚àß Q     V V V   V F F   F V F   F F F    print(True and True,True and False,False and True, False and False) True False False False\nnot est prioritaire devant and qui est prioritaire devant or.\nQue vaut False or not True and True ?\n ¬†Caract√®re paresseux des op√©rateurs or et and Lorsqu\u0026rsquo;on √©crit a or b, si a est vrai, alors Python ne s\u0026rsquo;emb√™te pas √† √©valuer b. Le r√©sultat est n√©cessairement vrai (cf. la table de v√©rit√©), et c\u0026rsquo;est donc ce qui est retourn√©.\nTrue or qu√©_pasa True\nDe m√™me, si a est faux, alors a and b retourne False sans √©valuer b.\nCe comportement peut s\u0026rsquo;av√©rer utile pour √©viter les erreurs.\nExemple : on veut tester si la premi√®re valeur d\u0026rsquo;une liste est positive. Appelons ce test Test. Si la liste est vide, l\u0026rsquo;expression Test va provoquer une erreur.\nOn ajoute alors un deuxi√®me test, Test_vide, qui n\u0026rsquo;est vrai que si la liste est vide. En utilisant l\u0026rsquo;expression (non Test_vide) and Test, on s\u0026rsquo;assure de ne pas lever d\u0026rsquo;erreur en cas de liste vide.\nPour en savoir plus sur l\u0026rsquo;alg√®bre de Boole :   ¬†Comparaisons Les diff√©rents comparateurs utilisables en Python sont :\n   comparateur signification     == √©gal √†   != diff√©rent de   \u0026gt; sup√©rieur √†   \u0026lt; inf√©rieur √†   \u0026gt;= sup√©rieur ou √©gal √†   \u0026lt;= inf√©rieur ou √©gal √†    Le r√©sultat d‚Äôune comparaison est un bool√©en.\nNe pas confondre l\u0026rsquo;op√©rateur d\u0026rsquo;affectation = et l\u0026rsquo;op√©rateur de comparaison ==.\n La pr√©cision finie des nombres flottants rend leur comparaison dangereuse :\n0.1**2 == 0.01 retourne False !\nSolution : utiliser un encadrement.\n0.1**2 \u0026gt; 0.01 - 1e-9 and 0.1**2 \u0026lt; 0.01 + 1e-9 renvoie bien True.\n Les op√©rateurs de comparaison sont prioritaires devant not, and et or.\nExemple : que vaut not 7.5 \u0026lt; 0.9 or 4 == 4 ?\n "
},
{
	"uri": "http://example.org/semestre_1/",
	"title": "Semestre 1",
	"tags": [],
	"description": "",
	"content": "Semestre 1 Les seÃÅances de travaux pratiques du premier semestre poursuivent les objectifs suivants :\n consolider l‚Äôapprentissage de la programmation en langage Python qui a eÃÅteÃÅ entrepris dans les classes du lyceÃÅe¬†; mettre en place un environnement de travail¬†; mettre en place une discipline de programmation : speÃÅcification preÃÅcise des fonctions et programmes, annotations et commentaires, jeux de tests¬†; introduire les premiers eÃÅleÃÅments de complexiteÃÅ des algorithmes¬†; introduire des outils de validation : variants et invariants.  "
},
{
	"uri": "http://example.org/semestre_2/graphes/",
	"title": "Graphes",
	"tags": [],
	"description": "",
	"content": "Les graphes Quelques points et des traits pour les relier suffisent pour cr√©er un graphe. Cette grande simplicit√© est pourtant √† l\u0026rsquo;origine d\u0026rsquo;un foisonnement math√©matiques impressionnant.\nUn peu d\u0026rsquo;histoire L\u0026rsquo;acte de naissance de la th√©orie des graphes date d\u0026rsquo;une petite √©nigme √† laquelle s\u0026rsquo;attelaient sans succ√®s les habitants de K√∂nigsberg. Comment un voyageur pouvait traverser les sept ponts sans jamais passer deux fois sur le m√™me pont ? Euler r√©sout le probl√®me et fonda du m√™me coup la th√©orie des graphes ! Un graphe permet d\u0026rsquo;extraire l\u0026rsquo;essence du probl√®me : les ar√™tes sont les ponts et les sommets (ou n≈ìuds) sont les zones accessibles depuis ces ponts (s√©par√©es par les bras de rivi√®re).\nLa forme pr√©cise des lignes reliant les points n\u0026rsquo;a pas d\u0026rsquo;importance : elles ne font qu\u0026rsquo;indiquer l\u0026rsquo;existance de laison entre ces points (cela illustre le caract√®re topologique et non g√©om√©trique du probl√®me). Euler compris alors que ce qu\u0026rsquo;on appelerait ensuite un chemin eul√©rien (un cheminreliant chaque sommet en ne passant qu\u0026rsquo;une fois par chaque ar√™te) n\u0026rsquo;est possible que si le graphe ne compte pas plus de deux sommets d\u0026rsquo;o√π partent un nombre impair d\u0026rsquo;ar√™tes. Or dans le cas de K√∂nigsberg, c\u0026rsquo;est le cas de chacun des sept sommets. Un chemin eul√©rien y est donc impossible !\nLorsqu\u0026rsquo;on trace un chemin eul√©rien sur un graphe, trois types de sommets se pr√©sentent : un sommet peut √™tre soit un point de d√©part, soit un point d\u0026rsquo;arriv√©e, soit un point travers√© (on y arrive puis on en repart). Et pour ces derniers, on aura toujours un nombre pair d\u0026rsquo;ar√™tes (autant d\u0026rsquo;arriv√©es que de d√©parts)\u0026hellip;\n Ce premier pas d\u0026rsquo;Euler eut lieu en 1737, il fallut attendre ensuite plus de cent ans pour que Kirchhoff r√©utilise des graphes pour d√©terminer les intensit√©s circulant dans les diff√©rentes branches d\u0026rsquo;un circuit √©lectrique ; il met alors au point la notion d'arbre, des graphes sans boucle, en 1847.\nDix ans plus tard, c\u0026rsquo;est au tour de la chimie de s\u0026rsquo;attaquer aux graphes. En 1857, Cayley s\u0026rsquo;int√©resse aux diff√©rentes structures possibles (isom√®res) d\u0026rsquo;une mol√©cule ayant $n$ atomes de carbone et $2n+2$ atomes d\u0026rsquo;hydrog√®ne (un alcane). Cela revient √† trouver tous les arbres √† $3n+2$ √©l√©ments tels que de chaque √©l√©ment (chaque sommet) partent exactement une ou quatre ar√™tes (symbolisant les liaisons chimiques).\nEn 1869, enfin, les math√©maticiens red√©couvrent les graphes, par la voix de Jordan qui, sans conna√Ætre les travaux de Cayley, retrouve ses r√©sultats.\nLes jeux ne sont pas en reste : en 1859, le math√©maticien et physicien irlandais William Hamilton invente \u0026ldquo;The Icosian Game\u0026rdquo;, dont le but est de visiter une et une seule fois tous les sommets d\u0026rsquo;un dod√©ca√®dre r√©gulier. Un tel chemin est depuis appel√© hamiltonien.Apparemment voisin du probl√®me du chemin eul√©rien (visiter une et une seule fois chaque ar√™te), le probl√®me du chemin hamiltonien est en r√©alit√© beaucoup plus difficile.Pour ce qui est du jeu que vous pouvez tester ci-dessous, une r√®gle suppl√©mentaire impose que la fin du chemin soit adjacente √† son d√©but. En rejoignant le point de d√©part, on formerait alors un cycle et on appelle ainsi cycle hamiltonnien un cycle passant par tous les sommets.\n¬†\nLe deuxi√®me moiti√© du 20esi√®cle et l\u0026rsquo;av√®nement de l\u0026rsquo;informatique voit la th√©orie des graphes prendre son v√©ritable essor : c\u0026rsquo;est en effet l\u0026rsquo;outil id√©al pour d√©crire les r√©seaux complexes modernes.\n  Les r√©seaux sont partout : les r√©seaux sociaux et les r√©seaux de communication, mais on trouve aussi des r√©seaux dans des champs scientifiques tr√®s diff√©rents comme en biologie, logistique, linguistique, √©conomie, etc.\nLa th√©orie des graphes donne un langage commun √† la description de ces r√©seaux.\n¬†Vocabulaire Graphes non orient√©s Un graphe $G$ est un ensemble de sommets (ou n≈ìuds) S (not√©s $s_i$) et d\u0026rsquo;ar√™tes A (not√©es $\\{s_i,s_j\\}$) reliant deux √† deux ces sommets. On note un tel graphe : $G = (S,A)$.\n Quelques exemples dans des champs vari√©s :\n   R√©seau Sommets Ar√™tes     transport a√©rien a√©roports vols   plans routiers carrefours tron√ßons de routes   r√©seau g√©n√©tique g√®nes facteurs de transcription   cerveau neurones synapses   colonie de fourmis jonctions traces de ph√©romones   appels t√©l√©phoniques num√©ro appel   r√©seau de citation auteur citation    Est repr√©sent√© ci-dessus le graphe $G=(S,A)$ avec $S=\\{1,2,3,4,5,6\\}$ et $A=\\{\\{1,2\\},\\{1,5\\},\\{2,5\\},\\{3,3\\},\\{4,6\\}\\}$\nUne boucle est une ar√™te reliant un sommet √† lui-m√™me\n Exemple : il y a une boucle sur le sommet $3$.\nL\u0026rsquo;ensemble des sommets adjacents (joints par une ar√™te) au sommet $s_i$, autrement dit les voisins du sommet $s_i$, se note : $Adj(s_i)=\\{s_j \\in S,\\{ s_i,s_j \\}\\in A\\}$.\n Exemple : $Adj(2)=\\{1,5\\}$\n Un graphe non orient√© est dit simple s\u0026rsquo;il ne comporte pas de boucle et jamais plus d\u0026rsquo;une ar√™te entre deux sommets.\n Le graphe ci-dessus n\u0026rsquo;est donc pas simple.\nOn appelle ordre d\u0026rsquo;un graphe le nombre de ses sommets ($card(S)$ ou plus simplement $|S|$).\n Exemple : pour le graphe ci-dessus $|S|=6$\nOn appelle taille d\u0026rsquo;un graphe le nombre de ses ar√™tes ($card(A)$ ou $|A|$).\n Exemple : pour le graphe ci-dessus $|A|=5$\n¬†Graphes orient√©s Les ar√™tes d\u0026rsquo;un graphe non orient√© sont sym√©triques, elles se parcourent indiff√©remment dans les deux sens, mais ce n\u0026rsquo;est pas toujours tr√®s pertinent. Consid√©rons les exemples suivants :\n Supposons que l\u0026rsquo;on veuille mod√©liser un plan routier. On associe naturellement un carrefour √† un sommet et une rue √† une ar√™te. Mais on a besoin en plus d\u0026rsquo;une notion de direction pour repr√©senter les rues √† sens unique. Pour mod√©liser des relations sociales, une ar√™te entre Alice et Bob mod√©lise un lien, mais comment repr√©senter le fait que Bob connaisse Alice, mais que l\u0026rsquo;inverse soit faux ? Dans un r√©seau d\u0026rsquo;ordinateur, en particulier sans fil, le lien entre deux n≈ìuds est g√©n√©ralement non sym√©trique dans le sens o√π un message peut √™tre envoy√© de A vers B, mais pas l\u0026rsquo;inverse.  Pour mod√©liser ce type de situation, on utilise des graphes orient√©s.\nDans un graphe orient√©, les sommets sont reli√©s par des arcs que l\u0026rsquo;on peut identifier √† des couples de sommets (un couple a un ordre) : au couple $(a,b)$ correspond un arc d\u0026rsquo;origine $a$ et d\u0026rsquo;extr√©mit√© $b$.\n L\u0026rsquo;arc $a = (s_i,s_j)$ est dit sortant en $s_i$ et incident ou entrant en $s_j$, et $s_j$ est un successeur de $s_i$, tandis que $s_i$ est un pr√©d√©cesseur de $s_j$.\n L\u0026rsquo;ensemble des successeurs d\u0026rsquo;un sommet $s_i \\in S$ est not√© $Succ(s_i) = \\{s_j \\in S,(s_i,s_j) \\in A\\}$.\nL\u0026rsquo;ensemble des pr√©d√©cesseurs d\u0026rsquo;un sommet $s_i \\in S$ est not√© $Pred(s_i) = \\{s_j \\in S,(s_j,s_i) \\in A\\}$.\n Un graphe orient√© permet, par exemple, de r√©sumer les relations dans un chi-fou-mi (ici dans la variante puits montrant bien que jouer \u0026ldquo;pierre\u0026rdquo; est sans int√©r√™t, ou encore dans la variante pierre-feuille-ciseaux-l√©zard-spock de The Big Bang Theory). Pour \u0026ldquo;pierre-feuille-ciseaux-puits\u0026rdquo;, le graphe $G(S,A)$ a pour sommets $S=\\{pierre,feuille,ciseaux,puits\\}$ et pour ar√™tes $A=\\{(ciseaux,feuille),(feuille,puits),(feuille,pierre),(puits,pierre),(puits,ciseaux),(pierre,ciseaux)\\}$.\n¬†Degr√© d\u0026rsquo;un sommet Dans un graphe non-orient√©, le degr√© d\u0026rsquo;un sommet $s$ est le nombre d\u0026rsquo;ar√™tes incidentes √† ce sommet (une boucle comptant pour 2).\nDans le cas d\u0026rsquo;un graphe simple, on aura $d(s) = |Adj(s)|$ (nombre de sommets adjacents).\n Dans un graphe orient√©, le degr√© sortant d\u0026rsquo;un sommet $s$, not√© $d_+(s)$, est le nombre d\u0026rsquo;arcs partant de $s$ (de la forme $(s,v)$ avec $s,v \\in S$).\nDans le cas d\u0026rsquo;un graphe simple, on aura $d_+(s) = |Succ(s)|$ (nombre de successeurs).\nDe m√™me, le degr√© entrant d\u0026rsquo;un sommet $s$, not√© $d_‚àí(s)$, est le nombre d\u0026rsquo;arcs arrivant en $s$ (de la forme $(v, s)$ avec $s,v \\in S$).\nDans le cas d\u0026rsquo;un graphe simple, on aura $d_‚àí(s) = |Pred(s)|$ (nombre de pr√©d√©cesseurs).\nLe degr√© d\u0026rsquo;un sommet $s$ d\u0026rsquo;un graphe orient√© est donc la somme des degr√© entrant et sortant : $d(s) = d_+(s) + d_‚àí(s)$.\n Exemple : $d_+(puits)=2$ et $d_-(puits)=1$, d\u0026rsquo;o√π $d(puits) = d_+(puits) + d_‚àí(puits)=2+1=3$\n Pour tout graphe, la somme des degr√©s de chaque sommet est le double du nombre d\u0026rsquo;ar√™tes. $$\\sum_{s \\in S} d(s) = 2*|A|$$\n $d(puits)=d(feuille)=d(ciseaux)=d(pierre)=3$ d\u0026rsquo;o√π $\\sum_{s \\in S} d(s) = 12$. Et on a bien $|A|=6$. Et pour un graphe orient√©, la somme des degr√©s entrant vaut la somme des degr√©s sortants et est aussi √©gal au nombre d\u0026rsquo;ar√™tes. $$\\sum_{s \\in S} d_+(s) = \\sum_{s \\in S} d_-(s) = |A|$$\n     $d_+$ $d_-$     puits 2 1   feuille 2 1   ciseaux 1 2   pierre 1 2    $\\sum_{s \\in S} d_+(s) =\\sum_{s \\in S} d_-(s) =|A|=6$\nOn en d√©duit que pour tout graphe, il y a un nombre pair de sommets √† degr√© impair.\n Le degr√© d\u0026rsquo;un sommet est un concept simple, mais f√©cond, utilis√© dans des contextes tr√®s diff√©rents. Dans un r√©seau social, le degr√© d\u0026rsquo;un sommet traduit l\u0026rsquo;importance d\u0026rsquo;une personne dans le groupe. Dans un r√©seau de communication comme Internet, on apprend beaucoup sur l\u0026rsquo;organisation r√©elle du r√©seau √† partir de la distribution obtenue en ordonnant les sommets par leurs degr√©s.\n¬†Chemin, cha√Æne, cycle et circuit Cas des graphes orient√©s Soit $G = (S, A)$ un graphe orient√©.\nUn chemin d\u0026rsquo;un sommet $u$ vers un sommet $v$ est une s√©quence $\u0026lt; s_0,s_1,s_2,\u0026hellip;,s_k \u0026gt;$ de sommets tels que $u = s_0$, $v = s_k$ et $(s_{i‚àí1},s_i) \\in A$ pour tout $i \\in \\{1,\u0026hellip;,k\\}$.\nOn dira que le chemin contient les sommets $s_0,s_1,\u0026hellip;,s_k$ et les arcs $(s_0,s_1),(s_1,s_2),\u0026hellip;,(s_{k‚àí1},s_k)$.\nLa longueur du chemin est le nombre d\u0026rsquo;arcs dans le chemin, c\u0026rsquo;est-√†-dire $k$.\n S\u0026rsquo;il existe un chemin de $u$ √† $v$, on dira que $v$ est accessible √† partir de $u$.\n Un chemin $\u0026lt; s_0,s_1,\u0026hellip;,s_k \u0026gt;$ forme un circuit si $s_0 = s_k$ et si le chemin comporte au moins un arc ($k ‚â• 1$).\n Une boucle est un circuit de longueur $1$.\n  $\u0026lt;6,3,2,1\u0026gt;$ est un chemin du graphe. $\u0026lt;1,5,3,2,1\u0026gt;$ est un circuit.  Cas des graphes non orient√©s Si $G = (S, A)$ est un graphe non orient√©, on parlera de cha√Æne au lieu de chemin, et de cycle au lieu de circuit.\nDans le cas d\u0026rsquo;un cycle, toutes les ar√™tes doivent √™tre distinctes.\nUn graphe sans cycle est dit acyclique.\n  Un arbre est est un graphe acyclique et connexe.\n La ligne A du RER forme un arbre, mais pas la ligne C.\n¬†Distance dans un graphe La notion de longueur de chemin nous permet ensuite de d√©finir la notion de distance dans un graphe.\nSoit un graphe $G=(S,A)$. La distance d\u0026rsquo;un sommet √† un autre est la longueur du plus court chemin/cha√Æne entre ces deux sommets, ou $\\infty$ s\u0026rsquo;il n\u0026rsquo;y a pas un tel chemin/cha√Æne :\n$$ \\forall x,y \\in S,d(x,y)=\\left\\lbrace \\begin{array}{ll} k \\; \u0026amp;\\text{si le plus court chemin de x vers y est de longueur k}\\\\ \\infty \u0026amp;\\text{sinon}\\end{array}\\right. $$\n Le diam√®tre du graphe est la plus grande distance entre deux sommets.\n Exemple : dans le graphe orient√© ci-dessus $d(2,3)=3$, et $d(3,6)=\\infty$ (le sommet $6$ n\u0026rsquo;est pas accessible depuis le sommet $3$). Le diam√®tre du graphe vaut, lui, 4 (il s\u0026rsquo;agit de $d(6,5)$).\n¬†Connexit√© Un graphe non orient√© est connexe si chaque sommet est accessible √† partir de n\u0026rsquo;importe quel autre (pour tout couple de sommets distincts $(s_i,s_j) \\in S^2$, il existe une cha√Æne entre $s_i$ et $s_j$).\n Le graphe comportant les sommets $1,2,3,4$ n\u0026rsquo;est pas connexe mais celui comportant les sommets $5,6,7,8$ l\u0026rsquo;est !\n¬†Repr√©sentation d\u0026rsquo;un graphe Listes d\u0026rsquo;adjacence Soit le graphe $G = (S,A)$ d\u0026rsquo;ordre $n$. On suppose que les sommets de $S$ sont num√©rot√©s de $1$ √† $n$. La repr√©sentation par listes d\u0026rsquo;adjacence de $G$ consiste en un tableau $T$ de $n$ listes, une pour chaque sommet de $S$.\nPour chaque sommet $s_i \\in S$, la liste d\u0026rsquo;adjacence $T[s_i]$ est une liste de tous les sommets $s_j$ tels qu\u0026rsquo;il existe un arc $(s_i,s_j) \\in A$ ou une ar√™te $\\{s_i,s_j\\} \\in A$.\nAutrement dit, pour chaque sommet, on liste ses voisins accessibles.\n Les sommets de chaque liste d\u0026rsquo;adjacence sont g√©n√©ralement list√©s selon un ordre arbitraire.\nPour l\u0026rsquo;impl√©mentation Python, on peut soit utiliser des listes imbriqu√©s, soit un dictionnaire.\nExemple : # Avec un dictionnaire T = {1:[1,3],2:[1,3,4],3:[],4:[1,2,3,4]} # Avec des listes imbriqu√©es T = [[1,3],[1,3,4],[],[1,2,3,4]] L\u0026rsquo;avantage du dictionnaire est qu\u0026rsquo;il n\u0026rsquo;impose pas d\u0026rsquo;avoir une correspondance entre le num√©ro du sommet et la position dans la liste d\u0026rsquo;adjacence (dans le cas de listes imbriqu√©es T[0] sera toujours la liste correspondant au premier sommet, T[1], celle du deuxi√®me, etc.).\nTaille m√©moire n√©cessaire: si le graphe G est orient√©, la somme des longueurs des listes d\u0026rsquo;adjacence est √©gale au nombre d\u0026rsquo;arcs de A, puisque l\u0026rsquo;existence d\u0026rsquo;un arc $(s_i,s_j)$ se traduit par la pr√©sence de $s_j$ dans la liste d\u0026rsquo;adjacence de $T[s_i]$.\nEn revanche, si le graphe n\u0026rsquo;est pas orient√©, la somme des longueurs de toutes les listes d\u0026rsquo;adjacence est √©gale √† deux fois le nombre d\u0026rsquo;ar√™tes du graphe, puisque si ${s_i,s_j}$ est une ar√™te, alors $s_i$ appartient √† la liste d\u0026rsquo;adjacence de $T[s_j]$, et vice versa.\nPar cons√©quent, la liste d\u0026rsquo;adjacence d\u0026rsquo;un graphe ayant $n$ sommets et $m$ arcs ou ar√™tes n√©cessite de l\u0026rsquo;ordre de $O(n + m)$ emplacements m√©moire.\n Op√©rations sur les listes d\u0026rsquo;adjacence : il n\u0026rsquo;existe pas de moyen plus rapide que de parcourir la liste d\u0026rsquo;adjacence de $T[s_i]$ jusqu\u0026rsquo;√† trouver $s_j$ pour tester l\u0026rsquo;existence d\u0026rsquo;un arc $(s_i, s_j)$ ou d\u0026rsquo;une ar√™te ${s_i, s_j }$ avec une repr√©sentation par liste d\u0026rsquo;adjacence.\nEn revanche, le calcul du degr√© d\u0026rsquo;un sommet, ou l\u0026rsquo;acc√®s √† tous les successeurs d\u0026rsquo;un sommet, est tr√®s efficace : il suffit de parcourir la liste d\u0026rsquo;adjacence associ√©e au sommet. D\u0026rsquo;une fa√ßon plus g√©n√©rale, le parcours de l\u0026rsquo;ensemble des arcs/ar√™tes n√©cessite le parcours de toutes les listes d\u0026rsquo;adjacence, et prendra un temps de l\u0026rsquo;ordre de $p$, o√π $p$ est le nombre d\u0026rsquo;arcs/ar√™tes.\n Le calcul des pr√©d√©cesseurs d\u0026rsquo;un sommet est mal ais√© avec cette repr√©sentation, et n√©cessite le parcours de toutes les listes d\u0026rsquo;adjacences de $T$. Une solution dans le cas o√π l\u0026rsquo;on a besoin de conna√Ætre les pr√©d√©cesseurs d\u0026rsquo;un sommet est de maintenir, en plus de la liste d\u0026rsquo;adjacence des successeurs, la liste d\u0026rsquo;adjacence des pr√©d√©cesseurs.\n¬†Matrice d\u0026rsquo;adjacence Soit le graphe $G = (S,A)$ d\u0026rsquo;ordre $n$. On suppose que les sommets de $S$ sont num√©rot√©s de $1$ √† $n$. La repr√©sentation par matrice d\u0026rsquo;adjacence de $G$ consiste en une matrice bool√©enne $M=(m_{i,j})$ de taille $n\\times n$ telle que $m_{i,j} = 1$ si $ (i,j) \\in A$, et $m_{i,j} = 0$ sinon.\n La matrice d\u0026rsquo;adjacence d\u0026rsquo;un graphe non orient√© sera toujours sym√©trique, mais pas n√©cessairement celle d\u0026rsquo;un graphe orient√©.\n Impl√©mentation Python :\nM = [[1,0,1,0],[1,0,1,1],[0,0,0,0],[1,1,1,1]] # pour savoir si un arc joint le sommet 1 au sommet 3 M[0][2] # pour savoir si un arc joint le sommet 3 au sommet 1 M[2][0] Taille m√©moire n√©cessaire : La matrice d\u0026rsquo;adjacence d\u0026rsquo;un graphe ayant $n$ sommets n√©cessite de l\u0026rsquo;ordre de $O(n^2)$ emplacements m√©moire.\nSi le nombre d\u0026rsquo;arcs est tr√®s inf√©rieur √† $n^2$ (on parle alors de graphe creux), cette repr√©sentation est loin d\u0026rsquo;√™tre optimale.\n Op√©rations sur les matrices d\u0026rsquo;adjacence :\nle test de l\u0026rsquo;existence d\u0026rsquo;un arc ou d\u0026rsquo;une ar√™te avec une repr√©sentation par matrice d\u0026rsquo;adjacence est imm√©diat (il suffit de tester directement la case correspondante de la matrice).\nEn revanche, conna√Ætre le degr√© d\u0026rsquo;un sommet n√©cessite le parcours de toute une ligne (ou toute une colonne) de la matrice. D\u0026rsquo;une fa√ßon plus g√©n√©rale, le parcours de l\u0026rsquo;ensemble des arcs/ar√™tes n√©cessite la consultation de la totalit√© de la matrice, et prendra un temps de l\u0026rsquo;ordre de $n^2$.\n Application : Combien y a-t-il de chemins menant d\u0026rsquo;un sommet √† un autre en exactement $n$ coups ?\nOn cherche donc les chemins de longueur $n$ entre deux sommets $i$ et $j$.\nSoit $M = (m_{i,j})$ la matrice d\u0026rsquo;adjacence d\u0026rsquo;un graphe $G(S,A)$. $M$ est donc aussi le nombre de chemin de $i$ √† $j$ de longueur $1$ (une seul ar√™te), que l\u0026rsquo;on va noter $m_{i,j}(1)$.\nL\u0026rsquo;id√©e est alors de d√©couper le chemin de longueur $n$ en un chemin de longueur $n-1$ suivi d\u0026rsquo;un chemin de longueur $1$. Le nombre $m_{i,j}(n)$ de chemins de longueur $n$ est ainsi donn√© par : $$ m_{i,j}(n)=\\sum_{k=1}^{|S|}m_{i,k}(n-1)\\times m_{k,j}(1)$$ Pour $ m_{i,j}(2) $, on obtient $m_{i,j}(n)=\\sum_{k=1}^{|S|}m_{i,k}(1)\\times m_{k,j}(1)$ qui n\u0026rsquo;est autre que $M^2$ (on reconna√Æt en effet la formule du produit matriciel).\nEt par une r√©currence imm√©diate, pour des chemins de longueur $n$, il suffit de calculer $M^n$.\nExemple : combien y a-t-il de chemins de longueur 4 entre les sommets 2 et 3 du graphe repr√©sent√© ci-dessous. La matrice d\u0026rsquo;adjacence du graphe vaut $M = \\begin{pmatrix}1\u0026amp;1\u0026amp;0\\\\0\u0026amp;0\u0026amp;1\\\\1\u0026amp;1\u0026amp;0\\end{pmatrix}$. Utilisons Python pour calculer $M^4$ :\nimport numpy as np # librairie tr√®s utile pour les calculs sur matrices from numpy.linalg import matrix_power M = [[1,1,0],[0,0,1],[1,1,0]] M = np.array(M) # on convertit M en tableau numpy M4 = matrix_power(M,4) print(f\u0026#34;Il y a {M4[2][0]} chemins de longueur 4 du sommet 3 au sommet 1.\u0026#34;) Il y a 3 chemins de longueur 4 du sommet 3 au sommet 1. ¬†Parcours d\u0026rsquo;un graphe Pour d√©terminer si un sommet est accessible depuis un autre sommet, il faut pouvoir parcourir m√©thodiquement l\u0026rsquo;ensemble du graphe.\nAlgorithme de parcours en largeur Une premi√®re m√©thode, l\u0026rsquo;algorithme de parcours en largeur (ou breadth-first algorithm), consiste √† partir d\u0026rsquo;un n≈ìud, d\u0026rsquo;explorer tous ses successeurs, puis les successeurs de chacun de ses successeurs, etc., jusqu\u0026rsquo;√† ce qu\u0026rsquo;il n\u0026rsquo;y ait plus de sommets.\nCela revient √† inspecter le graphe par couche concentrique de plus en plus √©loign√©es du n≈ìud source.\nPour impl√©menter un tel algorithme, la structure de donn√©es adapt√©e est la file.\n Les files (queues en anglais) sont des structures dynamiques (les √©l√©ments sont enfil√©s ou d√©fil√©s) qui, √† l\u0026rsquo;instar d\u0026rsquo;une file d\u0026rsquo;attente √† une caisse, c\u0026rsquo;est le premier arriv√© qui est le premier retir√© (FIFO pour \u0026ldquo;first in first out\u0026rdquo;). Les files sont utilis√©es par exemple lorsqu\u0026rsquo;il y a une possibilit√© d\u0026rsquo;encombrement (pour une imprimante partag√©e par exemple).\n L\u0026rsquo;id√©e est de placer chaque nouveau successeur au bout d\u0026rsquo;une file (enfiler), puis de retirer un √† un (d√©filer) les premiers arriv√©s (donc les plus proches) lorsqu\u0026rsquo;ils sont √† leur tour inspect√©s.\nPour l\u0026rsquo;impl√©mentation des files, on pourrait utiliser des listes python en ajoutant toujours les √©l√©ments √† la fin et les retirant au d√©but, mais ce n\u0026rsquo;est pas tr√®s efficace. En effet, l\u0026rsquo;ajout d\u0026rsquo;un √©l√©ment en d√©but de liste √† un co√ªt lin√©aire (proportionnel √† la taille de la liste). On pourrait pourtant tirer partie de la structure particuli√®rement simple des files o√π seule deux positions (premi√®re et derni√®re) nous int√©ressent.\nMais comme souvent en python, un module d√©di√©, ici collecions.deque, peut nous venir en aide. Il impl√©ment efficacement les files en permettant un enfilage et un d√©filage en temps constant.\nG = {\u0026#34;Bob\u0026#34; : [\u0026#34;Alice\u0026#34;,\u0026#34;Dave\u0026#34;,\u0026#34;Charlie\u0026#34;], \u0026#34;Alice\u0026#34; : [\u0026#34;Elisa\u0026#34;], \u0026#34;Charlie\u0026#34; : [\u0026#34;Elisa\u0026#34;,\u0026#34;Hector\u0026#34;], \u0026#34;Dave\u0026#34; : [\u0026#34;Farid\u0026#34;,\u0026#34;Gus\u0026#34;], \u0026#34;Elisa\u0026#34; : [], \u0026#34;Farid\u0026#34; : [], \u0026#34;Gus\u0026#34; : [], \u0026#34;Hector\u0026#34; : [] } from collections import deque # pr√©conditions: graphe G(S,A) repr√©sent√© par une liste d\u0026#39;adjacence par un dictionnaire et un sommet s de S # postconditions : un sommet est accessible depuis s si et seulement si il est marqu√© comme \u0026#34;vu\u0026#34; (dans la liste vus). def parcours_largeur(G,depart): file = deque() file.append(depart) Sommets = [] Vus = [] while file : sommet = file.popleft() # m√©thode de la classe deque permettant de d√©filer (√©quivaut √† pop(0) sur une liste) if not sommet in Vus : file += G[sommet] Vus.append(sommet) # on marque les sommets vus (√©vite ici d\u0026#39;avoir 2 Elisa, mais √ßa peut √™tre bien pire) Sommets.append(sommet) return Sommets parcours_largeur(G,\u0026quot;Bob\u0026quot;) renvoie ['Bob', 'Alice', 'Dave', 'Charlie', 'Elisa', 'Farid', 'Gus', 'Hector']. Si on ne marque pas les sommets vus (ici gr√¢ce √† la liste vus), on se retrouve avec une boucle infinie d√®s qu\u0026rsquo;il y a un circuit ou un cycle (le simple graphe ü¶â‚áÜüêò par exemple).\n Que vaut la complexit√© temporelle de l\u0026rsquo;algorithme ? Que devient-elle sans l\u0026rsquo;utilisation de la classe deque fournissant une vraie file ?\n¬†Exemples d\u0026rsquo;applications du parcours en largeur :\n utilis√© par les robots d\u0026rsquo;exploration des moteurs de recherche pour construire l\u0026rsquo;index des pages web, recherche dans les r√©seaux sociaux, recherche d\u0026rsquo;un n≈ìud voisin accessible dans les r√©seaux peer-to-peer.  ¬†Algorithme de parcours en profondeur Cette fois-ci, on explore jusqu\u0026rsquo;au bout chaque cha√Æne de successeurs du n≈ìud source avant de passer √† la suivante.\nCette fois-ci, la structure de donn√©es dynamique adapt√©e est la pile.\n Les piles (stacks en anglais) sont des structures dynamiques (des √©l√©ments sont ajout√©s = empil√©s, ou retir√©s = d√©pil√©s) ayant la propri√©t√© que l‚Äô√©l√©ment extrait est celui qui y a √©t√© introduit le plus r√©cemment (\u0026ldquo;dernier entr√©, premier sortie\u0026rdquo; ou LIFO \u0026ldquo;last in first out\u0026rdquo; en anglais). C\u0026rsquo;est l\u0026rsquo;√©quivalent informatique d\u0026rsquo;une pile d\u0026rsquo;assiettes. Cette structure est par exemple utilis√©e dans la fonction \u0026ldquo;annuler\u0026rdquo; (CTR-Z) d\u0026rsquo;un logiciel ou encore dans le traitement des fonctions r√©cursives (les piles seront √©tudi√©es plus en d√©tail en seconde ann√©e).\n def parcours_profondeur(G,depart): pile = deque() pile.append(depart) Sommets = [] Vus = [] while pile : sommet = pile.pop() if not sommet in Vus : pile += G[sommet] Vus.append(sommet) Sommets.append(sommet) return Sommets parcours_largeur(G,\u0026quot;Bob\u0026quot;) renvoie ['Bob', 'Charlie', 'Hector', 'Elisa', 'Dave', 'Gus', 'Farid', 'Alice'].\nOn remarque que les deux algorithmes ne diff√®rent que par la structure de donn√©es utilis√©e, mais loin d\u0026rsquo;√™tre anodin, ce passage de la file √† la pile change compl√®tement le principe du parcours !\nCela illustre bien que la conception d\u0026rsquo;un algorithme est tr√®s d√©pendantes des structures de donn√©es utilis√©es.\nUne structure de donn√©e est une fa√ßon d\u0026rsquo;organiser les donn√©es de telle sorte que certaines op√©rations sur ces donn√©es soient tr√®s rapides. Une structure de donn√©e est donc sp√©cialis√©e dans ces quelques op√©rations.\nLors de la conception, d\u0026rsquo;un algorithme, l\u0026rsquo;identification des diff√©rentes op√©rations √† effectuer va guider le choix de la structure de donn√©e adapt√©e.\nPar exemple, l\u0026rsquo;algorithme de recherche en largeur doit g√©rer un ensemble o√π le premier √©l√©ment ajouter doit toujours √™tre le premier retir√© (logique FIFO) $\\rightarrow$ utilisation d\u0026rsquo;une file qui g√®re l\u0026rsquo;ajout d\u0026rsquo;un √©l√©ment √† la fin d\u0026rsquo;une file d\u0026rsquo;attente et l\u0026rsquo;extraction au d√©but en temps constant (elle est optimis√© pour √ßa, mais en contrepartie, elle ne sait faire que √ßa).\nL\u0026rsquo;algorithme de recherche en profondeur suit lui la logique LIFO $\\rightarrow$ utilisation d\u0026rsquo;une pile.\nDernier exemple : l\u0026rsquo;algorithme de Dijkstra (d√©crit plus loin) a besoin √† chaque it√©ration d\u0026rsquo;ajouter un √©l√©ment √† un ensemble et d\u0026rsquo;en retirer le plus petit √©l√©ment $\\rightarrow$ ce sont les deux op√©rations dont le tas s\u0026rsquo;est fait le sp√©cialiste (le tas est un arbre binaire presque complet ordonn√©). Un tas sp√©cialis√© dans ces deux op√©rations s\u0026rsquo;appelle est aussi appel√© file de priorit√©. Dans quels autres algorithmes pourrait avantageusement √™tre utilis√© un tas ?\n Nous n\u0026rsquo;avions pas r√©ellement besoin de la classe deque pour impl√©menter efficacement la pile. En effet, si ins√©rer un √©l√©ment au d√©but d\u0026rsquo;une liste python de taille $n$ a bien un co√ªt lin√©aire ($O(n)$) et ralentit donc l\u0026rsquo;ex√©cution par rapport √† l\u0026rsquo;utilisation d\u0026rsquo;une file, retirer un √©l√©ment √† la fin (via pop) se fait en temps constant ($O(1)$).\n¬†Exemples d\u0026rsquo;applications du parcours en profondeur :\n utilis√© pour trouver un chemin entre deux sommets, d√©tection de cycles dans un graphe, utilis√© dans le tri topologique, utilis√© pour trouver la sortie d\u0026rsquo;un labyrinthe.  ¬†Graphes pond√©r√©s Dans de nombreuses situations, les ar√™tes d\u0026rsquo;un graphe ne sont pas toutes √©quivalentes. On ajoute alors l\u0026rsquo;information du \u0026ldquo;co√ªt\u0026rdquo; que cela repr√©sente d\u0026rsquo;emprunter telle ou telle ar√™te. On appelle poids ces valeurs ajout√©es aux ar√™tes/arcs.\nPar exemple, pour mod√©liser un r√©seau ferroviaire, on peut attribuer √† chaque ar√™te mod√©lisant les jonctions entre deux gares la distance correspondante. Et pour un r√©seau de communication, le poids d\u0026rsquo;une ar√™te correspondra plut√¥t au temps n√©cessaire pour transf√©rer un message de taille √©l√©mentaire.\nOn obtient alors un graphe pond√©r√©.\nOn utilise aussi souvent des graphes pond√©r√©s, plus particuli√®rement des arbres de probabilit√© (o√π chaque branche est affubl√©e d\u0026rsquo;une probabilit√©) pour calculer des probabilit√©s conditionnelles.\nExemple : Tr√®s souvent (particuli√®rement pour les r√©seaux de communication), l\u0026rsquo;information ajout√©e au graphe un temps ou une distance et se pose alors le probl√®me de l\u0026rsquo;optimisation d\u0026rsquo;un trajet entre deux sommets.\nLe poids d\u0026rsquo;un chemin est la somme des poids des arcs emprunt√©s.\n La distance entre deux sommets (dans un graphe pond√©r√©) correspond au chemin de poids minimum entre ces deux sommets.\n ¬†Probl√®me du plus court chemin Pas au programme de TSI mais plus prudent d\u0026rsquo;en avoir entendu parler pour l\u0026rsquo;√©preuve de Centrale qui jusqu\u0026rsquo;√† maintenant √©tait commune aux autres sections.\n Si le graphe consid√©r√© n\u0026rsquo;est pas pond√©r√©, l\u0026rsquo;algorithme de parcours en largeur, moyennant quelques adaptations, est tout √† fait capable de faire le travail.\nAlgorithme de parcours en largeur Comme l\u0026rsquo;algorithme de parcours en largeur examine le graphe en couches concentriques depuis le sommet de d√©part, lorsqu\u0026rsquo;il parvient au sommet cible, on est s√ªr que le nombre d\u0026rsquo;arcs est minimal.\nIl suffit alors de joindre √† la liste des sommets examin√©s, la liste des chemins permettant de parvenir √† chacun de ces sommets (en incr√©mentant √† chaque tour chacun des chemins du sommet correspondant de la nouvelle couche).\ndef recherche_largeur(G,depart,arrivee): file = [(depart,[depart])] # on remplace la file des sommets par une file de tuples (sommet,chemin) Vus = [] while file : sommet,chemin = file.pop(0) # pop(0) fait la m√™me chose que le popleft des deque if sommet == arrivee : return chemin # si l\u0026#39;arriv√©e est atteinte, on retourne le chemin correspondant if not sommet in Vus : for s in G[sommet] : nv_chemin = chemin+[s] file.append((s,nv_chemin)) Vus.append(sommet) return False # si l\u0026#39;arriv√©e n\u0026#39;est pas atteinte, on renvoie Faux G = {\u0026#34;Minimes\u0026#34; : {\u0026#34;Tasdon\u0026#34;,\u0026#34;H√¥pital\u0026#34;}, \u0026#34;H√¥pital\u0026#34; : {\u0026#34;Verdun\u0026#34;}, \u0026#34;Verdun\u0026#34; : {\u0026#34;Stade\u0026#34;}, \u0026#34;Tasdon\u0026#34; : {\u0026#34;Cognehors\u0026#34;, \u0026#34;Lafond\u0026#34;}, \u0026#34;Cognehors\u0026#34; : {\u0026#34;Verdun\u0026#34;}, \u0026#34;Lafond\u0026#34; : {\u0026#34;Mireuil\u0026#34;}, \u0026#34;Mireuil\u0026#34; : {\u0026#34;Stade\u0026#34;}, \u0026#34;Stade\u0026#34; : {} } recherche_largeur(G,\u0026quot;Minimes\u0026quot;,\u0026quot;Stade\u0026quot;) retourne bien le chemin comportant le moins d\u0026rsquo;ar√™tes : ['Minimes', 'H√¥pital', 'Verdun', 'Stade'].\nMais si on ajoute des poids, l\u0026rsquo;algorithme de recherche en largeur devient inefficace puisqu\u0026rsquo;il se borne √† donner la m√™me r√©ponse (les pond√©rations sont nul part prises en compte !).\n G_pond = {\u0026#34;Minimes\u0026#34; : {\u0026#34;Tasdon\u0026#34;:5,\u0026#34;H√¥pital\u0026#34;:4}, \u0026#34;H√¥pital\u0026#34; : {\u0026#34;Verdun\u0026#34;:21}, \u0026#34;Verdun\u0026#34; : {\u0026#34;Stade\u0026#34;:4}, \u0026#34;Tasdon\u0026#34; : {\u0026#34;Cognehors\u0026#34;:7, \u0026#34;Lafond\u0026#34;:7}, \u0026#34;Cognehors\u0026#34; : {\u0026#34;Verdun\u0026#34;:8}, \u0026#34;Lafond\u0026#34; : {\u0026#34;Mireuil\u0026#34;:5}, \u0026#34;Mireuil\u0026#34; : {\u0026#34;Stade\u0026#34;:3}, \u0026#34;Stade\u0026#34; : {} } recherche_largeur(G_pond,\u0026quot;Minimes\u0026quot;,\u0026quot;Stade\u0026quot;) retourne √† nouveau ['Minimes', 'H√¥pital', 'Verdun', 'Stade'] alors qu\u0026rsquo;il y a maintenant des chemins plus rapides !\n¬†Algorithme de Dijkstra # pr√©conditions : un graphe orient√© Ôøºpond√©r√© G(S,A) avec des poids positifs pour chaque arc repr√©sent√© par une liste d‚Äôadjacence gr√¢ce √† un dictionnaire, un sommet s_0 de S # postcondition : pour chaque sommet Ôøºs_i de S la distance trouv√©e correspond bien au chemin le plus court entre s_0 et s_i (d(s_0,s_i)) def sommet_suivant(scores,vus) : plus_bas_score = float(\u0026#34;inf\u0026#34;) sommet_choisi = None for sommet in scores : score = scores[sommet] if score \u0026lt; plus_bas_score and sommet not in vus : plus_bas_score = score sommet_choisi = sommet return sommet_choisi def Dijkstra(G,depart) : # on construit Scores et Preds dans lesquels on mettra √† jour les scores calcul√©s et les pr√©decesseurs des sommets examin√©s Scores = {} Preds = {} for s in G.keys() : Scores[s] = float(\u0026#34;inf\u0026#34;) Preds[s] = None Scores[depart] = 0 Vus = [] # liste des sommets examin√©s sommet = sommet_suivant(Scores,Vus) while sommet is not None : score = Scores[sommet] Succ = G[sommet] for n in Succ.keys(): nv_score = score + Succ[n] if Scores[n] \u0026gt; nv_score : Scores[n] = nv_score Preds[n] = sommet Vus.append(sommet) sommet = sommet_suivant(Scores,Vus) return Preds,Scores preds,scores = Dijkstra(G_pond,\u0026#34;Minimes\u0026#34;) print(preds) print(scores) # Ce qui s\u0026#39;affiche : {\u0026#39;Minimes\u0026#39;: None, \u0026#39;H√¥pital\u0026#39;: \u0026#39;Minimes\u0026#39;, \u0026#39;Verdun\u0026#39;: \u0026#39;Cognehors\u0026#39;, \u0026#39;Tasdon\u0026#39;: \u0026#39;Minimes\u0026#39;, \u0026#39;Cognehors\u0026#39;: \u0026#39;Tasdon\u0026#39;, \u0026#39;Lafond\u0026#39;: \u0026#39;Tasdon\u0026#39;, \u0026#39;Mireuil\u0026#39;: \u0026#39;Lafond\u0026#39;, \u0026#39;Stade\u0026#39;: \u0026#39;Mireuil\u0026#39;} {\u0026#39;Minimes\u0026#39;: 0, \u0026#39;H√¥pital\u0026#39;: 4, \u0026#39;Verdun\u0026#39;: 20, \u0026#39;Tasdon\u0026#39;: 5, \u0026#39;Cognehors\u0026#39;: 12, \u0026#39;Lafond\u0026#39;: 12, \u0026#39;Mireuil\u0026#39;: 17, \u0026#39;Stade\u0026#39;: 20}    "
},
{
	"uri": "http://example.org/python/typesstruct/",
	"title": "Types structur√©s",
	"tags": [],
	"description": "",
	"content": "Types structur√©s Les types structur√©s (cha√Ænes, tuiles, listes, dictionnaires, ensembles) sont des objets compos√©s ; ils contiennent eux-m√™mes d\u0026rsquo;autres objets.\n¬†Structures indic√©es immuables (cha√Ænes, tuples) On peut parcourir les √©l√©ments pr√©sents dans une structure indic√©e √† l\u0026rsquo;aide d\u0026rsquo;un indice (un nombre entier √©tiquetant l\u0026rsquo;indice). Les structures indic√©s sont donc ordonn√©es, ce sont des s√©quences. L\u0026rsquo;indice commence toujours √† 0.\nEt donc si la structure contient n √©l√©ments, le dernier indice est n-1.\n Une structure est dite immuable si on ne peut pas modifier les √©l√©ments qu\u0026rsquo;elle contient une fois qu\u0026rsquo;elle est construite.\nIl y a deux structures de ce type en Python : les cha√Ænes de caract√®res (type string) et les tuples (type tuple).\n  Les cha√Ænes de caract√®res sont des s√©quences de caract√®res d√©finies par des apostrophes ', des guillemets \u0026quot;, des triples apostrophes ''' ou des triples guillemets \u0026quot;\u0026quot;\u0026quot; ('abc', \u0026quot;abc\u0026quot;,'''abc''',\u0026quot;\u0026quot;\u0026quot;abc\u0026quot;\u0026quot;\u0026quot; ).\nLes guillemets permettent d\u0026rsquo;utiliser des apostrophes dans la cha√Æne sans que cela ne la ferme (\u0026quot;C'est bon\u0026quot;).\nLes triples apostrophes ou guillemets permettent d\u0026rsquo;√©crire des cha√Ænes sur plusieurs lignes (on utilise de telles cha√Ænes pour les signatures des fonctions).\nLes cha√Ænes de caract√®res peuvent √™tre constitu√©s de tous les caract√®res possibles. L\u0026rsquo;espace est un caract√®re comme un autre¬†!\n  Les tuples sont des ensembles d\u0026rsquo;objets (pas forc√©ment du m√™me type) plac√©s entre parenth√®ses et s√©par√©s par des virgules comme (3.2, 'abc', True).\n  ¬†len La fonction native len() permet d\u0026rsquo;obtenir le nombre d\u0026rsquo;√©l√©ments pr√©sents dans la structure. Il s\u0026rsquo;agit de sa longueur (len est l'\u0026lsquo;abr√©viation de length).\nlen(\u0026#39;abc\u0026#39;) 3\nlen((3.2, \u0026#39;abc\u0026#39;, True)) 3\nM√™me si le deuxi√®me √©l√©ment du tuple du dernier exemple est lui-m√™me compos√©, len le consid√®re comme un (et un seul) des √©l√©ments du tuple.\nDe m√™me, si un tuple contient un autre tuple, il ne sera qu\u0026rsquo;un seul √©l√©ment pour len :\nlen((\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,(1,2,3),18)) 4 Acc√®s par indice On place l\u0026rsquo;indice de l\u0026rsquo;√©l√©ment qui nous int√©resse entre crochet pour le r√©cup√©rer :\nS = 'abcdefghijklmnopqrstuvwxyz' n = len(S) print('de',S[0],'√†',S[n-1]) de a √† z\ns[n] provoque l\u0026rsquo;erreur classique IndexError: string index out of range.\nSi n est le nombre d\u0026rsquo;√©l√©ments de la structure, alors l\u0026rsquo;indice doit √™tre un entier inf√©rieur ou √©gal √† n-1.\n Si une structure indic√©e se trouve enchass√©e au sein d\u0026rsquo;une autre structure indic√©e, on peut aussi acc√©der √† ses √©l√©ments :\nT = (1,\u0026#39;abcd\u0026#39;,2) print(len(T[1]))  Qu\u0026rsquo;est-ce qui s\u0026rsquo;affiche ?\n print(T[1][3])  Et l√† ?\n Autre source d\u0026rsquo;erreur : on ne peut pas modifier la valeur d\u0026rsquo;un √©l√©ment dans une structure immuable.\n T = (1,2,3) T[2] = 4 TypeError: 'tuple' object does not support item assignment\n\u0026#39;abc\u0026#39;[1] = \u0026#39;d\u0026#39; TypeError: 'str' object does not support item assignment\n¬†Concat√©nation + L\u0026rsquo;op√©rateur + permet de concat√©ner deux structures du m√™me type.\n\u0026#39;abc\u0026#39;+\u0026#39;de\u0026#39; 'abcde'\n(1,\u0026#39;b\u0026#39;,2.2) + (True,1/5) (1, 'b', 2.2, True, 0.2)\nLa longueur de la structure r√©sultante vaut la somme des longueurs des deux tructures concat√©n√©es.\n¬†R√©p√©tition * L\u0026rsquo;op√©rateur * permet de r√©p√©ter une structure.\n\u0026#39;abc\u0026#39;*2 abcabc\nOn peut combiner * et + :\n(\u0026#39;z\u0026#39;*5 + \u0026#39; \u0026#39;)*3 ¬†Tranches On peut extraire plusieurs √©l√©ments d\u0026rsquo;une structure indic√©e en une seule fois gr√¢ce au d√©coupage en tranches (slicing en anglais). On utilise les crochets comme pour l\u0026rsquo;indexation mais on utilise maintenant 2 ou 3 indices s√©par√©s par :. La tranche va du premier indice (inclu) jusqu\u0026rsquo;au deuxi√®me indice (exclu).\nS = \u0026#39;0123456789\u0026#39; S[1:4] '123'\nCette r√®gle d\u0026rsquo;exclusion du deuxi√®me indice permet d\u0026rsquo;avoir une √©paisseur de tranche (len(S[i:j])) valant la diff√©rence entre les deux indices (j-i).\nSi on omet le premier indice ([:j]), on part du d√©but. Si on omet le second ([i:]), on va jusqu\u0026rsquo;au bout.\nS[:4],S[5:] ('0123', '56789')\nUn troisi√®me indice installe un pas dans la d√©coupe :\nS[::2],S[1::4] ('02468', '159')\nEt si le troisi√®me indice est n√©gatif, il permet de parcourir la s√©quence en sens inverse :\nS[::-1],S[8:0:-2] ('9876543210', '8642')\n¬†Listes Une liste (type list) est une collection d\u0026rsquo;objets plac√©s entre crochets et s√©par√©s par des virgules.\nExemple : L = [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8]\nComme avec les cha√Ænes de caract√®res et les tuples :\n on acc√®de √† un √©l√©ment via son indice :\nL[3] renvoie 0.3. on obtient le nombre d\u0026rsquo;√©l√©ments d\u0026rsquo;une liste gr√¢ce √† la fonction len :\nlen(L) retourne 9 ; on peut concat√©ner deux listes avec +:\n[5,6]+[7,8] donne [5,6,7,8]; on peut extraire par tranche des √©l√©ments :\nL[1:6] donne [0.1,0.2,0.3,0.4,0.5].\\ on peut tester lapr√©sence d\u0026rsquo;un √©l√©ment gr√¢ce √† in :\n0.1 in L revoie True et 1 in L renvoie False.  Mais contrairement aux cha√Ænes de caract√®res et aux tuples, les listes ne sont pas immuables. On peut donc r√©affecter des √©l√©ments.\nEn reprenant la liste L pr√©c√©dente, si on √©crit L[2] = 'a', L devient [0.0,0.1,'a',0.3,0.4,0.5,0.6,0.7,0.8].\nCr√©ation d\u0026rsquo;une liste par duplication : L\u0026rsquo;op√©rateur * permet de cr√©er une liste r√©p√©tant un √©l√©ment.\nPar exemple, pour cr√©er une liste de 10 z√©ros, il suffit d\u0026rsquo;√©crire [0]*10.\npar append successifs : On initialise une liste vide ([]), puis on la garnit √©l√©ment par √©l√©ment gr√¢ce √† la m√©thode append.\nExemple :\nL = [] for i in range(10) : L.append(i/10) print(L) [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8]\npar compr√©hension La construction par compr√©hension d\u0026rsquo;une liste est une m√©thode concise et √©l√©gante. L\u0026rsquo;id√©e est d\u0026rsquo;int√©grer les boucles et enventuelles conditions dans une seule expression entre crochets pour aboutir √† une d√©finition plus directe de la liste.\nExemples :\nL1 = [i/10 for i in range(9)] L2 = [k**2 if (k%2==0) else k**3 for k in range(9)] print(\u0026#34;L1 =\u0026#34;,L1) print(\u0026#34;L2 =\u0026#34;,L2) L1 = [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8]\nL2 = [0, 1, 4, 27, 16, 125, 36, 343, 64]\n¬†Copie d\u0026rsquo;une liste Si on copie une liste en l\u0026rsquo;affectant √† un nouveau nom, alors toute modification de l\u0026rsquo;ancienne liste se r√©percutera sur la nouvelle (et inversement). Les deux noms pointent en r√©alit√© vers le m√™me espace m√©moire. En effet, lorsqu\u0026rsquo;on affecte une liste √† un nom de variable via =, ce n\u0026rsquo;est pas la liste mais sa r√©f√©rence (son adresse m√©moire) qui est assign√©e √† la variable. Et donc lorsqu\u0026rsquo;on affecte la liste √† une nouvelle variable, c\u0026rsquo;est une copie de la r√©f√©rence et non des valeurs qui est faite.\nL_originelle = [\u0026#39;üçì\u0026#39;, \u0026#39;üçá\u0026#39;, \u0026#39;üçä\u0026#39;] L_copie = L_originelle L_originelle[1] = \u0026#39;?\u0026#39; print(L_originelle,L_copie) ['üçì', '?', 'üçä'] ['üçì', '?', 'üçä']\nAucune diff√©rence !\nSi on veut que la liste copi√©e conserve ses √©l√©ments tels qu\u0026rsquo;ils √©taient au moment de la copie, on peut soit utiliser une \u0026ldquo;copie par tranche\u0026rdquo;, en affectant une tranche compl√®te (avec [:]) de la liste, soit utiliser la m√©thode copy(), soit utiliser la fonction list.\nL_originelle = [\u0026#39;üçì\u0026#39;, \u0026#39;üçá\u0026#39;, \u0026#39;üçä\u0026#39;] L_copie_1 = L_originelle[:] L_copie_2 = L_originelle.copy() L_copie_3 = list(L_originelle) L_originelle[1] = \u0026#39;?\u0026#39; print(L_originelle,L_copie_1,L_copie_2,L_copie_3) ['üçì', '?', 'üçä'] ['üçì', 'üçá', 'üçä'] ['üçì', 'üçá', 'üçä'] ['üçì', 'üçá', 'üçä']\n'?' ne se retrouve pas dans les copies !\nMais ces deux copies n\u0026rsquo;en restent pas moins superficielles. En effet, si la liste originelle contient des √©l√©ments mutables (comme une autre liste), alors seule l\u0026rsquo;adresse de ceux-ci est copi√©e, et s\u0026rsquo;ils sont modifi√©s, la copie aussi le sera :\nL = [\u0026#39;üçã\u0026#39;,\u0026#39;üçë\u0026#39;,[\u0026#39;üçà\u0026#39;,\u0026#39;üçí\u0026#39;],\u0026#39;üçè\u0026#39;] L_copie = L[:] L.append(\u0026#39;ü••\u0026#39;) L[2].append(\u0026#39;üçå\u0026#39;) print(L_copie) ['üçã', 'üçë', ['üçà', 'üçí', 'üçå'], 'üçè']\n'ü••' ne se retrouve pas dans la copie, mais üçå y est bien\u0026hellip;\n¬†Retirer un √©l√©ment avec pop La m√©thode pop(i) permet de retirer l\u0026rsquo;√©l√©ment d\u0026rsquo;indice i d\u0026rsquo;une liste. Si on omet l\u0026rsquo;argument (pop()), c\u0026rsquo;est le dernier √©l√©ment qui est retir√©.\nL = [\u0026#39;ü••\u0026#39;, \u0026#39;üçê\u0026#39;, \u0026#39;üçã\u0026#39;, \u0026#39;üçí\u0026#39;] print(L.pop(2)) print(L) üçã\n['ü••', 'üçê', 'üçí']\npop retourne l\u0026rsquo;√©l√©ment retir√©. Ainsi print(L.pop()) affiche 4.\n¬†Dictionnaires Un dictionnaire (type dict) est une collection d\u0026rsquo;objets, comme une liste ou un tuple, mais au lieu d\u0026rsquo;indicer les objets s\u0026rsquo;y trouvant (appel√©s valeurs) par un nombre, on utilise une cl√©.\nLes dictionnaires sont l\u0026rsquo;impl√©mentation en Python des tables de hachage.\n Une cl√© peut √™tre n\u0026rsquo;importe quel objet immuable, mais il s\u0026rsquo;agit le plus souvent d\u0026rsquo;une cha√Æne de caract√®res.\nPour cr√©er un dictionnaire, on utilise la syntaxe {cl√©1 : valeur1, cl√©2 : valeur2, \u0026hellip;}.\nExemple o√π les cl√©s sont des pr√©noms et les valeurs, des notes :\nnote = {\u0026#39;Giselle\u0026#39; : 7.5, \u0026#39;Alphonse\u0026#39; : 12, \u0026#39;Dudule\u0026#39; : 7.5, \u0026#39;Berthe\u0026#39; : 16.5} Chaque valeur peut √™tre r√©cup√©r√©e gr√¢ce √† la cl√©, comme s\u0026rsquo;il s\u0026rsquo;agisait d\u0026rsquo;un indice : note['Dudule'] donne 7.5 et\nOn peut ajouter une entr√©e au dictionnaire de la m√™me fa√ßon : note['Raoul'] = 14 transforme note en {'Giselle': 7.5, 'Alphonse': 12, 'Dudule': 7.5, 'Berthe': 16.5, 'Raoul': 14} On peut ainsi partir d\u0026rsquo;un dictionnaire vide {} et le construire √©tape par √©tape :\ncoef = {} coef[\u0026#39;maths\u0026#39;] = 9 coef[\u0026#39;physique\u0026#39;] = 10 coef[\u0026#39;philo\u0026#39;] = 9 print(coef) {'maths': 9, 'physique': 10, 'philo': 9}\nComme les listes, les dictionnaires sont des objets mutables. note['Berthe'] = 18 modifie bien la note de Berthe dans le dictionnaire note.\nChaque cl√© doit √™tre unique, mais les valeurs peuvent √™tre identiques (comme les notes de Dudule et Giselle).\n Tenter d\u0026rsquo;acc√©der √† une cl√© qui ne figure pas dans le dictionnaire se solde par une erreur. Pour y √©chapper, on peut tester la pr√©sence d\u0026rsquo;une cl√© gr√¢ce au mot-cl√© in.\nExemple : fabriquons une liste de 12 √©l√©ments pris au hasard parmi les entiers de 1 √† 10 et mettons au point une m√©thode pour compter les occurrences de chacun des 10 entiers¬†:\nfrom random import randint L = [] for i in range(12) : L += [randint(1,10)] effectifs = dict() for e in L : if not e in effectifs : effectifs[e] = 1 else : effectifs[e] = effectifs[e] + 1 print(effectifs) {5: 3, 10: 1, 9: 1, 4: 1, 8: 1, 6: 2, 1: 3}\nSans la condition,effectifs[e]+1 aurait lev√© une KeyError car le dictionnaire n\u0026rsquo;a initialement aucune entr√©e et donc effectifs[e] n\u0026rsquo;est pas d√©fini.\nLes m√©thodes keys et values permettents de r√©cup√©rer les cl√©s et valeurs d\u0026rsquo;un dictionnaire sous forme d\u0026rsquo;it√©rables, ce qui peut s\u0026rsquo;av√©rer pratique pour un tracer, par exemple.\nimport matplotlib.pyplot as plt cl√©s = effectifs.keys() valeurs = effectifs.values() plt.bar(cl√©s, valeurs) plt.show() La m√©thode items regroupe cl√©s et valeurs au sein de tuples (cl√©,valeur).\nfor cl√©, valeur in effectifs.items() : print(\u0026#39;nombre de\u0026#39;,cl√©,\u0026#39;:\u0026#39;,valeur) nombre de 5 : 3\nnombre de 10 : 1\nnombre de 9 : 1\nnombre de 4 : 1\nnombre de 8 : 1\nnombre de 6 : 2\nnombre de 1 : 3\nLes dictionnaires sont des ensemble de paires cl√©-valeur qui n\u0026rsquo;ont aucun ordre particulier. Les dictionnaires ne sont donc pas des s√©quences.\n Comme pour les listes, une affectation d\u0026rsquo;un dictionnaire existant √† une nouvelle variable n\u0026rsquo;en copie que la r√©f√©rence. Toute modification de l\u0026rsquo;un se retrouve dans l\u0026rsquo;autre.\nEt comme pour les listes, si on veut conserver invariante les valeurs copi√©es, on peut utiliser la m√©thode copy().\ninfos = {\u0026#39;pr√©nom\u0026#39;: \u0026#39;Russell\u0026#39;, \u0026#39;nom\u0026#39;: \u0026#39;Bell\u0026#39;, \u0026#39;alias\u0026#39;: \u0026#39;Stringer\u0026#39;, \u0026#39;notes\u0026#39;: [13,18,7]} infos_copie = infos.copy() infos[\u0026#39;pr√©nom\u0026#39;] = infos.pop(\u0026#39;alias\u0026#39;) infos[\u0026#39;notes\u0026#39;][:] = [\u0026#39;abs\u0026#39;] print(infos,infos_copie) {'pr√©nom': 'Stringer', 'nom': 'Bell', 'notes': ['abs']} {'pr√©nom': 'Russell', 'nom': 'Bell', 'alias': 'Stringer', 'notes': ['abs']}\nOn remarque que le remplacement du pr√©nom par l\u0026rsquo;alias et la suppression de l\u0026rsquo;alias n\u0026rsquo;ont pas √©t√© r√©percut√©s sur la copie, par contre la modification de la liste de notes, objets mutable, oui.\n"
},
{
	"uri": "http://example.org/semestre_2/",
	"title": "Semestre 2",
	"tags": [],
	"description": "",
	"content": "Semestre 2 "
},
{
	"uri": "http://example.org/python/structcontr/",
	"title": "Strucutres de contr√¥le",
	"tags": [],
	"description": "",
	"content": "Structures de contr√¥le Instruction d\u0026rsquo;affectation D√©finition Lorsqu\u0026rsquo;un objet est cr√©√© dans un programme Python, une certaine place en m√©moire lui est allou√©e. Cette place est rep√©r√©e par une adresse dont la valeur peut √™tre obtenue gr√¢ce √† la fonction id().\nid(3.7) 4387417928\nIl est beaucoup plus pratique de pouvoir r√©cup√©rer une valeur en m√©moire gr√¢ce √† un petit nom plut√¥t que par son adresse. C\u0026rsquo;est √† √ßa que servent les variables. Une variable est li√©e √† un objet gr√¢ce √† une affectation et identifie cet objet pour les calculs suivants. Une affectation est une instruction (pas de retour).\nEn Python, une affectation s\u0026rsquo;op√®re avec le symbole =.\nLa variable est un tiroir avec une √©tiquette. Et comme on l\u0026rsquo;a vu, en Python, pas besoin de choisir un tiroir correspondant au type d\u0026rsquo;objet qu\u0026rsquo;il va contenir, c\u0026rsquo;est l\u0026rsquo;interpr√©teur qui s\u0026rsquo;en charge pour nous (le typage est dynamique).\na = 3 b = -2 a * b -6\nSi on veut pouvoir utiliser le r√©sultat de a * b pour des calculs ult√©rieurs, il faut lui aussi le stocker en m√©moire.\nc = a * b c -6\nOn peut interroger le type d\u0026rsquo;une variable avec la fonction type() :\nc = 3,2 type(c) \u0026lt;class 'tuple'\u0026gt;\n¬†Instruction plut√¥t qu\u0026rsquo;expression Le fait que l\u0026rsquo;affectation soir une instruction plut√¥t qu\u0026rsquo;une expression est un choix d\u0026rsquo;√©criture du langage (en C, l\u0026rsquo;affectation est une expression).\nD\u0026rsquo;ailleurs, Python 3.8 a introduit l\u0026rsquo;op√©rateur := (dit le walrus op√©rator ou op√©rateur de morse du fait de sa ressemblance √† un morse\u0026hellip;) permettant justement une expression d\u0026rsquo;affectation au sein d\u0026rsquo;une expression plus large. L\u0026rsquo;int√©r√™t est de permettre de raccourcir l\u0026rsquo;√©criture ou d\u0026rsquo;√©viter les r√©p√©titions dans certains cas.\nL\u0026rsquo;op√©rateur de morse n\u0026rsquo;est pas √† conna√Ætre, mais il va nous permettre, dans les deux exemples suivants, de bien faire la diff√©rence entre une instruction et une expression.\nif (n := len(a)) \u0026gt; 5: print(f\u0026#34;La liste est trop grande ({n} √©lements alors qu\u0026#39;on en attend 5 au plus)\u0026#34;)  Montrer que sans :=, on avait soit une r√©p√©tition, soit une ligne en plus.\n Autre exemple :\nwhile (choix := input(\u0026#39;Entrer q ou p : \u0026#39;)) != \u0026#39;q\u0026#39;: if choix == \u0026#39;p\u0026#39;: print(\u0026#34;Salut !\u0026#34;)  Comment aurait-on d√ª √©crire ce code sans := ?\n ¬†R√©affectation Une affectation ne retourne rien mais a un effet sur la m√©moire : l\u0026rsquo;adresse de la variable est modifi√©e √† chaque nouvelle affectation. C\u0026rsquo;est ce qui rend possible les r√©affectations √† partir de la variable elle-m√™me.\nid(a) 4304751488\nid(a+1) 4304751520\na = a + 1 id(a) 4304751520\nCes types de r√©affectation sont si fr√©quents qu\u0026rsquo;il existe une notation raccourcie : +=, -=, *=, /=, //=, %=.\nAinsi, a += 1 √©quivaut √† a = a + 1 et b /= 5 √©quivaut √† b = b/5.\n ¬†Affectation parall√®le Comment faire si on veut permuter les valeurs auxquelles sont li√©es deux variables ? D√®s qu\u0026rsquo;on √©crit a = b, la valeur initiale de a est perdue. Et si on commence par b = a, c\u0026rsquo;est la valeur initiale de b qui est perdue. Il faudrait donc utiliser une variable temporaire et √©crire : tmp = a, a = b et b = tmp.\nMais l\u0026rsquo;affectation parall√®le de Python va nous permettre d\u0026rsquo;√™tre plus √©l√©gants. Il suffit en effet d\u0026rsquo;une petite ligne :\na = \u0026#39;haut\u0026#39; b = \u0026#39;bas\u0026#39; a , b = b , a print(a,b) bas haut\nL\u0026rsquo;affectation parall√®le repose sur le d√©paquetage (unpacking) de tuples. En effet, des objets s√©par√©s par des virgules forment un tuple (pas besoin de parenth√®ses). Donc a,b,c = 1,2,3 correspond au d√©paquetage du tuple (1,2,3) sur les 3 variables a, b et c.\n¬†Noms de variable R√®gles sur les noms de variables :\n ils sont sensibles √† la casse (minuscule ou majuscule) ils peuvent contenir n\u0026rsquo;importe quelles lettres ou chiffres et le tiret-bas \u0026ldquo;_\u0026rdquo; mais ne doivent pas commencer par un chiffre. certains noms sont interdits (attention en particulier √† lambda) :  and assert break class continue def del elif else except finally for from global if import in is lambda nonlocal not or pass print raise return try while yield\nIl est important pour la lisibilit√© de son code de donner les noms les plus explicites possibles aux variables. Les rapports de jury le r√©p√®te tous les ans\u0026hellip;\n Rapport 2019 de l\u0026rsquo;√©preuve de Centrale par exemple :\n Des noms de variables explicites aident √† la compr√©hension du code. De trop nombreux candidats utilisent des noms de variables quelconques (a, b, c\u0026hellip;) ce qui nuit √† la compr√©hension du programme. La clart√© du programme (en particulier le choix des noms de variables) ainsi que la pr√©sence de commentaires opportuns sont prises en compte dans l‚Äô√©valuation.\n ¬†Instuction conditionnelle Les instructions conditionnelles permettent de rediriger le flot d\u0026rsquo;ex√©cution d\u0026rsquo;un programme en proposant des alternatives.\nif,elif,else La structure if ... elif ... else permet d\u0026rsquo;ex√©cuter des instructions seulement si une condition, donn√©e par le r√©sultat d\u0026rsquo;un ou plusieurs tests logiques, est v√©rifi√©e.\nif \u0026lt;expression logique 1\u0026gt; :\n\u0026lt;bloc d\u0026rsquo;instructions 1\u0026gt;\nelif \u0026lt;expression logique 2\u0026gt; :\n\u0026lt;bloc d\u0026rsquo;instructions 2\u0026gt;\n\u0026hellip;\nelse :\n\u0026lt;bloc d\u0026rsquo;instructions\u0026gt;\nSi l'\u0026lt;expression¬†logique¬†1\u0026gt; est √©valu√©e comme vraie, le \u0026lt;bloc¬†d\u0026rsquo;instructions¬†1\u0026gt; est ex√©cut√© ; dans le cas contraire, si l'\u0026lt;expression logique¬†2\u0026gt; est √©valu√©e comme vraie, le \u0026lt;bloc¬†d\u0026rsquo;instructions¬†2\u0026gt; est ex√©cut√©, et ainsi de suite¬†; et si aucune des expressions logiques pr√©c√©dentes n\u0026rsquo;est vraie, le bloc d\u0026rsquo;instructions faisant suite au else: est ex√©cut√©.\nPar exemple :\nfor x in range(10) : if x\u0026lt;= 3 : print(x,\u0026#39;est inf√©rieur ou √©gal √† 3\u0026#39;) elif x \u0026gt; 5 : print(x,\u0026#39;est plus grand que 5\u0026#39;) else : print(x,\u0026#39;doit √™tre 4 ou 5\u0026#39;) 0 est inf√©rieur ou √©gal √† 3 1 est inf√©rieur ou √©gal √† 3 2 est inf√©rieur ou √©gal √† 3 3 est inf√©rieur ou √©gal √† 3 4 doit √™tre 4 ou 5 5 doit √™tre 4 ou 5 6 est plus grand que 5 7 est plus grand que 5 8 est plus grand que 5 9 est plus grand que 5  Python reconna√Æt comme vrai n\u0026rsquo;importe quel type de donn√©e (m√™me pas besoin d\u0026rsquo;expression logique) du moment qu\u0026rsquo;il ne s\u0026rsquo;agit ni de l\u0026rsquo;entier 0, du d√©cimal 0., de la cha√Æne de caract√®res vide '', du tuple vide (), de la liste vide [], ou encore de la valeur None.\n Exemple :\nDans le calendrier gr√©gorien, une ann√©e est bissextile si elle est divisible par 4 sauf si elle est aussi divisible par 100 √† part les ann√©es divisibles par 400 qui sont bien bissextiles.\nLe programme suivant d√©termine si une ann√©e est bissextile :\nann√©e = 2022 if not ann√©e % 400 : est_bissextile = True elif not ann√©e % 100 : est_bissextile = False elif not ann√©e % 4 : est_bissextile = True else : est_bissextile = False s = \u0026#39;est une\u0026#39; if est_bissextile else \u0026#34;n\u0026#39;est pas une\u0026#34; print(\u0026#34;L\u0026#39;ann√©e\u0026#34;, ann√©e , s ,\u0026#34;ann√©e bissextile.\u0026#34;) L'ann√©e 2022 n'est pas une ann√©e bissextile.\n¬†¬†Boucle while Une boucle while ou \u0026ldquo;tant que\u0026rdquo; permet de r√©p√©ter une suite d\u0026rsquo;instructions tant qu' une condition est respect√©e.\nLa suite d\u0026rsquo;instructions r√©p√©ter devra √™tre indent√©e et forme alors le corps de la boucle.\nLes boucles while sont dangereuses ! Rien ne dit en effet que la condition sera un jour fausse et la boucle peut donc tourner ind√©finiment.\nLes boucles infinis posent le probl√®me de la terminaison d\u0026rsquo;un programme.\n i = 0 while i \u0026lt; 10 : i += 1 print(i,end =\u0026#39;.\u0026#39;) print(\u0026#39;\\nLa boucle est finie...\u0026#39;) 1.2.3.4.5.6.7.8.9.10. La boucle est finie...  Le compteur i est initialis√© √† 0 et comme 0 est inf√©rieur √† 10, la boucle while d√©marre. √Ä chaque it√©ration, i est incr√©ment√© de 1 et sa valeur affich√©e. Puis i atteint 10 et √† l\u0026rsquo;it√©ration suivante i \u0026lt; 10 devient faux, la boucle s\u0026rsquo;arr√™te et l\u0026rsquo;√©x√©cution reprend apr√®s la boucle.\nUn exemple plus int√©ressant :\nimpl√©mentons l\u0026rsquo;algorithme d\u0026rsquo;Euclide permettant de d√©terminer le plus grand diviseur commun de deux entiers.\na , b = 1920 , 1080 print(\u0026#39;pgcd({},{}) = \u0026#39;.format(a,b),end = \u0026#39;\u0026#39;) while b : a , b = b, a % b print(a) pgcd(1920,1080) = 120\nLa boucle continue jusqu\u0026rsquo;√† ce que b divise a. √Ä chaque it√©ration, b prend la valeur du reste de la division euclidienne de a par b et a prend l\u0026rsquo;ancienne valeur de b.\nwhile b est √©quivalent √† while b != 0 puisque la valeur 0 est √©valu√©e comme fausse.\n¬†break L\u0026rsquo;instruction break, plac√©e dans le bloc d\u0026rsquo;instructions d\u0026rsquo;une boucle, met imm√©diatement fin √† cette boucle lorsqu\u0026rsquo;arrive son tour d\u0026rsquo;√™tre ex√©cut√©e.\nL\u0026rsquo;ex√©cution reprend √† l\u0026rsquo;instruction suivant la boucle.\nx = 0 while True : x += 1 if not (x % 15 or x % 25) : break print(x,\u0026#39;est divisible √† la fois par 15 et 25.\u0026#39;) 75 est divisible √† la fois par 15 et 25.\nLa condition du while est ici litt√©ralement toujours vraie donc la seule sortie possible de la boucle passe par une ex√©cution de l\u0026rsquo;instruction break, ce qui ne peut arriver que si x est √† la fois divisible par 15 et 25.\nDe la m√™me mani√®re, pour trouver l\u0026rsquo;indice de la premi√®re occurrence d\u0026rsquo;un nombre n√©gatif dans une liste :\nliste = [5, 2, 99, 0, 100, -2, 37, 43, -124] for i, a in enumerate(liste) : if a \u0026lt; 0 : break print(\u0026#34;L\u0026#39;√©l√©ment d\u0026#39;indice\u0026#34;,i,\u0026#34;valant\u0026#34;,a,\u0026#34;est le premier √©l√©ment n√©gatif.\u0026#34;) L'√©l√©ment d'indice 5 valant -2 est le premier √©l√©ment n√©gatif.\nApr√®s la sortie de la boucle, les variables i et a gardent les valeurs qu\u0026rsquo;elles ont au moment de l\u0026rsquo;instruction break.\n ¬†return L\u0026rsquo;instruction return permet elle aussi de s\u0026rsquo;√©chapper d\u0026rsquo;une boucle.\nEn effet, l\u0026rsquo;utilisation du return a pour effet de sortir du corps d\u0026rsquo;une fonction donc √† fortiori, si une boucle est utilis√©e dans la d√©finition de cette fonction, le return permet aussi d\u0026rsquo;en sortir.\ndef vol(i) : t = 0 while(1) : if not i%2 : i //= 2 t += 1 elif i != 1 : i = 3*i+1 t += 1 else : return t vol(27) 111\n¬†¬†Boucle for Une boucle for se diff√©rencie d\u0026rsquo;une boucle while en ce que le nombre d\u0026rsquo;it√©rations est connu √† l\u0026rsquo;avance.\nLa structure d\u0026rsquo;une telle boucle est en effet :\nfor \u0026lt;√©l√©ment\u0026gt; in \u0026lt;it√©rable\u0026gt; :\n\u0026lt;bloc d\u0026rsquo;instructions\u0026gt;\nL\u0026rsquo;it√©rable est une collection d\u0026rsquo;√©l√©ments et le bloc d\u0026rsquo;instructions est alors r√©p√©t√© autant de fois que l\u0026rsquo;it√©rable contient d\u0026rsquo;√©l√©ments.\nPassons en revue quelques it√©rables.\nrange range permet d\u0026rsquo;it√©rer sur une suite arithm√©tique d\u0026rsquo;entiers :\nfor i in range(5) : print(i,end=\u0026#34;.\u0026#34;) 0.1.2.3.4.\nL\u0026rsquo;it√©ration sur range(n) va de 0 √† n-1 par pas de 1.\nOn peut sp√©cifier un point de d√©part et un pas diff√©rents en les passant en argument : range(depart,fin,pas).\nfor i in range(5,10) : print(i,end=\u0026#34;.\u0026#34;) 5.6.7.8.9.\nfor i in range(0,100,20) : print(i,end=\u0026#34;.\u0026#34;) 0.20.40.60.80.\n¬†une cha√Æne de caract√®res It√©rer sur une cha√Æne de caract√®res d√©compose la cha√Æne caract√®re par caract√®re :\nfor car in \u0026#39;abcüò±\u0026#39; : print(car*2,end=\u0026#39; \u0026#39;) aa bb cc üò±üò± \n¬†une liste, un tuple On peut de m√™me parcourir une liste ou un tuple √©l√©ment par √©l√©ment.\nL = [(\u0026#39;üôà\u0026#39;,\u0026#39;üôä\u0026#39;,\u0026#39;üôâ\u0026#39;),(\u0026#39;üåñ\u0026#39;,\u0026#39;üåó\u0026#39;,\u0026#39;üåò\u0026#39;),] s = \u0026#39;\u0026#39; i = 1 for tuple in L : for element in tuple : s += element*i i += 1 print(s) üôàüôäüôäüôâüôâüôâüåñüåñüåñüåñüåóüåóüåóüåóüåóüåòüåòüåòüåòüåòüåò\n¬†un dictionnaire Pour pacourir uniquement les cl√©s d\u0026rsquo;un dictionnaire, on peut utiliser la m√©thode keys :\nDico = {\u0026#39;pwd_1\u0026#39; : \u0026#39;123456\u0026#39;, \u0026#39;pwd_2\u0026#39; : \u0026#39;qwerty\u0026#39;, \u0026#39;pwd_3\u0026#39; : \u0026#39;password\u0026#39;} for cle in Dico.keys() : print(cle,\u0026#39;-\u0026gt;\u0026#39;,Dico[cle]) pwd_1 -\u0026gt; 123456\npwd_2 -\u0026gt; qwerty\npwd_3 -\u0026gt; password\nEt gr√¢ce √† la m√©thode items, on peut d√©baller cl√©s et valeurs associ√©es dans un tuple :\nfor cle,valeur in Dico.items() : print(cle,\u0026#39;-\u0026gt;\u0026#39;,valeur) pwd_1 -\u0026gt; 123456\npwd_2 -\u0026gt; qwerty\npwd_3 -\u0026gt; password\nConstruisons par exemple un nouveau dictionnaire inversant cl√©s et valeurs :\nDico = {\u0026#39;$\u0026#39; : \u0026#39;dollar\u0026#39;, \u0026#39;‚Ç¨\u0026#39; : \u0026#39;euro\u0026#39;, \u0026#39;¬•\u0026#39; : \u0026#39;yen\u0026#39;, \u0026#39;¬£\u0026#39; : \u0026#39;livre\u0026#39;} Dico_inv = {} for cle,valeur in Dico.items() : Dico_inv[valeur] = cle print(Dico_inv) {'dollar': '$', 'euro': '‚Ç¨', 'yen': '¬•', 'livre': '¬£'}\nDernier exemple, modifions une √† une chaque valeur d\u0026rsquo;un dictionnaire :\ndico_notes = {\u0026#39;Kurt\u0026#39; : 19, \u0026#39;Kris\u0026#39; : 11, \u0026#39;Dave\u0026#39; : 13, \u0026#39;Pat\u0026#39; : 10, \u0026#39;Courtney\u0026#39; : 15} for eleve,note in dico_notes.items() : dico_notes[eleve] = note+1 print(dico_notes) {'Kurt': 20, 'Kris': 12, 'Dave': 14, 'Pat': 11, 'Courtney': 16} ¬†D√©finition d\u0026rsquo;une fonction Une fonction est un ensemble d\u0026rsquo;instructions auxquelles on acc√®de par un raccourci : le nom de la fonction. Elles se comportent comme des sous-programmes √† l\u0026rsquo;int√©rieur du programme principal. Et comme tout programme, elles peuvent agir sur des donn√©es, les entr√©es, et fournir de nouvelles donn√©es, les sorties.\nLa signature d\u0026rsquo;une fonction r√©sume ces points cl√©s : son nom, les diff√©rents arguments et leurs types, les diff√©rentes sorties et leur type. nom(arg_1:type, arg_2:type, etc) -\u0026gt; sortie_1:type, sortie_2:type, etc\nOn d√©finit une fonction gr√¢ce au mot cl√© def en suivant la structure suivante :\ndef nom(arguments s√©par√©s par des virgules) :\n\u0026lt;corps de la fonction contenant les diff√©rentes instructions\u0026gt;\nLa d√©finition d\u0026rsquo;une fonction est une instruction.\ndef addition(a,b) : c = a+b print(c) On appelle une fonction en utilisant son nom et en affectant chaque argument dans les parenth√®ses qui suivent son nom.\nLes instructions du corps de la fonction sont alors ex√©cut√©e une par une et si des variables correspondant aux nom des arguments (on parle alors d'arguments formels) sont rencontr√©es, ce sont les valeurs utilis√©es lors de l\u0026rsquo;appel (les arguments effectifs) qui les remplacent.\naddition(5,2) 7 Malgr√© ce que l\u0026rsquo;affichage peut laisser croire, la fonction pr√©c√©dente ne retourne rien !\nLa valeur de c est prisonni√®re du corps de la fonction, elle n\u0026rsquo;est pas accessible dans le code principal. C\u0026rsquo;est une variable locale.\nSi on veut pouvoir acc√©der √† c ailleurs que dans la fonction, il faut l\u0026rsquo;extirper en utilisant un return.\nIl ne faut ainsi pas confondre print et return !\nLe return transforme l\u0026rsquo;appel de la fonction en expression puisqu\u0026rsquo;une valeur est retourn√©e.\nLe print n\u0026rsquo;a qu\u0026rsquo;un effet de bord. La valeur est affich√©e mais inutilisable. L\u0026rsquo;appel de la fonction n\u0026rsquo;est alors qu\u0026rsquo;une instruction et on nomme proc√©dure une telle fonction.\n Ainsi, addition(5,2) + 7 va lever une erreur : TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'.\nEn effet, comme addition ne retourne rien, Python la consid√®re de type NoneType et ne comprend pas pourquoi on cherche √† additionner quelque chose √† rien.\nArrangeons cela gr√¢ce √† un return :\ndef addition(a,b) : c = a+b return c Maintenant, addition(5,2) + 7 retourne gentiment 12.\nD√®s que l\u0026rsquo;instruction return est rencontr√©e lors de l\u0026rsquo;appel de la fonction le flot d\u0026rsquo;ex√©cution du code de la fonction est interrompu et reprend √† la ligne suivant l\u0026rsquo;appel.\ndef demo() : print(\u0026#34;Ligne ex√©cut√©e car avant le return\u0026#34;) return print(\u0026#34;Ligne non ex√©cut√©e car apr√®s le return\u0026#34;) demo() Ligne ex√©cut√©e car avant le return\nL\u0026rsquo;exemple pr√©c√©dent nous montre aussi qu\u0026rsquo;une fonction n\u0026rsquo;a pas n√©cessairement d\u0026rsquo;argument et qu\u0026rsquo;un return peut ne rien retourner (il ne sert alors qu\u0026rsquo;√† interrompre l\u0026rsquo;ex√©cution).\nComme on l\u0026rsquo;a vu pr√©c√©demment, un return, √† l\u0026rsquo;instar d\u0026rsquo;un break, peut donc interrompre une boucle dans le corps d\u0026rsquo;une fonction.\nL\u0026rsquo;appel d\u0026rsquo;une fonction est la valeur qu\u0026rsquo;elle retourne, qu\u0026rsquo;il s\u0026rsquo;agisse d\u0026rsquo;un entier, d\u0026rsquo;une liste, d\u0026rsquo;un dictionnaire, etc.\nUne fonction peut retourner plusieurs variables s√©par√©es par des virgules. L\u0026rsquo;appel est alors un tuple qui peut √™tre d√©ball√©.\ndef somme_moyenne(liste) : s = 0 for e in liste : s += e m = s/len(liste) return s,m L = [1,2,3,4] print(type(somme_moyenne(L))) a,b = somme_moyenne(L) print(\u0026#34;somme :\u0026#34;,a,\u0026#34;et moyenne :\u0026#34;,b) print(somme_moyenne(L)[1]) \u0026lt;class 'tuple'\u0026gt;\nsomme : 10 et moyenne : 2.5\n2.5\n"
},
{
	"uri": "http://example.org/semestre_2/tp/",
	"title": "TP",
	"tags": [],
	"description": "",
	"content": "Les travaux pratiques du deuxi√®me semestre.\n"
},
{
	"uri": "http://example.org/python/divers/",
	"title": "Divers",
	"tags": [],
	"description": "",
	"content": "Divers Commentaires Tous les langages de programmations permettent d\u0026rsquo;introduire des commentaires dans le code qui servent d\u0026rsquo;aides et de rep√®res √† celui qui lit le code, mais qui sont ignor√©s lors de l\u0026rsquo;ex√©cution.\nEn Python, les commentaires sont introduits par le symbole di√®se (hashtag) #.\n¬†Utilisation de print print est la premi√®re fonction native que l\u0026rsquo;on rencontre. C\u0026rsquo;est une fonction √† effet de bord : elle ne retourne rien (elle est de type None), mais elle permet d\u0026rsquo;afficher une cha√Æne de caract√®res, ou le contenu d\u0026rsquo;une variable, quel que soit son type.\nnom = \u0026#39;Joe\u0026#39; age = 212 print(nom,\u0026#39;a\u0026#39;,age,\u0026#39;ans.\u0026#39;) Joe a 212 ans.\nDe plus, print affiche par d√©faut un retour √† la ligne.\nBien que non exigible, l\u0026rsquo;utilisation des f-strings, introduites depuis Python 3.6, peut s\u0026rsquo;av√©rer tr√®s pratique. Les f-strings permettent d\u0026rsquo;inserrer des variables dans des cha√Ænes de caract√®res et de les mettre en forme avec une syntaxe minimale.\nPour utiliser des f-strings, il suffit de mettre un f devant la cha√Æne de caract√®res et de placer chaque variable entre accolade.\nprint(f\u0026#39;{nom} a {age} ans.\u0026#39;) print(f\u0026#39;{nom = }, {age = }) # tr√®s pratique pour les jeux de tests Joe a 212 ans.\nnom = 'Joe', age = 212\n¬†Importation de modules import module Pour importer le module machin, il suffit d\u0026rsquo;√©crire import machin. Chaque fonction contenue dans le module devra alors √™tre appl√©e en utilisant la notation point : machin.fonction (le point d√©signe ici une relation d\u0026rsquo;appartenance caract√©ristique de la programmation orient√©e objet).\nimport math print(f\u0026#39;{math.sqrt(2) = }\u0026#39;) math.sqrt(2) = 1.4142135623730951\n¬†import module as X Lorsqu\u0026rsquo;on utilise fr√©quemment un module, il est pratique d\u0026rsquo;abr√©ger son nom. Pour cela, on ajoute le raccourci souhait√© apr√®s un as lors de l\u0026rsquo;import : import machin as mch.\nimport numpy as np import matplotlib.pyplot as plt X = np.linspace(-np.pi,np.pi,100) Y = np.sin(X) plt.plot(X,Y) ¬†from module import x,y On peut aussi r√©cup√©rer uniquement certaines fonctions ou variables d\u0026rsquo;un module afin d\u0026rsquo;y avoir acc√®s directement (sans utiliser machin.).\nfrom math import pi,cos print(f\u0026#39;{cos(pi) = }\u0026#39;) cos(pi) = -1.0\n¬†from module import * Lorsqu\u0026rsquo;on est s√ªr que cela ne va pas poser probl√®me, on peut importer tout le contenu du module de la m√™me mani√®re. On utilise alors l\u0026rsquo;√©toile * qui signifie \u0026ldquo;tout\u0026rdquo;.\nCe type d\u0026rsquo;import est n√©anmoins d√©conseill√© √† moins de tr√®s bien conna√Ætre le contenu du module. Le danger est que dans l\u0026rsquo;ensemble de ce qui est import√©, il peut se trouver des variables ou des fonctions ayant un nom d√©j√† attribu√©. L\u0026rsquo;import r√©affectera alors ces variables contre notre gr√© et sans nous le dire.\nd = 8 e = 2 from math import * print(sqrt(d ** e)) 16.88210319127114\n¬†Manipulation de fichier texte Assertion "
},
{
	"uri": "http://example.org/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Introduction Comp√©tences vis√©es par ces cours d\u0026rsquo;informatique (d\u0026rsquo;apr√®s le BO) :\n analyser et modeÃÅliser un probleÃÄme ou une situation, notammant en utilisant les objets conceptuels de l\u0026rsquo;informatique pertinents (table relationnelle, graphe, dictionnaire, etc.)¬†; imaginer et concevoir une solution, d√©composer en blocs, se ramener √† des sous-probl√®mes simples et ind√©pendants, adopter une strat√©gie appropri√©e, d√©crire une d√©marche, un algorithme ou une structure de donn√©es permettant de r√©soudre le probl√®me¬†; d√©crire et sp√©cifier les caract√©ristiques d‚Äôun processus, les donn√©es d‚Äôun probl√®me, ou celles manipul√©es par un algorithme ou une fonction¬†; mettre en ≈ìuvre une solution, par la traduction d‚Äôun algorithme ou d‚Äôune structure de donn√©es dans un langage de programmation ou un langage de requ√™te¬†; justifier et critiquer une solution, que ce soit en d√©montrant un algorithme par une preuve math√©matique ou en d√©veloppant des processus d‚Äô√©valuation, de contr√¥le, de validation d‚Äôun code que l‚Äôon a produit¬†; communiquer √† l‚Äô√©crit ou √† l‚Äôoral, pr√©senter des travaux informatiques, une probl√©matique et sa solution ; d√©fendre ses choix ; documenter sa production et son impl√©mentation.  "
},
{
	"uri": "http://example.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]