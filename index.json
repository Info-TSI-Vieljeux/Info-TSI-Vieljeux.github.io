[
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_2/bonnes_pratiques/",
	"title": "Les bonnes pratiques",
	"tags": [],
	"description": "",
	"content": "Les bonnes pratiques Beaucoup de personnes amen√©es √† coder plus ou moins r√©guli√®rement se sont un jour retrouv√©es √† maudire leur moi du pass√© en reprenant un programme qu\u0026rsquo;ils avaient √©crit seulement quelques semaines/mois auparavant mais qui leur est subitement devenu compl√®tement cryptique.\nLe temps perdu est alors √©norme et v√©cu d\u0026rsquo;autant plus douloureusement qu\u0026rsquo;il √©tait facilement √©vitable\u0026hellip;\n¬†Commenter son code Commenter son code via l\u0026rsquo;utilisation de # est la principale protection contre de telles autotortures.\n Il ne s\u0026rsquo;agit pas de commenter chaque ligne comme on voit parfois\u0026hellip;\na,b = 2,3\t# j\u0026#39;affecte la valeur 2 √† la variable a et la valeur 3 √† b c = a+b # j\u0026#39;affecte √† c le r√©sultat de l\u0026#39;addition entre a et b print(c) # j\u0026#39;affiche le r√©sultat Il faut au contraire se concenter sur les points d√©licats susceptibles d\u0026rsquo;√©chapper √† son moi du futur (qui n\u0026rsquo;a jamais autant de m√©moire qu\u0026rsquo;on le pense).\nC\u0026rsquo;est souvent int√©ressant d\u0026rsquo;y justifier ses choix de programmation comme celui d\u0026rsquo;utiliser une structure de donn√©es plut√¥t qu\u0026rsquo;une autre (un dictionnaire plut√¥t qu\u0026rsquo;une liste par exemple). Ces diff√©rents choix sont en effet sens√©s ne rien devoir au hasard, donc autant noter clairement ce qui vous a fait pr√©f√©rer telle option plut√¥t qu\u0026rsquo;une autre, histoire que votre lecteur puisse comprendre votre d√©marche (et pour aider votre moi du futur √† s\u0026rsquo;y retrouver).\nDe mani√®re plus syst√©matique, une structure minimale de commentaires permet de cadrer rapidement les points cl√© d\u0026rsquo;un bloc d\u0026rsquo;instruction (qu\u0026rsquo;il s\u0026rsquo;agisse d\u0026rsquo;une boucle ou d\u0026rsquo;une fonction).\nUn bloc de code utilise g√©n√©ralement un ou plusieurs param√®tres appel√©s param√®tres d\u0026rsquo;entr√©es et construit √† partir d\u0026rsquo;eux un ou plusieurs param√®tres de sortie.\nDans l\u0026rsquo;id√©al, on commente alors chaque bloc de code en pr√©cisant dans la mesure du possibles les 3 √©l√©ments suivants :\n pr√©conditions postconditions invariant   pr√©conditions : ce sont les conditions que doivent v√©rifier imp√©rativement les param√®tres d\u0026rsquo;entr√©e pour que le code fasse ce qui est attendu.\n postconditions : ce sont les conditions que doivent v√©rifier imp√©rativement les param√®tres de sortie (apr√®s le bloc).\n Par exemple, si le bloc de code est sens√© calculer une moyenne sur 20, la postcondition sera que la variable de sortie soit bien un flottant compris entre 0 et 20 valant la moyenne des valeurs en entr√©e. invariant : propri√©t√© qui devra √™tre v√©rifi√©e √† chaque it√©ration de mani√®re √† ce que la pr√©condition aboutisse bien au final √† la poscondition.\n Exemples :\n si l\u0026rsquo;algorithme correspond √† \u0026ldquo;manger une pizza\u0026rdquo;, une pr√©condition est la pr√©sence de la pizza et une postcondition est l\u0026rsquo;absence de ladite pizza. pour calculer une racine carr√©e, une pr√©condition est que le nombre en entr√©e ne soit pas n√©gatif et une postcondition est que le carr√© de la sortie valle le nombre en entr√©e. pour utiliser une recherche dichotomique, la pr√©condition principale est que la liste soit tri√©e. lors d\u0026rsquo;un tri par s√©lection l'invariant est : \u0026ldquo;la partie de la liste d√©j√† inspect√©e est tri√©e\u0026rdquo;.  Exemple complet avec la division euclidienne :\n# ce code permet de calculer le quotient et le reste de la division euclidienne de a par b # pr√©conditions : a et b entiers, a ‚â• 0 et b \u0026gt; 0 a, b = 28, 5 r = a q = 0 while r \u0026gt;= b : # invariant : a = b*q + r r = r-b q = q+1 print(q,r) # postconditions : a = b*q + r, 0 ‚â§ r \u0026lt; b, a et b inchang√©s ¬†Choisir des noms explicites Bien nommer ses variables am√©liore fortement la lisibilit√© du code.\nChoisir des noms explicites qui se rapportent au r√¥le et/ou aux types des variables utilis√©es est en effet un bien meilleur guide pour le lecteur du code que des noms g√©n√©riques tel a, b, c\u0026hellip;\ny_0, v_0 = 0.3, 7.2 g = -9.8 t = 0 dt = 1e-3 y, v = y_0, v_0 while y \u0026gt; 0 : v += g*dt y += v*dt t += dt print(t) Un physicien comprend rapidement le but de ce code, mais d\u0026rsquo;autres choix de noms l\u0026rsquo;auraient rendu bien plus obscur.\n¬†Utiliser des fonctions Autre pratique am√©liorant son code : l\u0026rsquo;utilisation de fonctions.\nBut :\n √©viter de r√©√©crire du code : on appelle la fonction contenant le code √† la place (toute r√©p√©tition de code est globalement √† √©viter, comme dans un texte litt√©raire) ; simplifier la lecture du code (et plus les noms des fonctions seront clairs, plus la compr√©hension du code sera simplifi√©e) ; rendre son code modulaire : les fonctions construites sont autant d\u0026rsquo;outils ayant une mission clairement d√©finie. Et on peut tr√®s bien utiliser des fonctions au sein d\u0026rsquo;autres fonctions pour am√©liorer encore la lisibilit√©.  ¬†Documenter ses fonctions Les fonctions ont pour vocation d\u0026rsquo;√™tre r√©utilis√©es (par vous ou par d\u0026rsquo;autres) et demande donc une attention particuli√®re √† leur description. Les fonctions ont ainsi droit √† une forme de commentaire sp√©ciale, le docstring, qui peut √™tre interrog√©e directement par l\u0026rsquo;utilisateur (voir note ci-dessous).\nOn indique les types attendus des entr√©es (les param√®tres) et des sorties (les retours) en inscrivant la signature de la fonction dans son docstring et on y ajoute les pr√©conditions et les postconditions ainsi qu\u0026rsquo;une br√™ve descritpion.\nexemple :\ndef moyenne(notes) : \u0026#34;\u0026#34;\u0026#34; calcule une moyenne sur 20 √† partir de diff√©rentes notes sur 20 moyenne(notes:list) -\u0026gt; moy:float pr√©condition : la liste notes contient des nombres entre 0 et 20 postcondition : moy est la moyenne des √©l√©ments de notes \u0026#34;\u0026#34;\u0026#34; moy = 0 for n in notes : moy += n moy /= len(notes) return moy  On peut afficher le docstring d\u0026rsquo;une fonction via la m√©thode .__doc__.\n print(moyenne.__doc__) calcule une moyenne sur 20 √† partir de diff√©rentes notes sur 20\nmoyenne(notes:list) -\u0026gt; moy:float\npr√©condition : la liste notes contient des nombres entre 0 et 20\npostcondition : moy est la moyenne des √©l√©ments de notes\n¬†Contraindre les sp√©cifications avec des assertions En sus de noter les pr√©conditions dans les commentaires, on peut aussi tenter de s\u0026rsquo;assurer qu\u0026rsquo;elles sont bien v√©rifi√©es. Qui vous assure en effet que votre fonction, par ailleurs parfaitement sage lorsque les entr√©es respectent les pr√©conditions ne devienne pas folle dans certains cas loufoques¬†? C\u0026rsquo;est bien vous qui serez blam√© lorsque l\u0026rsquo;entr√©e farfelue causera une catastrophe\u0026hellip;\nL\u0026rsquo;explosion du vol 501 d\u0026rsquo;Ariane est √† cet √©gard un exemple √©difiant. Un m√™me programme ayant parfaitement accompli son ≈ìuvre de nombreuses ann√©es pour Ariane 4 a √©t√© r√©utilis√© en toute s√©r√©nit√© dans le nouveau mod√®le. Mais voil√†\u0026hellip; Le plan de vol diff√©rent d\u0026rsquo;Ariane 5 provoquait des acc√©l√©rations tr√®s sup√©rieures √† celles enregistr√©es sur Ariane 4 jusqu\u0026rsquo;√† d√©border la capacit√© alors allou√©e au codage de ces mesures dans la station inertielle. La valeur √©lev√©e non pr√©vue a plant√© le programme car elle a d\u0026rsquo;abord √©t√© r√©percut√©e sans lever d\u0026rsquo;erreur et du coup mal interpr√©t√©e par les dispositifs de correction de trajectoire. Une petite assertion bien plac√©e aurait peut-√™tre pu √©conomiser 1 milliard d\u0026rsquo;euros\u0026hellip;\nExemple (aux r√©percutions moins co√ªteuses) : pour s\u0026rsquo;assurer que le notes pass√©es en argument sont bien des nombres entre 0 et 20, on peut √©crire dans le corps de la fonction :\nfor n in notes : assert type(n) in (int,float) and 0\u0026lt;=n\u0026lt;=20 ¬†Tester Quand un code ne donne pas le r√©sultat attendu, il faut partir √† la recherche de l\u0026rsquo;erreur. Pour cela, le plus simple est d\u0026rsquo;utiliser un jeu de test.\nIl s\u0026rsquo;agit tout simplement de disposer des print tout le long de son code pour afficher conjointement les valeurs √† cette endroit du code des diff√©rentes variables et les valeurs qu\u0026rsquo;on aimerait qu\u0026rsquo;elles aient.\nLe plus efficace est d\u0026rsquo;adopter une d√©marche dichotomique pour placer ces tests : d√©but-milieu-fin dans un premier temps, puis on d√©coupe en deux d√©but-milieu et milieu-fin, etc.\n Prenons un exemple. Le programme suivant est sens√© d√©cider si la suite de caract√®res qu\u0026rsquo;on a entr√© au clavier est un palindrome ou non :\ndef bug() : res = [] fini = False print(\u0026#39;Ajoutez des caract√®res un par un en validant avec entr√©e, puis appuyez sur entr√©e pour terminer\u0026#39;) while not fini : elem = input(\u0026#39;\u0026#39;) if elem == \u0026#39;\u0026#39; : fini = True else : res.append(elem) tmp = res tmp.reverse() Pal = (res == tmp) if Pal : print(\u0026#39;palindrome\u0026#39;) else : print(\u0026#39;pas palindrome\u0026#39;) Lan√ßons bug et entrons les caract√®res 'a','2','a'.\nLa fonction affiche alors : palindrome\nJusque-l√† tout va bien.\nEntrons maintenant 'a','2','b'.\nLa fonction affiche maintenant\u0026hellip; palindrome\nDonc √ßa bugue. Mettons en place note d√©marche syst√©matique en inserrant un premier print √† peu pr√®s au milieu, juste apr√®s le while. √Ä ce niveau, on a construit la liste res, affichons-la au c√¥t√© de ce qu\u0026rsquo;on attend qu\u0026rsquo;elle soit.\ndef bug() : res = [] fini = False print(\u0026#39;Ajoutez des caract√®res un par un en validant avec entr√©e, puis appuyez sur entr√©e pour terminer\u0026#39;) while not fini : elem = input(\u0026#39;\u0026#39;) if elem == \u0026#39;\u0026#39; : fini = True else : res.append(elem) print(\u0026#34;res devrait √™tre [\u0026#39;a\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;b\u0026#39;] et est\u0026#34;,res) tmp = res tmp.reverse() Pal = (res == tmp) if Pal : print(\u0026#39;palindrome\u0026#39;) else : print(\u0026#39;pas palindrome\u0026#39;) Apr√®s avoir relanc√© bug() et retap√© 'a','2' et 'b', on voit s\u0026rsquo;afficher : res devrait √™tre ['a','2','b'] et est ['a', '2', 'b']\nOn sait maintenant que la premi√®re partie du code fait son boulot¬†!\nConcentrons-nous sur la deuxi√®me partie en pla√ßant un print avant le if. On a ici une nouvelle variable, tmp, en plus de res. Testons les deux¬†:\ndef bug() : res = [] fini = False print(\u0026#39;Ajoutez des caract√®res un par un en validant avec entr√©e, puis appuyez sur entr√©e pour terminer\u0026#39;) while not fini : elem = input(\u0026#39;\u0026#39;) if elem == \u0026#39;\u0026#39; : fini = True else : res.append(elem) #print(\u0026#34;res devrait √™tre [\u0026#39;a\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;b\u0026#39;] et est\u0026#34;,res) tmp = res tmp.reverse() Pal = (res == tmp) print(f\u0026#39;{tmp = } {res = }\u0026#39;) if Pal : print(\u0026#39;palindrome\u0026#39;) else : print(\u0026#39;pas palindrome\u0026#39;) S\u0026rsquo;affiche alors : tmp = ['b', '2', 'a'] res = ['b', '2', 'a']\nAha ! tmp a la bonne t√™te, maisres aussi a √©t√© modifi√©, et √ßa, ce n\u0026rsquo;√©tait pas pr√©vu\u0026hellip; Le probl√®me est donc dans les 3 lignes qui pr√©c√®dent le print. On pourrait placer un nouveau test entre ces lignes, mais vous aurez sans doute d√©j√† trouv√© le pi√®ge dans lequel le codeur est tomb√©.\nOn aurait pu √™tre tent√© de ne pas retester res √† cette √©tape puisqu\u0026rsquo;on venait de le faire au test pr√©c√©dent, mais cela aurait √©t√© du coup tr√®s mal jou√© (un bug dans la chasse au bug)¬†!\n L\u0026rsquo;exp√©rience la plus vexante et retorse, elle aussi v√©cue par beaucoup, voit le codeur pr√©senter fi√®rement un programme qui r√©pond parfaitement √† ses attentes, mais qui crashe piteusement √† la premi√®re utilisation d\u0026rsquo;une autre personne\u0026hellip;\nUne des raisons possibles est qu\u0026rsquo;il n\u0026rsquo;ait pas test√© son programme pour des entr√©es suffisamment diff√©rentes. Et si le testeur n\u0026rsquo;a pas re√ßu le m√©mo l\u0026rsquo;obligeant √† ne tenter que les quelques entr√©es que le codeur a valid√©es, il se retrouve en terrain min√©¬†!\nMorale : il faut tester le plus largement possible les entr√©es d\u0026rsquo;un programme.\n Pour ne pas non plus se perdre dans une revue syst√©matique, vous gagnerez √† partitionner le doma√Æne des entr√©es en grandes classes.\nUne classe est telle qu\u0026rsquo;√† l\u0026rsquo;int√©rieur, le programme r√©agisse de la m√™me fa√ßon avec toutes les entr√©es. Il suffit alors de ne tester qu\u0026rsquo;une seule valeur par classe.\n Exemple : si on fabrique une fonction valeur absolue, plut√¥t que de tester des milliers de nombres, on peut se contenter de tester une valeur dans chacune des trois classes suivantes correspondantes aux diff√©rents comportements de la fonction (et donc aux diff√©rents branchements de son code) : entr√©es $\u0026lt; 0$, entr√©es $\u0026gt; 0$ et la fronti√®re entr√©es $=0$.\nEn conclusion, mieux vous aurez d√©fini l\u0026rsquo;ensemble des entr√©es acceptables et bien inspect√© leurs fronti√®res, plus facilement vous pourrez guider le lecteur de votre code √† l\u0026rsquo;int√©rieur de ces fronti√®res de bon fonctionnement via les pr√©conditions. Car s\u0026rsquo;il est √©vident pour votre moi du pr√©sent que votre code demande n√©cessairement un type de donn√©es pr√©cis et qu\u0026rsquo;il ne viendrait √† l\u0026rsquo;id√©e de personne d\u0026rsquo;utiliser autre chose, attendez seulement quelques temps que le doute vous assaille en le relisant\u0026hellip; Et s\u0026rsquo;il vous arrive d\u0026rsquo;h√©siter un tant soit peu, imaginez quelqu\u0026rsquo;un d\u0026rsquo;autre¬†!\n"
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_1/tp0/",
	"title": "TP 0 : D√©marrage",
	"tags": [],
	"description": "",
	"content": "TP 0 : D√©marrage Cliquez sur cette invitation pour r√©cup√©rer le repository du TP. Exo 1 Combien de fois une feuille de papier d‚Äô√©paisseur $e=0,1$ mm doit-elle √™tre pli√©e pour atteindre la Lune ?\n √âcrivez dans la cellule suivante un code permettant d\u0026rsquo;obtenir la r√©ponse. Le plus simple est d\u0026rsquo;utiliser une boucle while.\n Wolfram alpha vous donne avec pr√©cision la distance Terre-Lune.\n### VOTRE CODE  Dans la cellule suivante, affectez √† la variable nb_plis la valeur enti√®re trouv√©e.\n nb_plis = 0 ¬†Exo 2  Compl√©tez le code de la fonction palindrome pour qu\u0026rsquo;il retourne un bool√©en valant True si la cha√Æne de caract√®res pass√©e en argument est bien un palindrome et False sinon.\n def palindrome(chaine) : \u0026#34;\u0026#34;\u0026#34; palindrome(chaine : string) -\u0026gt; test : bool pr√©condition : chaine est une chaine de caract√®res postcondition : si chaine est un palindrome, test vaut True, et False sinon. \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE return test ¬†Exo 3 Une liste peut √™tre utilis√©e comme une repr√©sentation simple d‚Äôun polyn√¥me, $P(x)$, o√π les √©l√©ments sont les coefficients des puissances de $x$ successives et les indices sont les puissances elles-m√™mes. Ainsi le polyn√¥me $P(x)=3+6x+2x^3$ sera repr√©sent√© par la liste [3,6,0,2].\nL\u0026rsquo;ex√©cution du code de la cellule suivante ne donne pas le r√©sultat attendu. Il est sens√© donn√© la liste repr√©sentant le polyn√¥me d√©riv√© $P'(x)$.\n Corrigez-le afin de rendre le retour affich√© correct.\n P = [3, 6, 0, 2] dPdx = [] i = 0 for c in P : i += 1 dPdx.append(i*c) dPdx [3, 12, 0, 8]\n¬†Exo 4 L‚Äôalgorithme de Luhn est une formule de somme de contr√¥le permettant de valider un num√©ro de carte bancaire. On consid√®re le num√©ro de carte comme une suite de nombres √† 1 chiffre.\n Renverser la liste. Prendre tous les chiffres en position paire dans la liste renvers√©e (2e chiffre, 4e chiffre, etc.) et doubler leur valeur, si le r√©sultat d√©passe 10, on ajoute les deux chiffres du r√©sultat (par exemple 6‚Üí12‚Üí3). Sommer tous les nombres de la nouvelle liste (les modifi√©s et les non-modifi√©s) Si cette somme vaut 0 modulo 10. Le num√©ro de carte est valide.   Compl√©ter la fonction suivante permettant de v√©rifier un num√©ro de carte.\n def verifcarte(numero) : \u0026#34;\u0026#34;\u0026#34; verifcarte(numero : string) -\u0026gt; bool pr√©condition : num√©ro est une cha√Æne de caract√®res (par exemple \u0026#39;1205 1205 1205 1205\u0026#39;) postcondition : la fonction retourne vrai si le num√©ro est valide et faux sinon \u0026#34;\u0026#34;\u0026#34; num = \u0026#39;\u0026#39; for c in numero : if c in \u0026#39;0123456789\u0026#39; : num += c assert len(num)==16, \u0026#39;Le num√©ro ne contient pas 16 chiffres\u0026#39; ### VOTRE CODE # Pour tester votre fonction num = \u0026#39;0000 0000 0000 9258\u0026#39; verifcarte(num) ¬†Exo 5 La suite de Syracuse est une suite d‚Äôentiers naturels d√©finie de la mani√®re suivante :\non part d‚Äôun nombre entier plus grand que z√©ro ;\n s‚Äôil est pair, on le divise par 2 ; s‚Äôil est impair, on le multiplie par 3 et on ajoute 1.  En r√©p√©tant l‚Äôop√©ration, on obtient une suite d‚Äôentiers positifs dont chacun ne d√©pend que de son pr√©d√©cesseur.\nLorsque 1 est atteint, un cycle de longueur 3 se r√©p√®te sans fin : 1, 4, 2, 1, 4, 2, 1,‚Ä¶\nOn ajoute donc une nouvelle r√®gle :\n si 1 est atteint, la suite s‚Äôarr√™te.  Appelons temps de vol le nombre de termes de la suite.\n Construisez une fonction qui renvoie le temps de vol correspondant √† une entr√©e donn√©e.\n def tpsdevol(nombre) : \u0026#34;\u0026#34;\u0026#34; tpsdevol(nombre : int) -\u0026gt; T : int pr√©condition : nombre est un entier positif \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE return T La conjecture de Syracuse (ou Collatz) dit que toutes les suites de Syracuse ont une fin.\nConfirmons la conjecture pour tous les entiers inf√©rieurs √† 100 gr√¢ce √† votre fonction.\nimport matplotlib.pyplot as plt plt.style.use(\u0026#39;seaborn\u0026#39;) plt.figure(figsize=(15,8),dpi=150) X = [i for i in range(1,100)] T = [] for x in X : T.append(tpsdevol(x)) plt.plot(X,T) plt.xlabel(\u0026#39;nombre de d√©part\u0026#39;) plt.ylabel(\u0026#39;temps de vol\u0026#39;) "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_1/tp1recherche/",
	"title": "TP 1 : recherche simple",
	"tags": [],
	"description": "",
	"content": "TP 1 : Recherche s√©quentielle dans un tableau unidimensionnel. Dictionnaires. Cliquez sur cette invitation pour r√©cup√©rer le repository du TP. Recherche d\u0026rsquo;un √©l√©ment dans une liste  √âcrire une fonction recherche qui prend pour argument un √©l√©ment et une liste et qui retourne True si l\u0026rsquo;√©l√©ment est pr√©sent et False sinon.\nLe corps de la fonction devra comprendre une boucle.\n Rq : le but de recherche est de reproduire le fonctionnement du mot cl√© in.\ndef recherche(x,L) : \u0026#39;\u0026#39;\u0026#39; recherche(x : tout type, L : list) -\u0026gt; bool \u0026#39;\u0026#39;\u0026#39; ### VOTRE CODE  Dans le pire des cas (√©l√©ment ne se trouvant pas dans la liste), combien de comparaisons doit-on op√©rer pour savoir si un √©l√©ment est pr√©sent dans une liste de taille 400 ?\n  Construisez une fonction dico qui prend en argument une liste L de $n$ entiers inf√©rieurs √† $n$ et qui retourne un dictionnaire de longueur $n$ dont les cl√©s sont les $n$ premiers entiers (de 0 √† $n$-1) et les valeurs comptent le nombre de fois que la cl√© est pr√©sente dans la liste.\nExemple : s\u0026rsquo;il y a 2 fois l\u0026rsquo;√©l√©ment 18 dans la liste L, alors dico(L)[18]==2, et si l\u0026rsquo;√©l√©ment 97 n\u0026rsquo;est pas pr√©sent dans la liste, alors dico(L)[97]==0.\n from random import randint def dico(L) : \u0026#39;\u0026#39;\u0026#39; dico(L : list) -\u0026gt; dict pr√©condition : si la longueur de L vaut n, alors L ne contient que des entiers \u0026lt; n \u0026#39;\u0026#39;\u0026#39; ### VOTRE CODE D√©finissons une fonction recherche_dico qui v√©rifie si un entier est bien pr√©sent :\ndef recherche_dico(e,dic) : \u0026#39;\u0026#39;\u0026#39; recherche_dico(e : int, dic : dict) -\u0026gt; bool \u0026#39;\u0026#39;\u0026#39; if dic[e] \u0026gt;= 1 : return True else : return False # Exemple d\u0026#39;utilisation : L = [5,2,3,1,2,0,2] dic = dico(L) (recherche_dico(3,dic),recherche_dico(4,dic)) (True, False)\nL\u0026rsquo;int√©r√™t de recherche-dico est d\u0026rsquo;aller beaucoup plus vite que recherche comme le montre le graphe suivant (l\u0026rsquo;execution du code peut prendre quelques secondes) :\nfrom time import time from random import randint import matplotlib.pyplot as plt plt.style.use(\u0026#39;ggplot\u0026#39;) I, T_ch, T_dico = [], [], [] for i in range(1000,200000,1000) : L = [] L = [randint(0,i-1) for k in range(i)] # randint(i,j) retourne un entier dans {i;...;j} # la liste L contient i √©l√©ments tir√©s au hasard entre 0 et i-1 dic = dico(L) # on cr√©e un dictionnaire √† partir de L gr√¢ce √† la fonction \u0026#39;dico\u0026#39; element = randint(0,i-1) # \u0026#39;element\u0026#39; est un entier tir√© au hasard entre 0 et i-1 start = time() # on note l\u0026#39;heure exacte recherche(element,L) stop1 = time() recherche_dico(element,dic) stop2 = time() T_ch.append(stop1-start) T_dico.append(stop2-stop1) I.append(i) plt.figure(figsize = (15,5)) plt.plot(I,T_dico,label=\u0026#34;recherche_dico\u0026#34;) plt.plot(I,T_ch,label=\u0026#34;votre fonction \u0026#39;recherche\u0026#39;\u0026#34;) plt.xlabel(\u0026#39;taille de la liste\u0026#39;) plt.ylabel(\u0026#34;temps d\u0026#39;ex√©cution (s)\u0026#34;) plt.legend() Recherche d\u0026rsquo;un maximum  √âcrire une fonction maximum qui prend pour argument une liste et qui retourne le plus grand √©l√©ment de la liste.\n(Interdiciton d\u0026rsquo;utiliser la fonction native max √©videmment)\n def maximum(L) : \u0026#39;\u0026#39;\u0026#39; maximum(L : list) -\u0026gt; float ou int \u0026#39;\u0026#39;\u0026#39; ### VOTRE CODE Que se passera-t-il si on passe la liste suivante [1,3,'a',-2] en argument √† maximum ?\nmaximum([1,3,\u0026#39;a\u0026#39;,-2])  Pour √©viter cela, vous devrez vous assurez en amont que la liste donn√©e en argument contient bien que des nombres.\nRappel : type(3) renvoie int et type(2.8) renvoie float.\nVous placerez un assert en d√©but de fonction pr√©venant l\u0026rsquo;utilisateur que la liste contient des types farfelus.\n def maximum_secure(L) : \u0026#39;\u0026#39;\u0026#39; maximum(L : list) -\u0026gt; float ou int la fonction l√®ve une \u0026#39;AsserionError\u0026#39; si la liste ne contient pas que des nombres \u0026#39;\u0026#39;\u0026#39; ### VOTRE CODE  Construisez maintenant une fonction max_2 qui retourne le deuxi√®me maximum d√©fini comme le plus grand √©l√©ment strictement inf√©rieur au maximum (s\u0026rsquo;il y a plusieurs √©l√©ments ayant la valeur maximale, il ne faut pas retourner un de ceux-l√†).\nVotre fonction max_2 devra utiliser votre ancienne fonction maximum, mais vous ferez attention √† ne pas placer maximum √† l\u0026rsquo;int√©rieur d\u0026rsquo;une boucle.\n def max_2(L) : \u0026#39;\u0026#39;\u0026#39; max_2(L : list) -\u0026gt; float ou int pr√©condition : L est une liste de nombres postcondition : la fonction retourne le plus grand √©l√©ment strictement plus petit que le max de la liste. \u0026#39;\u0026#39;\u0026#39; ### VOTRE CODE Ci-dessous est repr√©sent√©e l\u0026rsquo;√©volution du temps d\u0026rsquo;ex√©cution de la fonction native max ainsi que de la fonction maximum (si vous avez r√©ussi √† l\u0026rsquo;impl√©menter) en fonction de la taille de la liste en argument.\nOn remarque que cette √©volution est lin√©aire : l\u0026rsquo;augmentation du temps d\u0026rsquo;ex√©cution semble proportionnelle √† l\u0026rsquo;augmentation de la taille de la liste.\nI, T_max, T_maximum = [], [], [] for i in range(50000,1000000,50000) : L = [] for k in range(i) : L += [randint(0,k)] # randint(i,j) retourne un entier dans {i;...;j} start1 = time() max(L) stop1 = time() T_max.append(stop1-start1) start2 = time() maximum(L) stop2 = time() T_maximum.append(stop2-start2) I.append(i) plt.figure(figsize = (15,5)) plt.plot(I,T_max,label=\u0026#34;la fonction Python \u0026#39;max\u0026#39;\u0026#34;) plt.plot(I,T_maximum,label=\u0026#34;votre fonction \u0026#39;maximum\u0026#39;\u0026#34;) plt.xlabel(\u0026#39;taille de la liste\u0026#39;) plt.ylabel(\u0026#34;temps d\u0026#39;ex√©cution (s)\u0026#34;) plt.legend()  Ajoutez la fonction max_2 √† ce graphe et r√©pondre dans la cellule suivante si oui ou non, le temps d\u0026rsquo;ex√©cution de max_2 semble d√©pendre lin√©airement de la taille de la liste.\n "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/python/traitsgaux/",
	"title": "Traits g√©n√©raux",
	"tags": [],
	"description": "",
	"content": "Traits g√©n√©raux Introduction Shell et IDE Python est un langage de programmation interpr√©t√© d√©velopp√© par Guido van Rossum en 1989. Langage imp√©ratif de haut-niveau dot√© d\u0026rsquo;une syntaxe simple, Python s\u0026rsquo;adapte √† de nombreux contextes gr√¢ce √† sa modularit√© ; une importante librairie de modules et packages permet en effet d\u0026rsquo;√©tendre ses capacit√©s.\nPython poss√®de son propre shell (interface en ligne de commande) : l\u0026rsquo;utilisateur entre une commande Python qui est interpr√©t√©e imm√©diatement lorsque Entr√©e est tap√©e.\nAu lancement, le shell Python, poli, se pr√©sente :\nLes 3 chevrons sont l\u0026rsquo;invite (ou prompt) o√π les commandes seront √©crites.\nIPython, un shell plus √©volu√©, utilise [1] comme invite (o√π le chiffre dans les crochets s\u0026rsquo;incr√©mente √† chaque commande).\nPour sortir du shell classique, il faut taper exit(), et exit ou quit pour sortie du shell IPython.\nOn peut tout √† fait ex√©cuter des commandes Python une √† une dans le shell.\nUne commande qui renvoie un r√©sultat est appel√©e expression, alors qu\u0026rsquo;une commande qui ne renvoie rien est une instruction.\nToute fonction est une expression, mais certaines ont en plus un effet sur l\u0026rsquo;environnement comme print() qui permet d\u0026rsquo;afficher une cha√Æne de caract√®res dans le shell ou dans un fichier (elle retourne aussi la valeur None qui est omise dans ce cas par le shell). Par une mauvaise traduction de l\u0026rsquo;anglais side effect, les fonctions qui modifient un √©tat en dehors de leur environnement local comme une modification de la m√©moire (√©criture d\u0026rsquo;un fichier) ou une modification d\u0026rsquo;un p√©riph√©rique (affichage sur l\u0026rsquo;√©cran par exemple) sont dites √† effet de bord.\n Pour les projets plus complexes n√©cessitant d\u0026rsquo;encha√Æner les instructions, on √©crit l\u0026rsquo;ensemble de ces commandes (le programme) dans un √©diteur de texte et on enregistre le fichier avec une extension .py.\nOn demande alors √† l\u0026rsquo;interpr√®te Python d\u0026rsquo;ex√©cuter l\u0026rsquo;ensemble du script en utilisant la commande python nom_du_fichier.py dans le shell de l\u0026rsquo;OS. Les diff√©rents retours dans le shell ne sont alors plus affich√©s, seuls les effets ont un\u0026hellip; effet.\nLe plus simple pour coder est d\u0026rsquo;utiliser un environnement de travail (IDE pour \u0026ldquo;integrated development environment\u0026rdquo;) qui combine un √©diteur de code et un shell Python permettant d\u0026rsquo;ex√©cuter le script entier ou une partie directement via l\u0026rsquo;interface.\nInstallation L\u0026rsquo;installation d'Anaconda rend disponible les principales biblioth√®ques scientifiques Python ainsi que le preformant IDE Spyder ou encore Jupyterlab (tr√®s int√©ressant pour les pr√©sentations de projets car associant dans une m√™me interface texte et code pour former un notebook).\n ¬†Passons maintenant en revue quelques caract√©ristiques du langage Python.\nTypage dynamique Contrairement √† des langages √† typage statique comme le C, le type de la variable n\u0026rsquo;a pas besoin d\u0026rsquo;√™tre d√©clar√©e en Python. On parle alors de typage dynamique.\nL\u0026rsquo;interpr√®te Python d√©termine par lui-m√™me le type en fonction de l\u0026rsquo;objet affect√© √† la variable.\n¬†Principe d\u0026rsquo;indentation Beaucoup de langage de programmation (C++, Java par exemple) utilisent des accolades {} pour d√©finir un bloc de code (boucles,fonctions, instructions conditionnelles). Python utilise l'indentation (d√©calage d\u0026rsquo;un nombre constant d\u0026rsquo;espaces blancs, g√©n√©ralement 4, ou une tabulation).\nfor i in range(3) : mot = \u0026#39;\u0026#39; for lettre in (\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;) : mot += lettre*i print(mot)  Qu\u0026rsquo;est-ce qui s\u0026rsquo;affiche ?\n ¬†Port√©e lexicale Les variables d√©finies √† l\u0026rsquo;int√©rieur d\u0026rsquo;une fonction ont une port√©e locale. Elles ne sont pas reconnues dans le code principal (en dehors du bloc de la fonction).\n√Ä l\u0026rsquo;inverse, les variables affect√©es dans le programme principal peuvent √™tre utilis√©es partout (y compris dans la fonction) et sont dites globales.\nExemple :\ndef foo() : a = \u0026#39;locale\u0026#39; print(a) print(b) b = \u0026#39;globale\u0026#39; foo() locale\nglobale\nComme b n\u0026rsquo;est pas d√©finie dans la bloc de la fonction, Python va la chercher dans le champ global. Mais il faut que b soit affect√©e avant l\u0026rsquo;appel de la fonction.\nQue se passe-t-il si une fonction d√©finit une variable locale avec le m√™me nom qu\u0026rsquo;une variable globale ?\nLe champ local est scrut√© en premier.\nExemple :\ndef foo() : a = \u0026#39;locale\u0026#39; print(a) a = \u0026#39;globale\u0026#39; foo() print(a) locale\nglobale\nNotons bien que la variable locale a n\u0026rsquo;existe que dans le bloc de d√©finition, qu\u0026rsquo;elle ait ou non le m√™me nom qu\u0026rsquo;une variable globale ne change rien. Elle disparait quand l\u0026rsquo;interpr√®te sort de la fonction et n\u0026rsquo;√©crase donc pas la variable globale a.\nDans l\u0026rsquo;ordre, Python regarde d\u0026rsquo;abord le champ local, puis non local (le champ englobant la fonction int√©rieure dans le cas de fonctions imbriqu√©es), puis global, puis built-in (les fonctions natives qu\u0026rsquo;il convient donc de ne pas red√©finir).\n Une fonction ne peut pas modifier une variable globale sans pr√©ciser qu\u0026rsquo;elle le souhaite.\nExemple :\nx = 2 def fct1() : print(x) def fct2() : x += 1 print(x)  Que se passe-t-il lorsqu\u0026rsquo;on appelle fct1() ? Et fct2() ?\n Pour r√©gler le probl√®me, il faut utiliser le mot cl√© global qui permet de r√©affecter la variable globale √† l\u0026rsquo;int√©rieur de la fonction.\ndef fct2() : global x x += 1 print(x) L\u0026rsquo;appel de fct2() se fait maintenant sans heurt et 3 s\u0026rsquo;affiche.\nCe type de r√©affectation est n√©anmoins √† √©viter, car il am√®ne pas mal de confusion. C\u0026rsquo;est souvent plus logique de passer x en argument de la fonction.\n ¬†Appel de fonction par valeur Lors de l\u0026rsquo;appel d\u0026rsquo;une fonction, les arguments sont copi√©s et la fonction travaille alors uniquement sur cette copie.\nLa copie dispara√Æt lors du retour au programme principal.\nSi la fonction modifie la valeur d\u0026rsquo;un de ses arguments, seule la copie sera modifi√©e, pas la variable du programme principal.\nOn dit que les arguments d\u0026rsquo;une fonction sont transmis par valeurs (par contraste avec la transmission par r√©f√©rence ou adresse comme dans le langage Java o√π une modification de l\u0026rsquo;argument dans la fonction se r√©percute dans le programme principal).\nExemple :\ndef foo(a) : print(\u0026#34;valeur de \u0026#39;a\u0026#39; au d√©but de la fonction :\u0026#34;,a) a = a*2 print(\u0026#34;valeur de \u0026#39;a\u0026#39; √† la fin de la fonction :\u0026#34;,a) a = 2 print(\u0026#34;valeur de \u0026#39;a\u0026#39; dans le programme principal avant l\u0026#39;appel de la fonction :\u0026#34;,a) foo(a) print(\u0026#34;valeur de \u0026#39;a\u0026#39; dans le programme principal apr√®s l\u0026#39;appel de la fonction :\u0026#34;,a) valeur de 'a' dans le programme principal avant l'appel de la fonction : ...\nvaleur de 'a' au d√©but de la fonction : ...\nvaleur de 'a' √† la fin de la fonction : ...\nvaleur de 'a' dans le programme principal apr√®s l'appel de la fonction : ...\nNotons toutefois que si l\u0026rsquo;argument est une liste, c\u0026rsquo;est sa r√©f√©rence qui est cette fois transmise\u0026hellip; Toute modification de la liste dans la fonction se r√©percute √† l\u0026rsquo;ext√©rieur. La fonction a alors un effet de bord. C\u0026rsquo;est d√ª au statut mutable des listes dans Python. Et cela sera donc la m√™me chose avec les dictionnaires, autre objet mutable.\n"
},
{
	"uri": "https://info-tsi-vieljeux.github.io/python/",
	"title": "Python",
	"tags": [],
	"description": "",
	"content": "Python √âl√©ments du langage Python dont la connaissance est exigibles aux concours.\nAucun concept sous-jacent n\u0026rsquo;est exigible ainsi qu\u0026rsquo;aucune connaissance sur un module particulier.\n"
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_2/correctionterminaison/",
	"title": "Correction / Terminaison",
	"tags": [],
	"description": "",
	"content": "Prouver un algorithme Le mot algorithme vient de la latinisation du nom du savant arabe al-KhuwƒÅrizmƒ´ (780-850) qui a entre autres permis l\u0026rsquo;introduction de l\u0026rsquo;alg√®bre en Europe (et il est aussi √† l\u0026rsquo;origine de ce mot).\nUn algorithme est une m√©thode qui sert √† r√©soudre un probl√®me en un nombre fini d‚Äô√©tapes : chercher un mot dans le dictionnaire, classer des mots par ordre alphab√©tique, classer des nombres par ordre de grandeur, chercher le meilleur parcours possible sur une carte, trouver une racine carr√©e, construire des listes de nombres premiers, etc.\nOn peut d√©crire un algorithme comme √©tant une suite d\u0026rsquo;actions √† accomplir s√©quentiellement, dans un ordre fix√©.\nPour G√©rard Berry, ex titulaire de la chaire Informatique et sciences num√©riques au Coll√®ge de France, l\u0026rsquo;algorithmique est l\u0026rsquo;art d\u0026rsquo;organiser un calcul complexe en partant d\u0026rsquo;op√©rations simples (un ordinateur √©tant un objet extraordinairement stupide mais tr√®s ob√©issant).\nLes algorithmes manipulent trois types de choses :\n des objets : bits, entiers, flottants, mots, images, etc. des structures de donn√©es (comment on organise les objets) : piles, listes, cha√Ænes, arbres, etc. des structures de contr√¥le (comment on organise les op√©rations) : s√©quence, condition, boucle, etc.  Face √† un algorithme, on peut se poser plusieurs questions :\n Est-ce qu\u0026rsquo;il donne un r√©sultat ou bien est-ce qu‚Äôil ne s‚Äôarr√™te jamais ? C\u0026rsquo;est le probl√®me de la terminaison d\u0026rsquo;un algorithme. Est-ce qu\u0026rsquo;il donne le r√©sultat attendu ou bien est-ce qu‚Äôil calcule n‚Äôimporte quoi ? C\u0026rsquo;est le probl√®me de la correction de l\u0026rsquo;algorithme. Est-ce qu‚Äôil donne le r√©sultat en un temps raisonnable ou bien est-ce qu‚Äôil faut attendre plusieurs si√®cles ? C\u0026rsquo;est le probl√®me de la complexit√© de l\u0026rsquo;algorithme.  ¬†Terminaison d\u0026rsquo;un algorithme Un algorithme doit se terminer en un temps fini !\nOn est s√ªr qu\u0026rsquo;un algorithme termine si le nombre d\u0026rsquo;√©tapes est fix√©.\nLes deux √©nemis de la terminaison sont :\n les boucles while la r√©cursivit√©  ¬†Algorithmes it√©ratifs : Pour les algorithmes it√©ratifs, les boucles while (tant que) sont la partie pouvant poser probl√®me, car le nombre d\u0026rsquo;√©tapes n\u0026rsquo;est pas fix√© √† l\u0026rsquo;avance.\nPour prouver leur terminaison, on exhibe un variant de boucle.\nUn variant de boucle est un entier strictement positif avant l\u0026rsquo;entr√©e dans la boucle qui d√©cro√Æt strictement √† chaque passage dans la boucle.\n Trouver un variant de boucle prouve que la boucle termine, car sinon il existerait une suite d√©croissante d\u0026rsquo;entiers naturels, ce qui est impossible.\nExemple : preuve de la terminaison de l'algorithme d\u0026rsquo;exponentiation rapide\ndef puissance(a,n) : p = 1 while n \u0026gt; 0 : if n%2 == 0 : a *= a n //= 2 else : p *= a n -= 1 return p Si on sp√©cifie que n doit √™tre un entier positif, alors n est un variant de boucle. En effet :\n $n$ est bien un entier strictement positif avant chaque passage dans la boucle : $n$ est initialement un entier positif (par hypoth√®se) et $n$ reste entier apr√®s k passages dans la boucle (par r√©currence simple). De plus, la boucle s\u0026rsquo;arr√™te si $n‚â§0$. $n$ est bien strictement d√©croissant : en notant $n'$ la valeur de $n$ apr√®s un passage dans la boucle, si $n$ est pair avant un passage dans la boucle, on a $\\displaystyle n'=\\frac{n}{2}$ et comme $n‚â•2$, $n'\u0026lt;n$. Et si $n$ est impair, alors on a $n'=n-1$ et donc √† nouveau $n'\u0026lt;n$.  ¬†Algorithmes r√©cursifs : On prouve la terminaison d\u0026rsquo;un algorithme r√©cursif par r√©currence (par construction, tout ce qui est li√© aux algorithme r√©cursifs se prouve par r√©currence).\nExemple : l\u0026rsquo;algorithme r√©cursif suivant calcul la somme des n premiers entiers.\ndef sommerec(n) : \u0026#34;\u0026#34;\u0026#34; sommerec(n : int) -\u0026gt; int pr√©conditions : n est un entier positif postcondition : retourne la somme des entiers positifs ‚â§ n \u0026#34;\u0026#34;\u0026#34; if n == 0 : return 0 else : return n + sommerec(n-1) Prouvons par r√©currence sur n que l\u0026rsquo;algorithme termine :\n pour n = 0, c\u0026rsquo;est bon (cas de base). supposons que l\u0026rsquo;algorithme termine pour l\u0026rsquo;entr√©e n-1 (ie sommerec(n-1) termine).\nPour l\u0026rsquo;entr√©e n, l\u0026rsquo;algorithme retourne n + sommerec(n-1), donc sommerec(n) termine. conclusion : sommerec termine pour tout n.  ¬† On ne peut pas prouver automatiquement l\u0026rsquo;arr√™t d\u0026rsquo;un programme.\nC\u0026rsquo;est ce qu\u0026rsquo;affirme le th√©or√®me de l\u0026rsquo;arr√™t : il n\u0026rsquo;existe pas de programme prenant en entr√©e le code d\u0026rsquo;un programme et ses arguments et qui renvoie oui si le programme se termine pour une certaine entr√©e, non sinon.\nLa conjecture de syracuse (tp0) est un exemple de programme dont on ne sait pas s\u0026rsquo;il se termine pour une entr√©e quelconque.\n Preuve de correction d‚Äôun algorithme Ariane 501 a explos√© √† cause d\u0026rsquo;un bug tout petit dans un programme qui ne servait √† rien.\nProuver la correction d\u0026rsquo;un algorithme permet d\u0026rsquo;√©viter une telle m√©saventure, mais c\u0026rsquo;est difficile. Il faut pouvoir prouver qu‚Äôun programme s‚Äôex√©cute correctement dans toutes les situations. Mais correct selon quels crit√®res ? Quelles situations sont √† consid√©rer ?\nSp√©cifier les donn√©es acceptables (les pr√©conditions), les r√©sultats attendus (les postconditions) et exprimer logiquement la propri√©t√© devant lier les donn√©es aux r√©sultats (les entr√©es aux sorties) sont des √©l√©ments fondamentaux. Plus pr√©cis√©ment, on prouve qu\u0026rsquo;un algorithme fait ce qu\u0026rsquo;il est sens√© faire si pour toute entr√©e v√©rifiant les pr√©conditions, il donne une sortie v√©rifiant les postconditions.\n Si on prouve que pour toute donn√©e d\u0026rsquo;entr√©e qui v√©rifie les pr√©conditions, l\u0026rsquo;algorithme renvoie des donn√©es de sortie v√©rifiant les postconditions,\non dit qu\u0026rsquo;on a prouv√© la correction partielle de l\u0026rsquo;algorithme.\n Si on prouve en plus que l\u0026rsquo;algorithme termine,\non dit qu\u0026rsquo;on a prouv√© la correction totale de l\u0026rsquo;algorithme.\n ¬†Algorithmes it√©ratifs : Les difficult√©s se concentrent encore au niveau des boucles. Pour prouver qu\u0026rsquo;une boucle fait bien son boulot, on utilise cette fois-ci un invariant de boucle.\nUn invariant de boucle est une propri√©t√© vraie avant le premier tour de boucle et qui se conservera pendant toute l‚Äôex√©cution de la boucle (donc qui restera vraie d‚Äôun tour √† l‚Äôautre de la boucle), et sera toujours vraie une fois que la boucle aura fini de s‚Äôex√©cuter.\n Une d√©monstration par invariant de boucle se d√©roule en 3 √©tapes analogues √† une preuve par r√©currence (seule la terminaison diff√®re) :\n  Entr√©e de boucle = initialisation ($\\rightarrow$ initialisation) :\non d√©montre que juste avant de rentrer dans le premier tour de boucle l‚Äôinvariant est vrai.\n  Passage dans la boucle = conservation ($\\rightarrow$ h√©r√©dit√©) :\non suppose que l‚Äôinvariant est vrai au d√©but d‚Äôun passage quelconque dans la boucle et on d√©montre que l‚Äôinvariant reste vrai en fin de boucle.\n  Sortie de boucle = terminaison ($\\rightarrow$ conclusion) :\nl‚Äôinvariant est toujours vrai (car il √©tait vrai √† la fin du dernier tour de boucle) mais la condition de boucle est devenue fausse.\n  ¬†Exemple : preuve de la correction de l'algorithme d\u0026rsquo;Euclide\ndef pgcd(a,b) : while b != 0 : a, b = b, a%b return a On note $a_k$ et $b_k$ les valeurs de a et b √† la fin de la k√®me it√©ration ($a_0$ et $b_0$ d√©signent les valeurs de a et b avant d‚Äôentrer dans la boucle).\nL\u0026rsquo;invariant de boucle est le $pgcd$ de a et b. En effet :\n Initialisation :\nelle est triviale puisque $a$ et $b$ n\u0026rsquo;ont pas encore √©t√© modifi√© ($pgcd(a_0,b_0)=pgcd(a,b)$). Conservation :\nsi $a=bq+r$, il est clair que tout diviseur commun de $a$ et $b$ est un diviseur commun de $b$ et $r$ et r√©ciproquement. Notamment, $pgcd(a,b) = pgcd(b,r)$.\nCeci prouve que $pgcd(a_k,b_k) = pgcd(a_{k+1},b_{k+1})$. La quantit√© $pgcd(a_k,b_k)$ est donc bien un invariant de boucle. Terminaison :\n√† la fin de la derni√®re it√©ration (num√©rot√©e $f$), $b_f=0$ de sorte que $pgcd(a_0,b_0)=pgcd(a_f,b_f)=pgcd(a_f,0)=a_f.$\nEn renvoyant $a_f$, la fonction pgcd(a,b) renvoie donc bien le $pgcd$ de a et b.  ¬†Algorithmes r√©cursifs : La correction d\u0026rsquo;un algorithme r√©cursif est g√©n√©ralement beaucoup plus simple √† prouver que celle d\u0026rsquo;un it√©ratif (c\u0026rsquo;est l√† une des principales qualit√©s de la r√©cursivit√©).\nEn effet, la propri√©t√© transmise des pr√©conditions au postconditions (jouant le r√¥le d\u0026rsquo;invariant de boucle) est g√©n√©ralement beaucoup plus simple √† trouver et souvent m√™me directement inscrite dans le corps de la fonction.\nReprenons l\u0026rsquo;exemple de la somme des entiers et d√©montrons par r√©currence sa correction :\n si n = 0, la somme vaut bien 0. supposons que sommerec(n-1) donne la somme des n-1 premiers entiers. Alors la somme des n premiers entiers vaudra sommerec(n-1) + n et c\u0026rsquo;est bien ce que retourne sommerec(n). Conclusion : pour tout n, sommerec(n) retourne la somme des n premiers entiers.  On aurait pu se montrer plus technique en utilisant comme propri√©t√© h√©r√©ditaire : $u_n=$sommerec(n) $=\\frac{n(n+1)}{2}$\nEn supposant la propri√©t√© vraie au rang n-1, sommerec(n) = n + sommerec(n-1) $=n+u_{n-1}$ $= n + \\frac{n(n-1)}{2} = \\frac{n(n+1)}{2}$\n¬†Construire un algorithme pour qu\u0026rsquo;il soit correct Expliciter l\u0026rsquo;invariant comme on a vu dans les bonnes pratiques en s\u0026rsquo;en servir comme guide permet de s\u0026rsquo;assurer en amont de la correction de l\u0026rsquo;algorithme ; on sait o√π on va.\nPar exemple, pour le tri par s√©lection, faire en sorte que l\u0026rsquo;invariant \u0026ldquo;la partie de la liste d√©j√† inspect√©e est tri√©e\u0026rdquo; soit toujours vrai nous assure de la correction future de l\u0026rsquo;algorithme ; en s\u0026rsquo;assurant que la partie non tri√©e diminue √† chaque tour, on finira bien par obtenir une liste enti√®rement tri√©e.\nAutre exemple, pour consruire les m√©thodes li√©es √† la structure de donn√©es appel√©e tas que l\u0026rsquo;on retrouvera dans le chapitre sur les graphes, on est guid√© par la conservation de l\u0026rsquo;invariant \u0026ldquo;les cl√© des enfants doivent √™tre sup√©rieures √† celles du parent\u0026rdquo; (voir la vid√©o pour les d√©tails).\n Exercice : prouver la correction totale de l\u0026rsquo;algorithme de la division euclidienne vu dans les bonnes pratiques.\n "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_1/tp2imbrication/",
	"title": "TP 2 : boucles imbriqu√©es",
	"tags": [],
	"description": "",
	"content": "Algorithmes op√©rant sur une structure s√©quentielle par boucles imbriqu√©es Cliquez sur cette invitation pour r√©cup√©rer le repository du TP. Chercher un mot dans un texte  √âcrire une fonction cherche_mot na√Øve qui recherche si un mot est pr√©sent dans un texte en comparant chaque morceau du texte de la taille du mot au mot recherch√©.\nVous devrez vous assurez (gr√¢ce √† des assertions) que le mot et le texte sont bien des cha√Ænes de caract√®res et que le mot n\u0026rsquo;est pas plus long que le texte.\n def cherche_mot(mot,texte) : \u0026#39;\u0026#39;\u0026#39; cherche_mot(mot:string, texte:string)-\u0026gt;bool \u0026#39;\u0026#39;\u0026#39; ### VOTRE CODE # importation de la classique liste de mots de passe rockyou (cela prend quelques secondes) from urllib.request import urlopen url = \u0026#39;http://cordier-phychi.toile-libre.org/Info/github/rockyou.txt\u0026#39; rockyou = urlopen(url).read().decode(\u0026#39;latin-1\u0026#39;) print(f\u0026#34;Le fichier rockyou contient {len(rockyou.split())} mots de passe !\u0026#34;) Le fichier rockyou contient 14445388 mots de passe !\n# vous pouvez tester la pr√©sence de votre mot de passe dans la liste mot_de_passe = \u0026#39;...\u0026#39; cherche_mot(mot_de_passe,rockyou)  Sans ce soucier de l\u0026rsquo;impl√©mentation, combien faudra-t-il th√©oriquement faire de comparaisons au minimum pour s\u0026rsquo;assurer qu\u0026rsquo;un mot de 3 caract√®res est absent d\u0026rsquo;une cha√Æne de 10 caract√®res ?\n Tra√ßons l\u0026rsquo;√©volution du temps d\u0026rsquo;ex√©cution de cherche_mot en fonction de la taille du texte pour une taille du mot fixe.\nfrom time import time from random import randint import matplotlib.pyplot as plt plt.style.use(\u0026#39;ggplot\u0026#39;) plt.rcParams[\u0026#39;figure.figsize\u0026#39;] = (15, 5) I, T_in, T_ch = [], [], [] mot = \u0026#39;\u0026amp;\u0026#39;*100 for i in range(10000,500000,10000) : texte = rockyou[:i] start = time() cherche_mot(mot,texte) stop = time() T_ch.append(stop-start) I.append(i) plt.figure(figsize = (15,5)) plt.plot(I,T_ch) plt.xlabel(\u0026#34;longeur du texte (longueur mot = moiti√© longueur texte)\u0026#34;) plt.ylabel(\u0026#34;temps d\u0026#39;ex√©cution (s)\u0026#34;) plt.title(\u0026#34;Temps d\u0026#39;excution de \u0026#39;cherche_mot\u0026#39; en fonction de la taille du texte\u0026#34;) Sur le m√™me mod√®le, vous allez tracer l\u0026rsquo;√©volution du temps d\u0026rsquo;ex√©cution de cherche_mot en fonction de la taille du mot pour une taille de texte fixe et pour des mots petits devant le texte.\n Pour cela vous compl√©terez le code ci-dessous.\n I, T_ch_mot = [], [] texte = rockyou[:200000] for i in range(1000,20000,1000) : # √† compl√©ter (i doit correspondre au nombre de caract√®res du mot) fig,ax = plt.subplots(figsize = (15,5)) ax.plot(I,T_ch_mot) ax.set(xlabel=\u0026#34;longueur du mot\u0026#34;, ylabel=\u0026#34;temps d\u0026#39;ex√©cution (s)\u0026#34;) ax.set_title(\u0026#34;Temps d\u0026#39;excution de \u0026#39;cherche_mot\u0026#39; en fonction de la longueur du mot\u0026#34;) Pour des petits mots par rapport au texte et en appelant $n$ la longueur du texte et $m$ la longueur du mot, quelle fonction semble-t-elle le mieux mod√©liser l\u0026rsquo;√©volution du temps d\u0026rsquo;ex√©cution en fonction de $n$ et $m$ ?\n A : $a\\times m + b\\times n$ o√π $a$ et $b$ sont des constantes B : $a\\times m^2$ o√π $a$ est une constante C : $a\\times n^2$ o√π $a$ est une constante D : $a\\times m\\times n$ o√π $a$ est une constante  ¬†Chercher un doublon La fonction suivante cherche si un √©l√©ment d\u0026rsquo;une liste se trouve en double et le cas √©ch√©ant, le retourne.\ndef cherche_duplicata(liste) : N = len(liste) for i in range(N) : for j in range(N) : if i != j and liste[i] == liste[j] : print(\u0026#39;Un √©l√©ment en double a √©t√© trouv√© :\u0026#39;) return liste[i] return \u0026#39;Pas de doublons trouv√©s üòû\u0026#39; liste_fruits = [\u0026#34;üçì\u0026#34;, \u0026#34;üçê\u0026#34;, \u0026#34;üçä\u0026#34;, \u0026#34;üçå\u0026#34;, \u0026#34;üçç\u0026#34;, \u0026#34;üçë\u0026#34;, \u0026#34;üçé\u0026#34;, \u0026#34;üçà\u0026#34;, \u0026#34;üçä\u0026#34;, \u0026#34;üçá\u0026#34;] a = cherche_duplicata(liste_fruits) print(a) Un √©l√©ment en double a √©t√© trouv√© :\nüçä\n Combien de fois la comparaison liste[i] == liste[j] est-elle op√©r√©e au maximum si la liste contient 200 √©l√©ments ?\n On peut ais√©ment am√©liorer la fonction en √©vitant de doubler les comparaisons :\ndef cherche_duplicata_bis(liste) : N = len(liste) for i in range(N-1) : for j in range(i+1,N) : if liste[i] == liste[j] : print(\u0026#39;Un √©l√©ment en double a √©t√© trouv√© :\u0026#39;) return liste[i] return \u0026#39;Pas de doublons trouv√©s üòû\u0026#39; liste_fruits = [\u0026#34;üçì\u0026#34;, \u0026#34;üçê\u0026#34;, \u0026#34;üçä\u0026#34;, \u0026#34;üçå\u0026#34;, \u0026#34;üçç\u0026#34;, \u0026#34;üçë\u0026#34;, \u0026#34;üçé\u0026#34;, \u0026#34;üçà\u0026#34;, \u0026#34;üçä\u0026#34;, \u0026#34;üçá\u0026#34;] a = cherche_duplicata(liste_fruits) print(a) Un √©l√©ment en double a √©t√© trouv√© :\nüçä\n Combien de comparaisons sont op√©r√©es au maximum avec cette nouvelle fonction si la liste contient 200 √©l√©ments ?\n # Pour vous aider √† raisonner N = 10 for i in range(N-1) : L = [] for j in range(i+1,N) : L.append((i,j)) print(L) [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9)]\n[(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9)]\n[(2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9)]\n[(3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9)]\n[(4, 5), (4, 6), (4, 7), (4, 8), (4, 9)]\n[(5, 6), (5, 7), (5, 8), (5, 9)]\n[(6, 7), (6, 8), (6, 9)]\n[(7, 8), (7, 9)]\n[(8, 9)]\nfrom random import randint I, T_dup, T_dup_bis = [], [], [] for i in range(200,5000,200) : L = [i for i in range(i)] start = time() cherche_duplicata(L) stop1 = time() cherche_duplicata_bis(L) stop2 = time() I.append(i) T_dup.append(stop1-start) T_dup_bis.append(stop2-stop1) fig,axs = plt.subplots(3,figsize = (15,15)) axs[0].plot(I,T_dup) axs[0].set_title(\u0026#34;cherche_duplicata\u0026#34;) axs[1].plot(I,T_dup_bis,c=\u0026#39;#3388BB\u0026#39;,label=\u0026#34;cherche_duplicata_bis\u0026#34;) axs[1].set_title(\u0026#34;cherche_duplicata_bis\u0026#34;) axs[2].plot(I,T_dup,label=\u0026#34;cherche_duplicata\u0026#34;) axs[2].plot(I,T_dup_bis,c=\u0026#39;#3388BB\u0026#39;,label=\u0026#34;cherche_duplicata_bis\u0026#34;) axs[2].set_title(\u0026#34;Comparaison\u0026#34;) axs[2].legend() On constate que m√™me si l\u0026rsquo;am√©lioration est visible entre les deux fonctions, le comportement g√©n√©ral (la classe de complexit√© comme on le verra plus tard) est identique.\n¬†Int√©gration num√©rique def trapeze(f, a, b): return (f(a) + f(b))/2 * (b - a) def rect_gauche(f, a, b): return f(a)*(b-a) def integrale(f, a, b, n, methode): p = (b-a)/n s = 0 for i in range(n) : s += methode(f,a+i*p,a+(i+1)*p) return s def f(x) : return np.cos(x)*x**2 + 10 import numpy as np import matplotlib.patches as patches a = -np.pi b = 3/2*np.pi x = np.linspace(a,b,2000) y = f(x) n_possibles = (6,10,20,50,200) fig,axs = plt.subplots(5,2,figsize=(20,20)) for k in range(5) : n = n_possibles[k] p = (b-a)/n I_rect = integrale(f,a,b,n,rect_gauche) I_trap = integrale(f,a,b,n,trapeze) for i in range(n) : rect = plt.Polygon(((a+i*p,0),(a+i*p,f(a+i*p)),(a+(i+1)*p,f(a+i*p)),(a+(i+1)*p,0),(a+i*p,0)),alpha=0.5,facecolor=\u0026#39;#9988DD\u0026#39;,edgecolor=\u0026#39;#9988DD\u0026#39;) trap = plt.Polygon(((a+i*p,0),(a+i*p,f(a+i*p)),(a+(i+1)*p,f(a+(i+1)*p)),(a+(i+1)*p,0),(a+i*p,0)),alpha=0.5,edgecolor=\u0026#39;#3388BB\u0026#39;) for j in range(2) : axs[k][j].plot(x,y,c=\u0026#39;#EE6666\u0026#39;) axs[k][0].add_patch(rect) axs[k][1].add_patch(trap) axs[k][0].text(0,4,s=f\u0026#39;I = {I_rect:.2f}\u0026#39;,fontsize=18,c=\u0026#39;w\u0026#39;,horizontalalignment=\u0026#39;center\u0026#39;) axs[k][1].text(0,4,s=f\u0026#39;I = {I_trap:.2f}\u0026#39;,fontsize=18,c=\u0026#39;w\u0026#39;,horizontalalignment=\u0026#39;center\u0026#39;) √Ä comparer √† : $$ \\int_{-\\pi}^{3\\pi/2}(x^2\\cos(x)+10)dx = 2+23\\pi-9\\frac{\\pi^2}{4}\\approx 52,05$$\n Pour quelle valeur de $n$, la valeur de $I$ atteint-elle 52 (√† 0,5 pr√®s) avec la m√©thode des rectangles √† gauche ?\nVous appelerez cette valeur n_cible et votre code devra l\u0026rsquo;afficher.\n "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/python/typesbase/",
	"title": "Types de base",
	"tags": [],
	"description": "",
	"content": "Types de base Les types de base en python (les cat√©gories fondamentales des objets manipul√©s) sont :\n  Les entiers int (en anglais, entier se dit integer).\nExemples : 1, 2, 1012, -18 etc. Leur pr√©cision est infinie et leur taille est illimit√©e en Python.\n   Les flottants float. Ce sont des approximations de nombres r√©els. La m√©thode d\u0026rsquo;√©criture en machine de ces nombres, √©quivalente √† une √©criture scientifique pour nombre binaire, explique leur nom : ce sont des nombres √† virgule flottante.\nExemples : 3.58, -0.0398, 2e-7, 3e4 (les puissances de dix, not√©s e ou E renvoient toujours des nombres flottants). Leur pr√©cision est limit√©e √† 53 bits, soit environ 16 chiffres significatifs en d√©cimal.\n C\u0026rsquo;est le point . qui sert de d√©marcation entre la partie enti√®re et la partie d√©cimale et non la virgule ,.\n   Les bool√©ens bool. Ce sont des variables √† deux √©tats, True ou False, permettant de repr√©senter des propositions logiques vraies ou fausses.\n  On peut convertir d\u0026rsquo;un type en l\u0026rsquo;autre en utilisant les fonctions natives int(), float() et bool().\nExemple :\n\u0026gt;\u0026gt;\u0026gt; int(5.8)\n5 int() donne la partie enti√®re d\u0026rsquo;un nombre flottant.\n \u0026gt;\u0026gt;\u0026gt; float(5)\n5.0\n\u0026gt;\u0026gt;\u0026gt; bool(0)\nFalse\n\u0026gt;\u0026gt;\u0026gt; bool(5.8)\nTrue N\u0026rsquo;importe quel nombre non nul (entier ou flottant) est consid√©r√© comme vrai.\n Op√©rations sur les entiers (int) Les entiers sont stables pour les op√©rations suivantes (le r√©sultat est un entier).\n¬†Addition + \u0026gt;\u0026gt;\u0026gt; 2+3\n5\n¬†Soustraction - \u0026gt;\u0026gt;\u0026gt; 2-3\n-1\n¬†Multiplication * \u0026gt;\u0026gt;\u0026gt; 2*3\n6\n¬†Division enti√®re // a//b donne le quotient de la division euclidienne de a par b.\n\u0026gt;\u0026gt;\u0026gt; 2//3\n0 Attention √† ne pas confondre avec la division d√©cimale /.\n Si on travaille avec des entiers, de pr√©cision infinie, il est contre-productif d\u0026rsquo;introduire des flottants en utilisant / plut√¥t que //.\n ¬†Modulo % a%b donne le reste de la division euclidienne de a par b.\n\u0026gt;\u0026gt;\u0026gt; 2%3\n1 L\u0026rsquo;op√©rateur modulo sert √©norm√©ment en informatique, notamment pour √©viter de d√©passer des valeurs (i%8 ne d√©passera jamais 7, quoi que valle i).\n Les op√©rations suivent les r√®gles de priorit√© habituelles, et on utilise les parenth√®ses pour les modifier :\n\u0026gt;\u0026gt;\u0026gt; 8//2*(2+2)\n16\nQue va donner 5*3%2 ? Et 5*(3%2) ?\n¬†Puissance ** \u0026gt;\u0026gt;\u0026gt; 2**3\n8\n On parle aussi d\u0026rsquo;op√©rateur d\u0026rsquo;exponentiation.\n Les puissances n√©gatives retournent des flottants.\n\u0026gt;\u0026gt;\u0026gt; 2**(-3)\n0.125\n ¬†Op√©rations sur les flottants (float) Du moment qu\u0026rsquo;un des deux nombres est un flottant, les op√©rations +, - et * donnent des flottants.\n Exemples :\n\u0026gt;\u0026gt;\u0026gt; 3-1.0\n2.0\n\u0026gt;\u0026gt;\u0026gt; 2e-3*500\n1.0\n\u0026gt;\u0026gt;\u0026gt; 2**(5/2)\n5.656854249492381\nLa pr√©cision limit√©e des flottants et le fait qu\u0026rsquo;ils soient d√©finis en binaire peut donner des r√©sultats surprenants.\nExemple :\n\u0026gt;\u0026gt;\u0026gt; 3*0.1\n0.30000000000000004\n La division d√©cimale / retourne un flottant m√™me avec deux entiers, et m√™me si le r√©sultat est entier :\n \u0026gt;\u0026gt;\u0026gt; 10/5\n2.0\n¬†Op√©rations sur les bool√©ens (bool) N√©gation logique (not) Sert √† nier une proposition :\n   P ¬¨P     F V   V F    a , b = True, False print(not a,not b) False True\nDisjonction logique (or)    P Q P ‚à® Q     V V V   V F V   F V V   F F F    print(True or True,True or False,False or True, False or False) True True True False\nConjonction logique (and)    P Q P ‚àß Q     V V V   V F F   F V F   F F F    print(True and True,True and False,False and True, False and False) True False False False\nnot est prioritaire devant and qui est prioritaire devant or.\nQue vaut False or not False and True ?\n ¬†Caract√®re paresseux des op√©rateurs or et and Lorsqu\u0026rsquo;on √©crit a or b, si a est vrai, alors Python ne s\u0026rsquo;emb√™te pas √† √©valuer b. Le r√©sultat est n√©cessairement vrai (cf. la table de v√©rit√©), et c\u0026rsquo;est donc ce qui est retourn√©.\nTrue or qu√©_pasa True\nDe m√™me, si a est faux, alors a and b retourne False sans √©valuer b.\nCe comportement peut s\u0026rsquo;av√©rer utile pour √©viter les erreurs.\nExemple : on veut tester si la premi√®re valeur d\u0026rsquo;une liste est positive. Appelons ce test Test. Si la liste est vide, l\u0026rsquo;expression Test va provoquer une erreur.\nOn ajoute alors un deuxi√®me test, Test_vide, qui n\u0026rsquo;est vrai que si la liste est vide. En utilisant l\u0026rsquo;expression (non Test_vide) and Test, on s\u0026rsquo;assure de ne pas lever d\u0026rsquo;erreur en cas de liste vide.\nPour en savoir plus sur l\u0026rsquo;alg√®bre de Boole :   ¬†Comparaisons Les diff√©rents comparateurs utilisables en Python sont :\n   comparateur signification     == √©gal √†   != diff√©rent de   \u0026gt; sup√©rieur √†   \u0026lt; inf√©rieur √†   \u0026gt;= sup√©rieur ou √©gal √†   \u0026lt;= inf√©rieur ou √©gal √†    Le r√©sultat d‚Äôune comparaison est un bool√©en.\nNe pas confondre l\u0026rsquo;op√©rateur d\u0026rsquo;affectation = et l\u0026rsquo;op√©rateur de comparaison ==.\n La pr√©cision finie des nombres flottants rend leur comparaison dangereuse :\n0.1**2 == 0.01 retourne False !\nSolution : utiliser un encadrement.\n0.1**2 \u0026gt; 0.01 - 1e-9 and 0.1**2 \u0026lt; 0.01 + 1e-9 renvoie bien True.\n Les op√©rateurs de comparaison sont prioritaires devant not, and et or.\nExemple : que vaut not 7.5 \u0026lt; 0.9 or 4 == 4 ?\n "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_1/",
	"title": "Semestre 1",
	"tags": [],
	"description": "",
	"content": "Semestre 1 Les seÃÅances de travaux pratiques du premier semestre poursuivent les objectifs suivants :\n consolider l‚Äôapprentissage de la programmation en langage Python qui a eÃÅteÃÅ entrepris dans les classes du lyceÃÅe¬†; mettre en place un environnement de travail¬†; mettre en place une discipline de programmation : speÃÅcification preÃÅcise des fonctions et programmes, annotations et commentaires, jeux de tests¬†; introduire les premiers eÃÅleÃÅments de complexiteÃÅ des algorithmes¬†; introduire des outils de validation : variants et invariants.  "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_2/complexite/",
	"title": "Complexit√©",
	"tags": [],
	"description": "",
	"content": "Complexit√© d\u0026rsquo;un algorithme Parmi les 3 questions qu\u0026rsquo;on peut se poser naturellement devant un algorithme (termine-t-il ? est-il correct ? combien de temps met-il ?), on a laiss√© la derni√®re en plan dans le chapitre pr√©c√©dent.\nLa question du temps mis par l\u0026rsquo;algorithme est le probl√®me de la complexit√© de l\u0026rsquo;algorithme.\nL\u0026rsquo;objectif premier d\u0026rsquo;un calcul de complexit√© algorithmique est de pouvoir comparer l‚Äôefficacit√© d‚Äôalgorithmes r√©solvant le m√™me probl√®me. Dans une situation donn√©e, cela permet donc d\u0026rsquo;√©tablir lequel des algorithmes disponibles est le meilleur (du point de vue temps d\u0026rsquo;ex√©cution).\n¬†  complexit√© en temps R√©aliser un calcul de complexit√© en temps revient √† d√©compter le nombre d‚Äôop√©rations √©l√©mentaires (affectation, calcul arithm√©tique ou logique, comparaison‚Ä¶) effectu√©es par l‚Äôalgorithme.\nPour rendre ce calcul r√©alisable, on √©mettra l\u0026rsquo;hypoth√®se que toutes les op√©rations √©l√©mentaires sont √† √©galit√© de co√ªt. En pratique ce n\u0026rsquo;est pas tout √† fait exact, mais cette approximation est cependant raisonnable.\nOn pourra donc estimer que le temps d\u0026rsquo;ex√©cution de l\u0026rsquo;algorithme est proportionnel au nombre d‚Äôop√©rations √©l√©mentaires.\nLa complexit√© $T(n)$ d\u0026rsquo;un algorithme va naturellement √™tre fonction de la taille $n$ des donn√©es pass√©es en entr√©e. Cette d√©pendance est logique, plus ces donn√©es seront volumineuses, plus il faudra d\u0026rsquo;op√©rations √©l√©mentaires pour les traiter.\nSouvent la complexit√© d√©pendra aussi de la donn√©e en elle m√™me et pas seulement de sa taille. En particulier la fa√ßon dont sont r√©parties les diff√©rentes valeurs qui la constituent.\nRappelons-nous par exemple l\u0026rsquo;algorithme de recherche s√©quentielle d‚Äôun √©l√©ment dans une liste non tri√©e du cours \u0026ldquo;structures de donn√©es\u0026rdquo;. Le principe de l\u0026rsquo;algorithme est simple, on parcourt un par un les √©l√©ments jusqu\u0026rsquo;√† trouver, ou pas, celui recherch√©. Ce parcours peut s‚Äôarr√™ter d√®s le d√©but si le premier √©l√©ment est \u0026ldquo;le bon\u0026rdquo;. Mais on peut √©galement √™tre amen√© √† parcourir la liste enti√®re si l‚Äô√©l√©ment cherch√© est en derni√®re position, ou m√™me n\u0026rsquo;y figure pas. Le nombre d\u0026rsquo;op√©rations √©l√©mentaires effectu√©es d√©pend donc non seulement de la taille de la liste, mais √©galement de la r√©partition de ses valeurs.\nCette remarque nous conduit √† pr√©ciser un peu notre d√©finition de la complexit√© en temps. En toute rigueur, on devra en effet distinguer trois formes de complexit√© en temps :\n  la complexit√© dans le meilleur des cas : c\u0026rsquo;est la situation la plus favorable, qui correspond par exemple √† la recherche d\u0026rsquo;un √©l√©ment situ√© √† la premi√®re postion d\u0026rsquo;une liste, ou encore au tri d\u0026rsquo;une liste d√©j√† tri√©e. la complexit√© dans le pire des cas : c\u0026rsquo;est la situation la plus d√©favorable, qui correspond par exemple √† la recherche d\u0026rsquo;un √©l√©ment dans une liste alors qu\u0026rsquo;il n\u0026rsquo;y figure pas, ou encore au tri par ordre croissant d\u0026rsquo;une liste tri√©e par ordre d√©croissant. la complexit√© en moyenne : on suppose l√† que les donn√©es sont r√©parties selon une certaine loi de probabilit√©s.   On calcule le plus souvent la complexit√© dans le pire des cas, car elle apporte une garantie (pas de mauvaises surprises en tablant sur le pire).\nDerni√®re chose importante √† prendre en consid√©ration, si la donn√©e est un nombre entier, la fa√ßon de le repr√©senter influera beaucoup sur l‚Äôappr√©ciation de la complexit√©.\nPar exemple, si $n=2020$, on peut consid√©rer que la taille de $n$ est :\nsoit la valeur de $n$ en elle-m√™me, fa√ßon la plus naturelle de voir les choses, c.-√†-d. $2020$,\nsoit le nombre de chiffres que comporte l\u0026rsquo;√©criture en binaire de $n$, c.-√†-d. 11,\nsoit le nombre de chiffres que comporte l\u0026rsquo;√©criture en d√©cimal de $n$, c.-√†-d. 4.\nVu la finalit√© informatique de nos algorithmes, nous devrions choisir le nombre de chiffres dans l\u0026rsquo;√©criture binaire de l\u0026rsquo;entier, mais par souci de simplicit√©, on consid√®rera le plus souvent la valeur de l\u0026rsquo;entier comme taille.\nN√©anmoins, lors de l\u0026rsquo;√©tude de la complexit√© des algorithmes arithm√©tiques (test de primalit√©, algorithme d\u0026rsquo;Euclide, etc.), la taille de l\u0026rsquo;entier est le param√®tre important et il faudra donc consid√©rer la taille de l\u0026rsquo;entr√©e $n$ comme √©tant $\\log_2(n)$.\nExemple : la fonction somme\n1def somme(L) : 2 s = 0 3 for e in L : 4 s += e 5 return s  Le calcul somme([1,2,3]) n√©cessite √† priori 4 op√©rations (1 fois la ligne 2, et 3 fois la ligne 4). Toutefois, la notion d\u0026rsquo;op√©ration √©l√©mentaire n\u0026rsquo;est pas pr√©cis√©ment d√©finie : on pourrait consid√©rer par exemple que la ligne 4 fait non pas une, mais deux op√©rations √©l√©mentaires (une somme puis une affectation) et alors somme([1,2,3]) n√©cessiterait 7 op√©rations.\n Cette impr√©cision est sans cons√©quence, car on estime la complexit√© \u0026ldquo;√† la louche\u0026rdquo;. Pour d√©finir formellement ce que signifie ce \u0026ldquo;√† la louche\u0026rdquo;, nous introduisons les trois notations suivantes :\n √âtant donn√© deux fonctions $\\mathbb{N}\\rightarrow \\mathbb{R}^*_+$ $f$ et $g$ : $f(n)$ est un grand $\\mathcal{O}$ de $g(n)$ s\u0026rsquo;il existe une constante $k_2$ telle que pour tout $n$ assez grand $f(n)‚â§k_2\\cdot g(n)$ ;\non note $f(n) = \\mathcal{O}(g(n))$. Et on dit que $g$ domine $f$ asymptotiquement.\n $f(n)$ est un grand $\\Omega$ de $g(n)$ s\u0026rsquo;il existe une constante $k_1\u0026gt;0$ telle que pour tout $n$ assez grand $k_1\\cdot g(n)‚â§f(n)$ ;\non note $f(n) = \\Omega(g(n))$.\n $f(n)$ est un grand $\\Theta$ de $g(n)$ s\u0026rsquo;il existe deux constantes $k_1\u0026gt;0$ et $k_2$ telles que pour tout $n$ assez grand $k_1\\cdot g(n)‚â§f(n)‚â§k_2\\cdot g(n)$ ;\non note $f(n) = \\Theta(g(n))$.\n$f$ et $g$ sont asymptotiquement du m√™me ordre de grandeur.\n Comme on l\u0026rsquo;a dit, notre souhait est de conna√Ætre le nombre d\u0026rsquo;√©tapes que n√©cessitera l\u0026rsquo;algorithme dans le pire des cas, quitte √† le surestimer. On veut par contre absolument √©viter de le sous-estimer ; on se concentre alors sur la premi√®re notation, grand $O$ (correspondant √† la majoration).\nEn effet, si on sait que $T(n)=O(g(n))$, on est alors assur√© que le nombre d\u0026rsquo;√©tapes $T(n)$ ne sera asymptotiquement jamais plus grand que $g(n)$ (asymptotiquement signifiant en pratique \u0026ldquo;pour des $n$ suffisamment grands\u0026rdquo;).\nExemple : $T(n)=5n+3$\nD√®s $n\u0026gt;3$, $T(n)\u0026lt;6n$, ce qu\u0026rsquo;on r√©√©crit $T(n)\u0026lt;6\\times g(n)$ avec $g(n)=n$, d\u0026rsquo;o√π' $T(n)=O(n)$.\nLes complexit√©s algorithmiques sont exprim√©es comme des grands $\\mathcal{O}$ ou grands $\\mathcal{\\Theta}$ des fonctions de r√©f√©rence. Cela va nous permettre de les classer.\nDes algorithmes appartenant √† une m√™me classe sont alors consid√©r√©s comme de complexit√© √©quivalente ; ils ont la m√™me efficacit√©.\nLe tableau suivant r√©capitule les complexit√©s de r√©f√©rence (rang√©es par ordre croissant) :\n   $\\mathcal{O}$ Type de complexit√©     $\\mathcal{O(1)}$ constant   $\\mathcal{O}(\\ln(n))$ logarithmique   $\\mathcal{O}(n)$ lin√©aire   $\\mathcal{O}(n\\times\\ln(n))$ quasi-lin√©aire   $\\mathcal{O}(n^2)$ quadratique   $\\mathcal{O}(n^3)$ cubique   $\\mathcal{O}(2^n)$ exponentiel   $\\mathcal{O}(n!)$ factoriel    Lors de la somme de deux complexit√©s de types diff√©rents, la classe de plus grande complexit√© domine.\nPar exemple : $\\mathcal{O}(n)+\\mathcal{O}(n^2)=\\mathcal{O}(n^2)$.\n Si $T(n)$ est un grand $O$ d\u0026rsquo;une certaine fonction $g$, alors il sera un grand $O$ de toutes les fonctions $h$ qui dominent $g$ (toutes les fonctions appartenant √† une classe de complexit√© sup√©rieure). Laquelle de ces classes d√©signe la complexit√© de $T(n)$ ?\nOn choisit toujours la plus petite classe possible pour d√©finir la classe de complexit√© de $T(n)$, car si on cherche bien √† se pr√©munir contre les mauvaises surprises, cela ne sert √† rien de s\u0026rsquo;assurer contre l\u0026rsquo;impossible (cela reviendrait √† toujours r√©pondre l\u0026rsquo;infini quand on nous demande une borne sup√©rieure, c\u0026rsquo;est certes vrai mais pas tr√®s utile\u0026hellip;).\n Moralit√©, quand on parle de grand $O$, la plupart du temps, il s\u0026rsquo;agit en fait de grand $Œò$.\n Dans l\u0026rsquo;exemple de $5n+3$, on a $T(n) = O(n)$, et par cons√©quent on a aussi $T(n)=O(n^2)$, $T(n)=O(n^3)$, etc.\nMais attention, quand on nous demande la complexit√© asymptotique au pire de $T(n)$, la r√©ponse attendue est bien $O(n)$ !\n¬†Ordres de grandeurs : en supposant qu\u0026rsquo;un syst√®me donn√© permette un milliard d\u0026rsquo;op√©rations par seconde (de type constant), on obtient les valeurs de temps d\u0026rsquo;ex√©cution suivantes en fonction du type de complexit√© et de la taille des donn√©es :\n   taille des donn√©es $\\ln n$ $n$ $n\\ln n$ $n^2$ $n^3$ $2^n$ $n!$     $10^2$ $5$ ns $100$ ns $500$ ns $10$ Œºs $1$ ms $4.10^{13}$ ans $3.10^{141}$ ans   $10^3$ $7$ ns $1$ Œºs $7$ Œºs $1$ ms $1$ s     $10^4$ $9$ ns $10$ Œºs $90$ Œºs $100$ ms $17$ min     $10^5$ $12$ ns $100$ Œºs $1,2$ ms $10$ s $12$ jours     $10^6$ $14$ ns $1$ ms $14$ ms $17$ min $32$ ans      ¬†Quelques relations utiles (valables pour toute constante $c$) :\n(1) $\\mathcal{O}(n+c)=\\mathcal{O}(n)$\n(2) $\\mathcal{O}(cn)=\\mathcal{O}(n)$\n(3) $\\mathcal{O}(n/c)=\\mathcal{O}(n)$\n(4) $\\mathcal{O}(c)=1$\n(5) $n\\times\\mathcal{O}(1)=\\mathcal{O}(n)$\n Exemples :\n Le calcul de la somme des $n$ premiers entiers √† l‚Äôaide d‚Äôune formule explicite (n*(n+1)//2) est de complexit√© constante. Ce m√™me calcul r√©alis√© de fa√ßon it√©rative gr√¢ce √† la fonction somme() est de complexit√© lin√©aire. En effet, la taille de l\u0026rsquo;entr√©e est $n=$ len(L) et la complexit√© est en : $$T(n)=\\underbrace{\\mathcal{O}(1)}_\\text{ligne 2}+\\underbrace{n\\times \\underbrace{\\mathcal{O}(1)}_\\text{ligne 4}}_{\\text{for}}=\\mathcal{O}(n)$$ L\u0026rsquo;algorithme de recherche par dichotomie (TP4) est de complexit√© logarithmique puisque l\u0026rsquo;algorithme n√©cessite au pire $\\log_2 n$ passages dans la boucle et chaque instruction dans la boucle (comparaison, division euclidienne, affectations) se fait en temps constant $$T(n)=\\log_2(n)\\times \\mathcal{O}(1) = \\mathcal{O}(\\ln n)$$  Plus tordu : trouvons la complexit√© de la fonction neufs() suivante qui calcule na√Øvement le plus grand nombre de 9 cons√©cutifs dans l\u0026rsquo;√©criture en base 10 de $n$.\ndef neufs(n) : L = [] while n!= 0 : L.append(n%10) n //= 10 M = 0 for k in range(len(L)) : i = k while i \u0026lt; len(L) and L[i]==9 : i += 1 M = max(M, i - k) return M  Chacune des instructions utilis√©es est en $\\mathcal{O}(1)$ (temps constant). On utilise bien max qui a une complexit√© lin√©aire, mais on ne l\u0026rsquo;utilise que sur 2 valeurs.\nOn passe dans le premier while une fois par chiffre de $n$ en base 10 (n//10 fait perdre un chiffre √† $n$), soit environ $\\log_{10}(n)$ fois.\nLa liste L contient alors (√† moins de 1 pr√®s) $\\log_{10}(n)$ valeurs. On passe dans le for $\\log_{10}(n)$ fois, et au pire le m√™me nombre de fois dans le second while.\nLa complexit√© est donc $T(n)=\\underbrace{\\log_{10}(n) \\times \\mathcal{O}(1)}_{\\text{premier while}}+\\underbrace{\\log_{10}(n) \\times\\log_{10}(n) \\times\\mathcal{O}(1)}_{\\text{boucles imbriqu√©es}}=\\mathcal{O}(\\ln ^2 n)$\n ¬†La complexit√© sert essentiellement √† comparer les algorithmes.\nOn peut aussi tenter de confirmer exp√©rimentalement nos conclusions en mesurant le temps mis par la machine pour faire tourner l\u0026rsquo;algorithme. Gr√¢ce au module time, on va ainsi pouvoir v√©rifier empiriquement que l\u0026rsquo;algorithme de recherche par dichotomie est bien meilleur que l\u0026rsquo;algorithme de recherche na√Øf. On va aussi tenter d\u0026rsquo;en savoir plus sur l\u0026rsquo;op√©rateur natif in qui accomplit la m√™me fonction.\nPour cela, on va mesurer le temps mis par les diff√©rentes m√©thodes pour chercher un nombre au hasard entre $0$ et $b$ dans une liste des $b$ premiers entiers. On moyenne ce temps en faisant $50\\,000$ essais avec des nombres √† rechercher diff√©rents. Puis on multiplie $b$ par $2$ et on recommence :\nimport random import time b, m = 1, 50000 print(\u0026#39;\\n| n | tps algo na√Øf | tps algo dicho | tps \u0026#34;in\u0026#34; |\u0026#39;) print(\u0026#39;-\u0026#39;*54) for i in range(12) : b *= 2 T = [i for i in range(0,b)] t1 = t2 = t3 = 0 for j in range(m) : x = random.randint(0,b) d1 = time.time() #time() note la valeur de l\u0026#39;horloge (en s) recherche_na√Øve(x,T) f1 = time.time() d2 = time.time() recherche_dicho(x,T) f2 = time.time() d3 = time.time() x in T f3 = time.time() t1 += f1 - d1 #f1-d1 = laps de temps qu\u0026#39;a dur√© la recherche lin√©aire t2 += f2 - d2 #f2-d2 = laps de temps qu\u0026#39;a dur√© la recherche dicho t3 += f3 - d3 #f3-d3 = laps de temps qu\u0026#39;a dur√© la recherche avec \u0026#34;in\u0026#34; print(\u0026#39;| {:\u0026gt;4d} |{:^15.2E}|{:^16.2E}|{:^12.2E}|\u0026#39;.format(b,t1/m,t2/m,t3/m)) | n | tps algo na√Øf | tps algo dicho | tps \u0026quot;in\u0026quot; | ------------------------------------------------------ | 2 | 3.56E-07 | 6.81E-07 | 1.90E-07 | | 4 | 4.04E-07 | 7.87E-07 | 2.12E-07 | | 8 | 4.58E-07 | 8.58E-07 | 2.38E-07 | | 16 | 5.86E-07 | 9.48E-07 | 2.80E-07 | | 32 | 8.11E-07 | 1.06E-06 | 3.60E-07 | | 64 | 1.30E-06 | 1.19E-06 | 5.37E-07 | | 128 | 2.25E-06 | 1.33E-06 | 8.83E-07 | | 256 | 4.18E-06 | 1.53E-06 | 1.57E-06 | | 512 | 8.09E-06 | 1.87E-06 | 2.96E-06 | | 1024 | 1.57E-05 | 2.14E-06 | 5.70E-06 | | 2048 | 3.09E-05 | 2.38E-06 | 1.12E-05 | | 4096 | 6.13E-05 | 2.63E-06 | 2.22E-05 | in est plus rapide que l\u0026rsquo;algo de recherche na√Øf mais ils r√©agissent tous deux pareil √† un changement d\u0026rsquo;√©chelle ; si on on multiplie n par 2, les deux algorithmes mettent 2 fois plus de temps. C\u0026rsquo;est ce qui nous montre qu\u0026rsquo;ils ont la m√™me complexit√© ! Pour la recherche dichotomique en revanche, une multiplication du nombre de valeur par 2 ne se solde pas par un doublement du temps, mais par l\u0026rsquo;ajout d\u0026rsquo;un temps constant seulement. C\u0026rsquo;est typique d\u0026rsquo;une complexit√© logarithmique. On remarque que\nL\u0026rsquo;op√©rateur in semble de complexit√© lin√©aire. Derri√®re ces deux petits caract√®res se cache donc du code loin d\u0026rsquo;√™tre de la complexit√© constante des op√©rations de base. Ce n\u0026rsquo;est pas la taille qui compte\u0026hellip;\n ¬†Complexit√© en espace La complexit√© en espace est quant √† elle la taille de la m√©moire n√©cessaire pour stocker les diff√©rentes structures de donn√©es utilis√©es lors de l\u0026rsquo;ex√©cution de l\u0026rsquo;algorithme.\nOn consid√®re pour simplifier qu\u0026rsquo;un type de base (un entier, un flottant, un caract√®re,\u0026hellip;) occupe une place en m√©moire constante (complexit√© en $\\mathcal{O}(1)$).\nExemples : Pour la fonction somme(), on constate que si la liste L contient des entiers ou des flottants, chaque variable interm√©diaire (e et s) contient un type de base, donc demande une place en m√©moire en $\\mathcal{O}(1)$ et donc la complexit√© en m√©moire au pire est en $\\mathcal{O}(1)$.\nPour la fonction neufs(), la complexit√© en m√©moire vient de la variable L (toutes les autres variables demandent $\\mathcal{O}(1)$ en m√©moire). Or cette variable va contenir environ $\\log_{10}(n)$ √©l√©ments d‚Äôo√π une complexit√© en m√©moire de $\\mathcal{O}(\\log_{10}(n)) = \\mathcal{O}(ln(n))$.\n¬† Retour sur les TP du premier semestre :\n TP 1 : quelle est la complexit√© des fonctions recherche, recherche_dico, max, maximum et max_2 ? TP 2 : quelle est la complexit√© de cherche_mot, cherche_duplicata et cherche_duplicata_bis ? TP 4 : quelle est la complexit√© de recherche_dicho_corr ? Et celle de racine en fonction du nombre de chiffres significatifs ? TP 6 : trier les algorithmes de tri en diff√©rentes cat√©gories de complexit√©.   Dans la vid√©o suivante, on compare plusieurs algorithmes dont la mission est de trouver un doublon dans une liste. Quel est le meilleur ? √âtudions leurs complexit√©s en temps et en espace.\n  "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_1/tp3data/",
	"title": "TP 3 : utilisation de modules",
	"tags": [],
	"description": "",
	"content": "L\u0026rsquo;id√©e de ce TP est de constater combien des modules/biblioth√®ques adapt√©s peuvent fournir des outils puissants et permettre un gain de temps gigantesque.\nOn va se placer dans un des champs les plus porteurs actuellement (et o√π python est tr√®s utilis√©), l\u0026rsquo;analyse de donn√©es.\nCliquez sur cette invitation pour r√©cup√©rer le repository du TP. Exploration d\u0026rsquo;un jeu de donn√©es Statistiques simples import pandas as pd # biblioth√®ques d√©di√©e au traitement de jeux de donn√©es import matplotlib.pyplot as plt # biblioth√®que graphique import seaborn as sns # biblioth√®que graphique reposant sur matplotlib et d√©di√©e plus particuli√®rement √† la repr√©sentation de jeux de donn√©es import numpy as np # biblioth√®que puissante permettant de g√©rer des tableaux multidimensionnels import plotly.express as px # libraire permettant des graphes interactifs import plotly.graph_objects as go # compl√©mentaire √† la premi√®re (seulement utile dans les cas complexes) Pour pouvoir √™tre import√©, un module doit avoir √©t√© pr√©alablement install√©. Les plus importants sont install√©s par d√©faut dans certaines distributions (comme Anaconda).\nLes gros modules sont g√©n√©ralement import√©s sous la forme import module as x o√π x est un raccourci pour le nom du module (np pour numpy ou plt pour matplotlib.pyplot). Se r√©f√©rer au cours Python pour les autres formes d\u0026rsquo;importation.\nPour obtenir de l\u0026rsquo;aide sur un module, on peut demander √† Python (help(pd) par exemple pour avoir de l\u0026rsquo;aide sur pandas ou help(pd.read_csv) pour avoir de l\u0026rsquo;aide sur la fonction sp√©cifique read_csv), mais il y a g√©n√©ralement beaucoup moins indigeste : l\u0026rsquo;aide en ligne des modules (pour Pandas par exemple).\n# param√®tres par d√©faut pour les graphes plt.rcParams[\u0026#39;figure.figsize\u0026#39;] = (15, 6) plt.rcParams[\u0026#39;font.family\u0026#39;] = \u0026#34;serif\u0026#34; plt.rcParams[\u0026#39;font.size\u0026#39;] = 13 sns.set_style(\u0026#34;white\u0026#34;) Le premier jeu de donn√©es qu\u0026rsquo;on va utiliser est issu du World Happiness report (une publication annuelle de l\u0026rsquo;ONU mesurant le degr√©s de bonheur de la population mondiale par pays √† partir de sondages).\nurl = \u0026#34;https://raw.githubusercontent.com/Info-TSI-Vieljeux/s1-tp3/main/2020.csv\u0026#34; data_monde = pd.read_csv(url,sep=\u0026#34;;\u0026#34;,index_col=0) # data_monde est une dataframe Pandas # Une dataframe est une sorte de dictionnaire dont les cl√©s sont les en-t√™tes des colonnes et dont les lignes sont index√©es. data_monde   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur √âcart-type PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue Score de bonheur en Distopie   Pays               Finland Western Europe 7.8087 0.031156 10.639267 0.954330 71.900825 0.949172 -0.059482 0.195445 1.972317   Denmark Western Europe 7.6456 0.033492 10.774001 0.955991 72.402504 0.951444 0.066202 0.168489 1.972317   Switzerland Western Europe 7.5599 0.035014 10.979933 0.942847 74.102448 0.921337 0.105911 0.303728 1.972317   Iceland Western Europe 7.5045 0.059616 10.772559 0.974670 73.000000 0.948892 0.246944 0.711710 1.972317   Norway Western Europe 7.4880 0.034837 11.087804 0.952487 73.200783 0.955750 0.134533 0.263218 1.972317   ... ... ... ... ... ... ... ... ... ... ...   Central African Republic Sub-Saharan Africa 3.4759 0.115183 6.625160 0.319460 45.200001 0.640881 0.082410 0.891807 1.972317   Rwanda Sub-Saharan Africa 3.3123 0.052425 7.600104 0.540835 61.098846 0.900589 0.055484 0.183541 1.972317   Zimbabwe Sub-Saharan Africa 3.2992 0.058674 7.865712 0.763093 55.617260 0.711458 -0.072064 0.810237 1.972317   South Sudan Sub-Saharan Africa 2.8166 0.107610 7.425360 0.553707 51.000000 0.451314 0.016519 0.763417 1.972317   Afghanistan South Asia 2.5669 0.031311 7.462861 0.470367 52.590000 0.396573 -0.096429 0.933687 1.972317    153 rows √ó 10 columns\n Pr√©cisions sur ces donn√©es :\n le score de bonheur est un score sur 10 correspondant √† la moyenne des r√©ponses des sond√©s (0 correspond √† la pire vie possible et 10 √† la meilleure) ce n\u0026rsquo;est pas le PIB par habitant mais son logarithme qui est utilis√© pour ne pas avoir des valeurs sur des ordres de grandeur trop diff√©rents d\u0026rsquo;une colonne √† l\u0026rsquo;autre entraide sociale : moyenne des r√©ponses √† la question binaire \u0026ldquo;en cas de difficult√©s, pouvez-vous compter sur de la famille ou des amis pour vous aider ?\u0026rdquo; (0 : non, 1 : oui) libert√© des choix de vie : moyenne des r√©ponses √† la question binaire \u0026ldquo;√™tes-vous satisfait ou non de votre libert√© √† choisir ce que vous voulez faire de votre vie ?\u0026rdquo; (0 : non, 1 : oui) g√©n√©rosit√© : moyenne des r√©ponses √† \u0026ldquo;Avez-vous donn√© √† une association caritative le mois dernier ?\u0026rdquo; ajust√©e par rapport au PIB par habitant (valeur r√©siduelle) corruption per√ßue : moyenne des r√©ponses √† la question binaire \u0026ldquo;la corruption est-elle r√©pandue dans le gouvernement ?\u0026rdquo; (0 : non, 1 : oui)  On simplifie un peu le jeu de donn√©es en retirant la colonne \u0026lsquo;√âcart-type\u0026rsquo; et \u0026lsquo;Score de bonheur en distopie\u0026rsquo; (score minimal obtenu).\ndata_monde.drop(columns=[\u0026#39;√âcart-type\u0026#39;,\u0026#39;Score de bonheur en Distopie\u0026#39;], inplace=True) data_monde.head(3)   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue   Pays             Finland Western Europe 7.8087 10.639267 0.954330 71.900825 0.949172 -0.059482 0.195445   Denmark Western Europe 7.6456 10.774001 0.955991 72.402504 0.951444 0.066202 0.168489   Switzerland Western Europe 7.5599 10.979933 0.942847 74.102448 0.921337 0.105911 0.303728     data_monde.tail(3)   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue   Pays             Zimbabwe Sub-Saharan Africa 3.2992 7.865712 0.763093 55.61726 0.711458 -0.072064 0.810237   South Sudan Sub-Saharan Africa 2.8166 7.425360 0.553707 51.00000 0.451314 0.016519 0.763417   Afghanistan South Asia 2.5669 7.462861 0.470367 52.59000 0.396573 -0.096429 0.933687     Tra√ßons un histogramme brut du jeu de donn√©es complet pour y voir plus clair (la librairie Seaborn rend cela tr√®s simple).\nsns.histplot(data=data_monde) La m√©thode describe s\u0026rsquo;appliquant √† des dataframe pandas retourne un r√©sum√© statistique tr√®s pratique des donn√©es de chaque colonne :\ndata_monde.describe()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue     count 153.00000 153.000000 153.000000 153.000000 153.000000 153.000000 153.000000   mean 5.47324 9.295706 0.808721 64.445529 0.783360 -0.014568 0.733120   std 1.11227 1.201588 0.121453 7.057848 0.117786 0.151809 0.175172   min 2.56690 6.492642 0.319460 45.200001 0.396573 -0.300907 0.109784   25% 4.72410 8.350645 0.737217 58.961712 0.714839 -0.127015 0.683019   50% 5.51500 9.456313 0.829204 66.305145 0.799805 -0.033665 0.783122   75% 6.22850 10.265124 0.906747 69.289192 0.877709 0.085429 0.849151   max 7.80870 11.450681 0.974670 76.804581 0.974998 0.560664 0.935585      Pour confirmer certaines des valeurs, vous allez construire diff√©rentes fonctions :\n une fonction decompte qui retourne le nombre d\u0026rsquo;√©l√©ments d\u0026rsquo;une liste, une fonction moyenne qui retourne la moyenne des √©l√©ments d\u0026rsquo;une liste, une fonction mediane qui retourne la m√©diane des √©l√©ments d\u0026rsquo;une liste tri√©e en ordre croissant.  L\u0026rsquo;utilisation de fonctions statistiques d√©j√† existantes est bien s√ªr prohib√©e.\n  Calculez, pour les 3 formes d\u0026rsquo;importation du module, l\u0026rsquo;√©cart-type des √©l√©ments de la liste Liste_scores en utilisant la fonction stdev du module statistics.\nIl s\u0026rsquo;agit d\u0026rsquo;√©valuer directement l\u0026rsquo;expresion (le nombre doit s\u0026rsquo;afficher sous la cellule sans utiliser de print).\n Tracons maintenant un diagramme en batons des scores de bonheur des 60 premiers pays.\nfig,ax = plt.subplots(figsize=(20,4)) sns.barplot(ax = ax,x = data_monde.index[:60], y = data_monde[\u0026#39;Score de bonheur\u0026#39;].head(60)) plt.xticks(rotation=90) ax.set_xlabel(\u0026#39;\u0026#39;) On remarque que les pays sont class√©s par score de bonheur d√©croissant dans le jeu de donn√©es d\u0026rsquo;origine.\nMais on peut √©videmment choisir un autre crit√®re de classement si on le d√©sire :\ndata_monde.sort_values(by=\u0026#34;PIB par habitant (log)\u0026#34;,ascending=True).head(10)   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue   Pays             Burundi Sub-Saharan Africa 3.7753 6.492642 0.490326 53.400002 0.626350 -0.017552 0.606935   Central African Republic Sub-Saharan Africa 3.4759 6.625160 0.319460 45.200001 0.640881 0.082410 0.891807   Congo (Kinshasa) Sub-Saharan Africa 4.3110 6.694256 0.672159 52.900002 0.700794 0.083638 0.809404   Niger Sub-Saharan Africa 4.9096 6.842167 0.617435 53.500095 0.759772 0.013861 0.722530   Liberia Sub-Saharan Africa 4.5579 7.054380 0.709281 56.096313 0.735269 0.042273 0.856376   Malawi Sub-Saharan Africa 3.5380 7.062226 0.544007 57.592888 0.803223 0.021433 0.731701   Mozambique Sub-Saharan Africa 4.6236 7.069346 0.723874 54.205822 0.864452 0.032376 0.683019   Sierra Leone Sub-Saharan Africa 3.9264 7.268803 0.636142 50.865143 0.715315 0.088661 0.861331   Madagascar Sub-Saharan Africa 4.1656 7.281686 0.668196 59.105427 0.557574 -0.011824 0.817486   Gambia Sub-Saharan Africa 4.7506 7.321815 0.693169 55.012016 0.733163 0.343199 0.690718     data_monde.sort_values(by=\u0026#34;Corruption per√ßue\u0026#34;,ascending=False).head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue   Pays             Bulgaria Central and Eastern Europe 5.1015 9.869319 0.937840 66.803978 0.745178 -0.143908 0.935585   Romania Central and Eastern Europe 6.1237 10.107584 0.825162 67.207237 0.842823 -0.197815 0.934300   Bosnia and Herzegovina Central and Eastern Europe 5.6741 9.455817 0.829204 67.808136 0.651353 0.098275 0.933769   Afghanistan South Asia 2.5669 7.462861 0.470367 52.590000 0.396573 -0.096429 0.933687   Kosovo Central and Eastern Europe 6.3252 9.204430 0.820727 63.885555 0.861536 0.190934 0.922328     data_monde.sort_values(by=\u0026#34;G√©n√©rosit√©\u0026#34;,ascending=False).iloc[[45]]   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue   Pays             Denmark Western Europe 7.6456 10.774001 0.955991 72.402504 0.951444 0.066202 0.168489     D\u0026rsquo;apr√®s la cellule pr√©c√©dente, le 46e (le 1er est √† l\u0026rsquo;indice 0) meilleur score de g√©n√©rosit√© appartient au Danemark.\n Quel pays correspond √† la 59e plus courte esp√©rance de vie en bonne sant√© ?\n On peut aussi ais√©ment filtrer le jeu de donn√©es en fonction de n\u0026rsquo;importe quel crit√®re :\ndata_monde[(data_monde[\u0026#34;Esp√©rance de vie en bonne sant√©\u0026#34;]\u0026gt;60) \u0026amp; (data_monde[\u0026#34;Esp√©rance de vie en bonne sant√©\u0026#34;]\u0026lt;61)] # Rq : pandas n√©cessite les op√©rateurs logiques bit √† bit \u0026#39;\u0026amp;\u0026#39; (et) et \u0026#39;|\u0026#39; (ou)  # plut√¥t que les op√©rateurs √©l√©ment par √©l√©ment \u0026#39;and\u0026#39; et \u0026#39;or\u0026#39; qui l√®veraient une erreur.   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue   Pays             Kenya Sub-Saharan Africa 4.5830 8.029776 0.702652 60.096931 0.829748 0.294682 0.831499   India South Asia 3.5733 8.849824 0.592201 60.215187 0.881445 0.057552 0.772043      Quel pays poss√®de un score de bonheur inf√©rieur √† 5 malgr√© une valeur de corruption per√ßue inf√©rieure √† 0.5 ?\n Pour r√©cup√©rer l\u0026rsquo;ensemble des donn√©es d\u0026rsquo;un pays en particulier, on utilise :\ndata_monde.loc[\u0026#39;France\u0026#39;] R√©gion du monde Western Europe Score de bonheur 6.6638 PIB par habitant (log) 10.584223 Entraide sociale 0.937104 Esp√©rance de vie en bonne sant√© 73.801933 Libert√© des choix de vie 0.825468 G√©n√©rosit√© -0.130642 Corruption per√ßue 0.583521 Name: France, dtype: object Pour chaque variable mesur√©e (chaque colonne), on peut facilement tracer des histogrammes illustrant la r√©partition des valeurs.\nsns.displot(data_monde, x=\u0026#34;Score de bonheur\u0026#34;, bins=20, kde=True, height=4, aspect=3) # bins contr√¥le le nombre de classes On peut faciliter la lecture des graphes en les rendant interactif.\nOn utilise pour cela la biblioth√®que Plotly express qui sait (comme seaborn) parler √† une dataframe pandas.\nOn peut zoomer sur ces graphiques interactifs et obtenir des informations en survolant avec le curseur.\npx.histogram(data_monde,\u0026#39;Corruption per√ßue\u0026#39;,nbins=40,title=\u0026#34;Corruption per√ßue\u0026#34;) # Cette fois-ci, le nombre de classes est d√©sign√© par nbins.     Plotly.d3.json(\"/corrup.json\", function(err, fig) { Plotly.plot('\\/corrup.json', fig.data, fig.layout, {responsive: true}); }); \n Modifez le graphe pr√©cedent pour r√©pondre √† cette question : combien la classe la plus peupl√©e de l\u0026rsquo;histogramme de l\u0026rsquo;esp√©rence de vie en bonne sant√© compte-elle de valeurs si l\u0026rsquo;histogramme comporte 30 classes ?\n ¬†Regroupement des donn√©es On remarque que le jeu de donn√©es contient une colonne cat√©gorielle : \u0026ldquo;R√©gion du monde\u0026rdquo;.\nCela va nous permettre d\u0026rsquo;explorer de possibles dynamiques r√©gionales : est-ce que les pays d\u0026rsquo;une m√™me zone ont des indicateurs semblables ?\npd.unique(data_monde[\u0026#34;R√©gion du monde\u0026#34;]) # permet d\u0026#39;afficher une seule fois chacune des valeurs diff√©rentes de la colonne array(['Western Europe', 'North America and ANZ','Middle East and North Africa', 'Latin America and Caribbean','Central and Eastern Europe', 'East Asia', 'Southeast Asia','Commonwealth of Independent States', 'Sub-Saharan Africa','South Asia'], dtype=object)\nTra√ßons des diagrammes en bo√Æte √† moustaches repr√©sentant les scores de bonheur pour chacune des r√©gions.\nConstruction des bo√Ætes √† moustaches (ou diagrammes en bo√Ætes de Tukey) :\nLes fronti√®res de la boites sont form√©es des premier Q1 et troisi√®me quartile Q3 et la barre dans la boite correspond √† la m√©diane (50% des valeurs sont donc dans la bo√Æte).\nPour les moustaches, on calcule d\u0026rsquo;abord 1,5 fois la distance interquartile entre le premier et le troisi√®me quartile (la longueur de la bo√Æte) : L=1,5√ó(Q3-Q1). Si les valeurs ne s\u0026rsquo;√©tendent pas au-del√† de Q1-L et Q3+L, on trace les moustaches aux valeurs min et max. Sinon, on trace les moustaches au niveau des valeurs pr√©c√©dant imm√©diatement la limite. Les valeurs au-del√† sont repr√©sent√©es par des points et sont le plus souvent consid√©r√©es comme des anomalies.\n √Ä nouveau Seaborn rend cela tr√®s simple\u0026hellip;\nsns.set_style(\u0026#34;white\u0026#34;) fig, ax = plt.subplots(figsize=(12,8)) sns.boxplot(ax = ax, x=\u0026#34;Score de bonheur\u0026#34;, y=\u0026#34;R√©gion du monde\u0026#34;, palette=\u0026#34;husl\u0026#34;, data=data_monde) sns.despine(offset=10, trim=True) ax.set_ylabel(\u0026#39;\u0026#39;) Tra√ßons maintenant un graphe plus g√©n√©ral repr√©sentant toutes les relations possibles entre deux axes du jeu de donn√©es pour voir si certaines combinaisons discriminent plus nettement les diff√©rentes r√©gions.\n# Un peu long √† s\u0026#39;ex√©cuter (environ 30 s) g = sns.pairplot(data_monde, hue=\u0026#34;R√©gion du monde\u0026#34;, corner=True) g._legend.set_bbox_to_anchor((0.6, 0.8)) On constate que les groupes r√©gionaux sont relativement homog√®nes pour la plupart des crit√®res.\nZoomons sur un de ces graphes :\nsns.set_style(\u0026#34;whitegrid\u0026#34;) sns.jointplot(data=data_monde,x=\u0026#34;PIB par habitant (log)\u0026#34;, y=\u0026#34;Score de bonheur\u0026#34;, hue=\u0026#34;R√©gion du monde\u0026#34;, kind=\u0026#39;scatter\u0026#39;, height=8, legend=False) Une version interactive du m√™me graphique permet de consulter les informations pour chaque point :\npx.scatter(data_monde,x=\u0026#39;PIB par habitant (log)\u0026#39;, y=\u0026#39;Score de bonheur\u0026#39;, hover_name=data_monde.index, color=\u0026#39;R√©gion du monde\u0026#39;)    Plotly.d3.json(\"/zoompairplot.json\", function(err, fig) { Plotly.plot('\\/zoompairplot.json', fig.data, fig.layout, {responsive: true}); });   Trouvez la r√©gion du monde repr√©sent√©e sur le graphe suivant (le graphe interactif permet de trouver la r√©ponse facilement).  Allons maintenant au-del√† de la proximit√© g√©ographique pour regrouper les pays en 3 grands blocs socio√©conomiques : \u0026ldquo;Nord\u0026rdquo;, \u0026ldquo;Sud\u0026rdquo;, \u0026ldquo;Interm√©diaire\u0026rdquo;.\nconditions = [(data_monde[\u0026#39;R√©gion du monde\u0026#39;] == \u0026#39;Western Europe\u0026#39;) | (data_monde[\u0026#39;R√©gion du monde\u0026#39;] == \u0026#39;North America and ANZ\u0026#39;),(data_monde[\u0026#39;R√©gion du monde\u0026#39;] == \u0026#39;South Asia\u0026#39;) | (data_monde[\u0026#39;R√©gion du monde\u0026#39;] == \u0026#39;Sub-Saharan Africa\u0026#39;)] choix = [\u0026#39;\u0026#34;Nord\u0026#34;\u0026#39;, \u0026#39;\u0026#34;Sud\u0026#34;\u0026#39;] data_monde[\u0026#39;Groupe\u0026#39;] = np.select(conditions, choix, default=\u0026#39;Autres\u0026#39;) deux_gpes = data_monde[data_monde[\u0026#34;Groupe\u0026#34;].isin([\u0026#39;\u0026#34;Nord\u0026#34;\u0026#39;,\u0026#39;\u0026#34;Sud\u0026#34;\u0026#39;])] # Un peu long √† s\u0026#39;ex√©cuter (environ 30 s) sns.set_style(\u0026#34;white\u0026#34;) g = sns.PairGrid(data_monde, diag_sharey=False, hue=\u0026#34;Groupe\u0026#34;) g.map_upper(sns.scatterplot) g.map_lower(sns.kdeplot,common_norm=False) g.map_diag(sns.histplot,bins=20,kde=True) g.add_legend(title=\u0026#34;Grands groupes\u0026#34;,adjust_subtitles=True) L\u0026rsquo;homog√©n√©it√© de ces 3 groupes saute aux yeux.\n¬†Corr√©lations Les graphiques pr√©c√©dents mettent en √©vidence des corr√©lations assez fortes entre certaines grandeurs.\nCreusons un peu.\ng = sns.PairGrid(data_monde, y_vars=[\u0026#34;Score de bonheur\u0026#34;], x_vars=[\u0026#34;PIB par habitant (log)\u0026#34;, \u0026#34;Corruption per√ßue\u0026#34;], height=7, aspect=1.5) g.map(sns.regplot) On constate sur cet exemple que le score de bonheur est corr√©l√© positivement avec le PIB par habitant et n√©gativement avec le degr√© de corruption per√ßue.\nPour avoir un panorama complet, tra√ßons la matrice de corr√©lation donnant, pour chaque couple de variable, la valeur du coefficient de corr√©lation $r$ (valeur entre -1 et 1 traduisant le degr√© de d√©pendance lin√©aire entre deux variables) :\nfig, ax = plt.subplots(figsize=(12,10)) cmap = sns.diverging_palette(0, 230, 90, 60, as_cmap=True).reversed() # choix de la palette de couleurs sns.heatmap(data_monde.iloc[:,1:].corr(), cmap=cmap, center=0, annot=True, fmt=\u0026#34;.2f\u0026#34;, linewidth = 0.5, ax=ax)  Citez les deux variables les moins corr√©l√©es entre elles (donner les noms exacts tels qu\u0026rsquo;ils apparaissent dans les donn√©es, attention √† la casse). L\u0026rsquo;ordre des variables n\u0026rsquo;est pas important.\n ¬†Fin du TP3a\n Un chou√Øa d\u0026rsquo;apprentissage automatique (machine learning) On a vu qu\u0026rsquo;un regroupement des donn√©es en 3 grands groupes \u0026ldquo;Nord\u0026rdquo;, \u0026ldquo;Sud\u0026rdquo; et \u0026ldquo;Interm√©diaire\u0026rdquo; semble plut√¥t coh√©rent.\nMais pourquoi pas laisser un algorithme d√©cider lui-m√™me de qui va le mieux ensemble ? Ensuite nous pourrons v√©rifier si cela recoupe notre d√©coupage fait √† la main.\nOn appelle cela un apprentissage non supervis√©.\nNous allons utiliser l\u0026rsquo;algorithme des k-moyennes pour partitionner automatiquement nos donn√©es.\nIl consiste √† placer chaque point de donn√©es dans un espace √† $n$ dimensions o√π $n$ est le nombre de variables (les descripteurs) et chercher √† les regrouper en clusters en fonction de leurs distances.\nChaque variable correspondant √† un axe du rep√®re.\nPour aider l\u0026rsquo;algorithme, on peut tenter de r√©duire la dimension de l\u0026rsquo;espace dans lequel chaque point de donn√©es est plong√© en utilisant une analyse en composantes principales.\nL\u0026rsquo;id√©e est de d√©terminer les combinaisons des diff√©rentes variables expliquant le mieux la variance des donn√©es. Chaque nouvel axe ainsi form√© (les composantes principales) explique une part d√©croissante mais compl√©mentaire de la variance (sur la deuxi√®me composante, les donn√©es sont moins √©tal√©es que sur la premi√®re, mais elles s\u0026rsquo;√©talent dans une direction orthogonale, et ainsi de suite).\nProjeter les donn√©es sur les premi√®res composantes permet de les √©taler le plus possible. On peut ainsi r√©duire l\u0026rsquo;espace √† n dimensions du d√©part √† un espace de seulement 2 ou 3 dimensions expliquant la majorit√© de la variance des donn√©es.\nL\u0026rsquo;animation suivante montre comment serait s√©lectionn√© l\u0026rsquo;axe de la composante principale dans un espace √† deux dimensions : il correspond √† la position de la droite pour laquelle la distance cumul√©e de tous les points √† la droite est la plus grande.\nLa biblioth√®que Scikit-learn, destin√©e √† l\u0026rsquo;apprentissage automatique, contient tout ce qu\u0026rsquo;il nous faut :\nfrom sklearn.decomposition import PCA # l\u0026#39;algorithme d\u0026#39;analyse en composantes principales (PCA en anglais) from sklearn.preprocessing import StandardScaler # pour centrer-r√©duire les donn√©es from sklearn.cluster import KMeans # l\u0026#39;algorithme des k-moyennes variables = data_monde.columns.values[1:-1] scaler = StandardScaler() X = scaler.fit_transform(data_monde[variables]) # chaque vecteur correspondant √† chacune des variables est maintenant centr√©-r√©duit pca = PCA() components = pca.fit_transform(X) Quelle combinaison des variables de d√©part utilise la premi√®re composante ?\ndata = data_monde.copy() # pour pouvoir revenir sur le graphe suivant m√™me apr√®s ajout de colonnes √† data_monde n_c = 1 # num√©ro de la composante principale √† d√©crire px.bar(components.T, x=data.columns.values[1:-1], y=n_c-1, labels={f\u0026#34;{n_c-1}\u0026#34;: f\u0026#34;Composante Principale (CP) {n_c}\u0026#34;})    Plotly.d3.json(\"/compppale.json\", function(err, fig) { Plotly.plot('\\/compppale.json', fig.data, fig.layout, {responsive: true}); });   Quelle est le nom de la variable participant le plus √† la composante principale n¬∞34 ?\n Repr√©sentons le pourcentage de variance expliqu√©e par chacune des composantes :\nexp_var_cumul = np.cumsum(pca.explained_variance_ratio_) fig = px.bar(x=range(1, exp_var_cumul.shape[0] + 1),y=pca.explained_variance_ratio_,labels={\u0026#34;x\u0026#34;: \u0026#34;composante\u0026#34;, \u0026#34;y\u0026#34;: \u0026#34;% variance expliqu√©e\u0026#34;}) fig.add_scatter(x=list(range(1, exp_var_cumul.shape[0] + 1)), y=exp_var_cumul, name=\u0026#34;\u0026#34;, showlegend=False)    Plotly.d3.json(\"/explvariance.json\", function(err, fig) { Plotly.plot('\\/explvariance.json', fig.data, fig.layout, {responsive: true}); }); \nLes trois premi√®res composantes expliquent plus de 80% de la variance !\nPla√ßons les donn√©es dans un espace r√©duit √† ces 3 dimensions :\npx.scatter_3d(components, x=0, y=1, z=2, color=data_monde[\u0026#39;Groupe\u0026#39;], labels={\u0026#39;0\u0026#39;: \u0026#39;CP 1\u0026#39;, \u0026#39;1\u0026#39;: \u0026#39;CP 2\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;CP 3\u0026#39;}, hover_name=data_monde.index)    Plotly.d3.json(\"/scat3Dgpe.json\", function(err, fig) { Plotly.plot('\\/scat3Dgpe.json', fig.data, fig.layout, {responsive: true}); });  On constate √† nouveau que nos 3 groupes discriminent plut√¥t tr√®s bien nos donn√©es m√™me si quelques chevauchements existent.\nC\u0026rsquo;est le moment d\u0026rsquo;utiliser l\u0026rsquo;algorithme des k-moyennes pour essayer de former 3 groupes homog√®nes :\n# on ne garde que les 3 premi√®res composantes principales pca = PCA(n_components = 3) pca.fit(X) score_pca = pca.transform(X) kmeans_pca = KMeans(n_clusters=3,init=\u0026#39;k-means++\u0026#39;,random_state=42) kmeans_pca.fit(score_pca) data_monde[\u0026#34;Cluster\u0026#34;]=kmeans_pca.labels_.astype(str) data_monde.head(3)   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue Groupe Cluster   Pays               Finland Western Europe 7.8087 10.639267 0.954330 71.900825 0.949172 -0.059482 0.195445 \"Nord\" 2   Denmark Western Europe 7.6456 10.774001 0.955991 72.402504 0.951444 0.066202 0.168489 \"Nord\" 2   Switzerland Western Europe 7.5599 10.979933 0.942847 74.102448 0.921337 0.105911 0.303728 \"Nord\" 2     fig = px.scatter_3d(components, x=0, y=1, z=2, color=data_monde[\u0026#39;Cluster\u0026#39;], labels={\u0026#39;0\u0026#39;: \u0026#39;CP 1\u0026#39;, \u0026#39;1\u0026#39;: \u0026#39;CP 2\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;CP 3\u0026#39;}, color_discrete_sequence=px.colors.qualitative.Bold, hover_name=data_monde.index) fig.update_layout(legend_title = \u0026#34;Cluster\u0026#34;)    Plotly.d3.json(\"/scat3Dclust.json\", function(err, fig) { Plotly.plot('\\/scat3Dclust.json', fig.data, fig.layout, {responsive: true}); });  Les 3 clusters cr√©√©s reproduisent √† peu de chose pr√®s les 3 groupes \u0026ldquo;Nord\u0026rdquo;, \u0026ldquo;Sud\u0026rdquo;, \u0026ldquo;Interm√©diaire\u0026rdquo; construits √† la main.\n √Ä quel cluster correspondent approximativement les pays du groupe \u0026ldquo;Sud\u0026rdquo; ?\n Mais l\u0026rsquo;accord n\u0026rsquo;est pas parfait !\n Citez un pays qui appartient au groupe \u0026ldquo;Nord\u0026rdquo; mais qui n\u0026rsquo;appartient pas au cluster lui correspondant.\n Nous allons voir dans la prochaine partie du TP comment repr√©senter ces donn√©es sur une carte pour y voir plus clair.\n¬†Fin du TP3b\n Un peu de g√©ographie Le module suivant va permettre d\u0026rsquo;ajouter √† nos donn√©es le code √† 3 lettres (SO 3166-1 alpha-3) de chaque pays.\nMais pourquoi donc ? plotly express permet de tracer la carte d\u0026rsquo;un pays directement √† partir de ce petit code de 3 lettres !\nimport country_converter as coco iso3 = coco.convert(names=data_monde.index, to=\u0026#39;ISO3\u0026#39;, not_found=None) data_monde[\u0026#34;code\u0026#34;] = iso3 data_monde.head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue Groupe Cluster code   Pays                Finland Western Europe 7.8087 10.639267 0.954330 71.900825 0.949172 -0.059482 0.195445 \"Nord\" 2 FIN   Denmark Western Europe 7.6456 10.774001 0.955991 72.402504 0.951444 0.066202 0.168489 \"Nord\" 2 DNK   Switzerland Western Europe 7.5599 10.979933 0.942847 74.102448 0.921337 0.105911 0.303728 \"Nord\" 2 CHE   Iceland Western Europe 7.5045 10.772559 0.974670 73.000000 0.948892 0.246944 0.711710 \"Nord\" 2 ISL   Norway Western Europe 7.4880 11.087804 0.952487 73.200783 0.955750 0.134533 0.263218 \"Nord\" 2 NOR     fig = px.choropleth(data_monde, locations = \u0026#34;code\u0026#34;, color = \u0026#34;Score de bonheur\u0026#34;, projection = \u0026#34;orthographic\u0026#34;, color_continuous_scale = \u0026#34;Spectral_r\u0026#34;, hover_name = data_monde.index, hover_data = {\u0026#34;code\u0026#34; : False}) fig.update_geos( showland = True, landcolor = \u0026#34;LightGrey\u0026#34;, showocean = True, oceancolor = \u0026#34;LightBlue\u0026#34;, showlakes = True, lakecolor = \u0026#34;LightBlue\u0026#34;, showframe = False) fig.update_layout(margin={\u0026#34;r\u0026#34;:0,\u0026#34;t\u0026#34;:0,\u0026#34;l\u0026#34;:0,\u0026#34;b\u0026#34;:0}) fig.show()    Plotly.d3.json(\"/cartechoro1.json\", function(err, fig) { Plotly.plot('\\/cartechoro1.json', fig.data, fig.layout, {responsive: true}); });  On est maintenant par√© pour repr√©senter les 3 clusters obtenus par l\u0026rsquo;algo des k-moyennes du tp3b.\ndata_monde[\u0026#34;Cluster\u0026#34;] = [f\u0026#39;n¬∞{cluster}\u0026#39; for cluster in data_monde[\u0026#34;Cluster\u0026#34;].astype(\u0026#39;int64\u0026#39;) if cluster != \u0026#39;nan\u0026#39;] data_monde.head(1)   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    R√©gion du monde Score de bonheur PIB par habitant (log) Entraide sociale Esp√©rance de vie en bonne sant√© Libert√© des choix de vie G√©n√©rosit√© Corruption per√ßue Groupe Cluster code   Pays                Finland Western Europe 7.8087 10.639267 0.95433 71.900825 0.949172 -0.059482 0.195445 \"Nord\" n¬∞2 FIN     fig = px.choropleth(data_monde, locations = \u0026#34;code\u0026#34;, color = \u0026#34;Cluster\u0026#34;, projection = \u0026#34;natural earth\u0026#34;, color_discrete_sequence = px.colors.qualitative.Set2, hover_name = data_monde.index, hover_data = {\u0026#34;code\u0026#34; : False} ) #fig.update_geos(fitbounds=\u0026#34;locations\u0026#34;, visible=True) fig.update_layout(margin = {\u0026#34;r\u0026#34;:0,\u0026#34;t\u0026#34;:0,\u0026#34;l\u0026#34;:0,\u0026#34;b\u0026#34;:0}) fig.update_geos(showframe = False) fig.show()    Plotly.d3.json(\"/cartechoro2.json\", function(err, fig) { Plotly.plot('\\/cartechoro2.json', fig.data, fig.layout, {responsive: true}); });  Terminons en fabriquant une carte r√©gionale.\npd.unique(data_monde[\u0026#34;R√©gion du monde\u0026#34;]) array(['Western Europe', 'North America and ANZ','Middle East and North Africa', 'Latin America and Caribbean','Central and Eastern Europe', 'East Asia', 'Southeast Asia','Commonwealth of Independent States', 'Sub-Saharan Africa','South Asia'], dtype=object)\nregion = data_monde[data_monde[\u0026#34;R√©gion du monde\u0026#34;] == \u0026#34;Middle East and North Africa\u0026#34;] fig = px.choropleth(region, locations = \u0026#34;code\u0026#34;, color = \u0026#34;Score de bonheur\u0026#34;, projection = \u0026#34;natural earth\u0026#34;, color_continuous_scale = \u0026#34;Temps\u0026#34;, hover_name = region.index, hover_data = {\u0026#34;code\u0026#34; : False} ) fig.update_geos(fitbounds = \u0026#34;locations\u0026#34;, visible = True) fig.update_layout(margin = {\u0026#34;r\u0026#34;:0,\u0026#34;t\u0026#34;:0,\u0026#34;l\u0026#34;:0,\u0026#34;b\u0026#34;:0}) fig.update_geos(showframe = False, resolution = 50) fig.show()    Plotly.d3.json(\"/cartechoro3.json\", function(err, fig) { Plotly.plot('\\/cartechoro3.json', fig.data, fig.layout, {responsive: true}); });   Modifiez les cellules qui pr√©c√®dent pour que le graphique ci-dessus affiche la carte du score de g√©n√©rosit√© des pays d\u0026rsquo;Asie du sud-est.\n  De quelle couleur est le Vietnam sur cette carte ?\n ¬†Fin du TP3c\n S√©rie temporelle Utilisons un nouveau jeu de donn√©es comprenant des relev√©s de consommation √©lectrique allemands entre 2006 et 2018 :\nurl = \u0026#34;http://cordier-phychi.toile-libre.org/Info/github/elec_allemagne.csv\u0026#34; serie_temp = pd.read_csv(url,sep=\u0026#34;,\u0026#34;) serie_temp.drop(columns=\u0026#34;Wind+Solar\u0026#34;,inplace=True) serie_temp   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    Date Consumption Wind Solar     0 2006-01-01 1069.18400 NaN NaN   1 2006-01-02 1380.52100 NaN NaN   2 2006-01-03 1442.53300 NaN NaN   3 2006-01-04 1457.21700 NaN NaN   4 2006-01-05 1477.13100 NaN NaN   ... ... ... ... ...   4378 2017-12-27 1263.94091 394.507 16.530   4379 2017-12-28 1299.86398 506.424 14.162   4380 2017-12-29 1295.08753 584.277 29.854   4381 2017-12-30 1215.44897 721.247 7.467   4382 2017-12-31 1107.11488 721.176 19.980    4383 rows √ó 4 columns\n Petit toilettage des donn√©es : on transforme les valeurs de la colonne des dates en un type date reconnu par pandas et on les utilise comme index.\nserie_temp[\u0026#39;Date\u0026#39;] = pd.to_datetime(serie_temp[\u0026#39;Date\u0026#39;]) serie_temp = serie_temp.set_index(\u0026#39;Date\u0026#39;) serie_temp.head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    Consumption Wind Solar   Date        2006-01-01 1069.184 NaN NaN   2006-01-02 1380.521 NaN NaN   2006-01-03 1442.533 NaN NaN   2006-01-04 1457.217 NaN NaN   2006-01-05 1477.131 NaN NaN     On francise ensuite les noms de colonne\u0026hellip;\nserie_temp.columns = [\u0026#34;Consommation\u0026#34;,\u0026#34;Vent\u0026#34;,\u0026#34;Solaire\u0026#34;] serie_temp.head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    Consommation Vent Solaire   Date        2006-01-01 1069.184 NaN NaN   2006-01-02 1380.521 NaN NaN   2006-01-03 1442.533 NaN NaN   2006-01-04 1457.217 NaN NaN   2006-01-05 1477.131 NaN NaN     Et enfin, on ajoute des colonnes \u0026ldquo;jour\u0026rdquo;, \u0026ldquo;mois\u0026rdquo; et \u0026ldquo;ann√©e\u0026rdquo;.\nserie_temp[\u0026#39;jour\u0026#39;] = serie_temp.index.day_name() serie_temp[\u0026#39;mois\u0026#39;] = serie_temp.index.month serie_temp[\u0026#39;ann√©e\u0026#39;] = serie_temp.index.year serie_temp[\u0026#34;date\u0026#34;] = serie_temp.index serie_temp[\u0026#34;date\u0026#34;] = serie_temp[\u0026#34;date\u0026#34;].dt.date # pour aider Colab qui a des soucis avec les dates serie_temp.head()   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    Consommation Vent Solaire jour mois ann√©e date   Date            2006-01-01 1069.184 NaN NaN Sunday 1 2006 2006-01-01   2006-01-02 1380.521 NaN NaN Monday 1 2006 2006-01-02   2006-01-03 1442.533 NaN NaN Tuesday 1 2006 2006-01-03   2006-01-04 1457.217 NaN NaN Wednesday 1 2006 2006-01-04   2006-01-05 1477.131 NaN NaN Thursday 1 2006 2006-01-05     px.line(serie_temp[[\u0026#34;Consommation\u0026#34;,\u0026#34;Vent\u0026#34;,\u0026#34;Solaire\u0026#34;]])    Plotly.d3.json(\"/linecomplet.json\", function(err, fig) { Plotly.plot('\\/linecomplet.json', fig.data, fig.layout, {responsive: true}); });  On constate d\u0026rsquo;importantes variations saisonni√®res.\nzoom = serie_temp[serie_temp[\u0026#39;ann√©e\u0026#39;]==2016] fig1 = px.line(zoom,\u0026#39;date\u0026#39;,\u0026#39;Consommation\u0026#39;) fig2 = px.scatter(zoom,\u0026#39;date\u0026#39;,\u0026#39;Consommation\u0026#39;,color=\u0026#39;jour\u0026#39;) fig = go.Figure() fig.add_traces([fig1.data[0],*[fig2.data[i] for i in range(7)]])    Plotly.d3.json(\"/zoom2016.json\", function(err, fig) { Plotly.plot('\\/zoom2016.json', fig.data, fig.layout, {responsive: true}); });  Une variabilit√© hebdomadaire se superpose √† la tendance saisonni√®re.\nGr√¢ce √† la m√©thode des dataframe pandas groupby, on peut facilement grouper les donner de mani√®re √† obtenir les statistiques qui nous int√©ressent.\nExemple : trouvons combien d\u0026rsquo;√©lectricit√© d\u0026rsquo;origine √©olienne a √©t√© produite chaque mois en 2016.\nserie_temp[serie_temp[\u0026#39;ann√©e\u0026#39;]==2016].groupby(\u0026#34;mois\u0026#34;)[\u0026#34;Vent\u0026#34;].sum() mois\n1 9264.588\n2 9814.294\n3 6030.177\n4 5910.504\n5 6089.484\n6 3369.069\n7 4651.582\n8 4742.343\n9 4222.315\n10 5585.248\n11 8076.232\n12 9252.290\nName: Vent, dtype: float64\n Sur le mod√®le pr√©c√©dent, d√©terminez le jour de la semaine o√π l\u0026rsquo;Allemagne a consomm√© le plus d\u0026rsquo;√©lectricit√© en moyenne en 2016 (vous pourrez utilisez la m√©thode mean √† la place de sum.\n Tra√ßons une bo√Æte √† moustaches de la r√©partition des 3 variables mois par mois :\nfig, axes = plt.subplots(3, 1, figsize=(15, 10), sharex=True) for var, ax in zip([\u0026#39;Consommation\u0026#39;, \u0026#39;Solaire\u0026#39;, \u0026#39;Vent\u0026#39;], axes): sns.boxplot(data=serie_temp, x=\u0026#39;mois\u0026#39;, y=var, ax=ax) ax.set_ylabel(\u0026#39;GWh\u0026#39;) ax.set_title(var) if ax != axes[-1]: ax.set_xlabel(\u0026#39;\u0026#39;) On observe que :\n les trois graphes pr√©sentent bien une variabilit√© saisonni√®re ; la consommation √©lectrique est plus forte en hiver ainsi que la production √©olienne (m√™me si l\u0026rsquo;√©cart est moins marqu√©) et la production solaire est beaucoup plus importante en √©t√©. beaucoup de valeurs se retrouvent √† l\u0026rsquo;ext√©rieur des moustaches sup√©rieures pour la production √©olienne, ce qui est probablement d√ª √† des p√©riodes de fort vent.  Regardons maintenant jour par jour :\nserie_temp[\u0026#34;date\u0026#34;]=(serie_temp.index.strftime(\u0026#39;%d%B\u0026#39;)) px.box(serie_temp,x=\u0026#39;jour\u0026#39;, y=\u0026#39;Consommation\u0026#39;,hover_data={\u0026#34;date\u0026#34;})    Plotly.d3.json(\"/jourparjour.json\", function(err, fig) { Plotly.plot('\\/jourparjour.json', fig.data, fig.layout, {responsive: true}); });   Pourquoi y a-t-il autant de points au-del√† des moustaches les jours de semaine ?\n "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/python/typesstruct/",
	"title": "Types structur√©s",
	"tags": [],
	"description": "",
	"content": "Types structur√©s Les types structur√©s (cha√Ænes, tuiles, listes, dictionnaires, ensembles) sont des objets compos√©s ; ils contiennent eux-m√™mes d\u0026rsquo;autres objets.\nCertains de ces objets composites sont en plus indic√©s. Comme leur nom l\u0026rsquo;indique, on peut parcourir les √©l√©ments pr√©sents d\u0026rsquo;une structure indic√©e √† l\u0026rsquo;aide d\u0026rsquo;un indice (un nombre entier √©tiquetant l\u0026rsquo;indice). Les structures indic√©s sont donc ordonn√©es, ce sont des s√©quences. L\u0026rsquo;indice commence toujours √† 0.\nEt donc si la structure contient n √©l√©ments, le dernier indice est n-1.\n ¬†Structures indic√©es immuables (cha√Ænes, tuples) Une structure est dite immuable si on ne peut pas modifier les √©l√©ments qu\u0026rsquo;elle contient une fois qu\u0026rsquo;elle est construite.\nIl y a deux structures de ce type en Python : les cha√Ænes de caract√®res (type string) et les tuples (type tuple).\n Les cha√Ænes de caract√®res sont des s√©quences de caract√®res (du texte) d√©finies par des apostrophes ', des guillemets \u0026quot;, des triples apostrophes ''' ou des triples guillemets \u0026quot;\u0026quot;\u0026quot; ('abc', \u0026quot;abc\u0026quot;,'''abc''',\u0026quot;\u0026quot;\u0026quot;abc\u0026quot;\u0026quot;\u0026quot; ).\nLes cha√Ænes de caract√®res peuvent √™tre constitu√©es de tous les caract√®res possibles, y compris des emojis üëç.   Les guillemets \u0026quot;\u0026quot; permettent d\u0026rsquo;utiliser des apostrophes ' dans la cha√Æne sans que cela ne la ferme (\u0026quot;C'est bon\u0026quot;).\nLes triples apostrophes ''' ou guillemets \u0026quot;\u0026quot;\u0026quot; permettent d\u0026rsquo;√©crire des cha√Ænes sur plusieurs lignes (on utilise de telles cha√Ænes pour les signatures des fonctions).\n L\u0026rsquo;espace est un caract√®re comme un autre !\n  Les tuples sont des ensembles d\u0026rsquo;objets (pas forc√©ment du m√™me type) plac√©s entre parenth√®ses (pas obligatoires) et s√©par√©s par des virgules comme (3.2, 'abc', True).  ¬†len La fonction native len() permet d\u0026rsquo;obtenir le nombre d\u0026rsquo;√©l√©ments pr√©sents dans la structure, c\u0026rsquo;est-√†-dire sa longueur (len est l'\u0026lsquo;abr√©viation de length).\nlen(\u0026#39;abc\u0026#39;) 3\nlen((3.2, \u0026#39;abc\u0026#39;, True)) 3\nM√™me si le deuxi√®me √©l√©ment du tuple du dernier exemple est lui-m√™me compos√©, len le consid√®re comme un (et un seul) des √©l√©ments du tuple.\nDe m√™me, si un tuple contient un autre tuple imbriqu√©, il ne comptera que pour un seul √©l√©ment pour len :\nlen((\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,(1,2,3),18)) 4\n¬†Acc√®s par indice d\u0026rsquo;un √©l√©ment On place l\u0026rsquo;indice de l\u0026rsquo;√©l√©ment qui nous int√©resse entre crochets pour le r√©cup√©rer :\nS = \u0026#39;abcdefghijklmnopqrstuvwxyz\u0026#39; n = len(S) print(\u0026#39;de\u0026#39;,S[0],\u0026#39;√†\u0026#39;,S[n-1]) de a √† z\ns[n] provoque l\u0026rsquo;erreur classique IndexError: string index out of range.\nSi $n$ est le nombre d\u0026rsquo;√©l√©ments de la structure (donn√© par len), alors l\u0026rsquo;indice doit √™tre un entier inf√©rieur ou √©gal √† $n-1$.\n Si une structure indic√©e se trouve enchass√©e au sein d\u0026rsquo;une autre structure indic√©e, on peut aussi acc√©der √† ses √©l√©ments :\nT = (1,\u0026#39;abcd\u0026#39;,2) len(T[1]) 4\nT[1][3] d\nAutre source d\u0026rsquo;erreur : on ne peut pas modifier la valeur d\u0026rsquo;un √©l√©ment dans une structure immuable.\n T = (1,2,3) T[2] = 4 TypeError: 'tuple' object does not support item assignment\n\u0026#39;abc\u0026#39;[1] = \u0026#39;d\u0026#39; TypeError: 'str' object does not support item assignment\n¬†Concat√©nation + L\u0026rsquo;op√©rateur + permet de concat√©ner deux structures du m√™me type.\n\u0026#39;abc\u0026#39;+\u0026#39;de\u0026#39; 'abcde'\n(1,\u0026#39;b\u0026#39;,2.2) + (True,1/5) (1, 'b', 2.2, True, 0.2)\nLa longueur de la structure r√©sultante vaut la somme des longueurs des deux tructures concat√©n√©es.\n¬†R√©p√©tition * L\u0026rsquo;op√©rateur * permet de r√©p√©ter une structure.\n\u0026#39;abc\u0026#39;*2 abcabc\nOn peut combiner * et + :\n(\u0026#39;z\u0026#39;*5 + \u0026#39; \u0026#39;)*3 zzzzz zzzzz zzzzz \n¬†Tranches On peut extraire plusieurs √©l√©ments d\u0026rsquo;une structure indic√©e en une seule fois gr√¢ce au d√©coupage en tranches (slicing en anglais). On utilise les crochets comme pour l\u0026rsquo;indexation mais on utilise maintenant 2 ou 3 indices s√©par√©s par :. La tranche va du premier indice (inclu) jusqu\u0026rsquo;au deuxi√®me indice (exclu).\n S = \u0026#39;0123456789\u0026#39; S[1:4] '123'\nCette r√®gle d\u0026rsquo;exclusion du deuxi√®me indice permet d\u0026rsquo;avoir une √©paisseur de tranche (len(S[i:j])) valant la diff√©rence entre les deux indices (j-i).\nSi on omet le premier indice ([:j]), on part du d√©but. Si on omet le second ([i:]), on va jusqu\u0026rsquo;au bout.\n S[:4],S[5:] ('0123', '56789')\nUn troisi√®me indice installe un pas dans la d√©coupe :\nS[::2],S[1::4] ('02468', '159')\nEt si le troisi√®me indice est n√©gatif, il permet de parcourir la s√©quence en sens inverse :\nS[::-1],S[8:0:-2] ('9876543210', '8642')\n¬†Appartenance in On peut tester l\u0026rsquo;appartenance d\u0026rsquo;un √©l√©ment ou d\u0026rsquo;une tranche √† une structure compos√©e gr√¢ce au mot cl√© in :\n\u0026#39;b\u0026#39; in (5,\u0026#39;a\u0026#39;,12.5) False\n\u0026#39;567\u0026#39; in S True\n¬†Listes Une liste (type list) est une collection d\u0026rsquo;objets plac√©s entre crochets et s√©par√©s par des virgules.\nExemple : L = [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8]\nComme avec les cha√Ænes de caract√®res et les tuples :\n on acc√®de √† un √©l√©ment via son indice :\nL[3] renvoie 0.3. on obtient le nombre d\u0026rsquo;√©l√©ments d\u0026rsquo;une liste gr√¢ce √† la fonction len :\nlen(L) retourne 9 ; on peut concat√©ner deux listes avec +:\n[5,6]+[7,8] donne [5,6,7,8] ; on peut extraire par tranche des √©l√©ments :\nL[1:6] donne [0.1,0.2,0.3,0.4,0.5] ; on peut tester la pr√©sence d\u0026rsquo;un √©l√©ment gr√¢ce au mot cl√© in :\n0.1 in L renvoie True et 1 in L renvoie False.  Mais contrairement aux cha√Ænes de caract√®res et aux tuples, les listes ne sont pas immuables. On peut donc r√©affecter des √©l√©ments.\nEn reprenant la liste L pr√©c√©dente, si on √©crit L[2] = 'a', L devient [0.0,0.1,'a',0.3,0.4,0.5,0.6,0.7,0.8].\n¬†Cr√©ation d\u0026rsquo;une liste ¬†par duplication : L\u0026rsquo;op√©rateur * permet de cr√©er une liste r√©p√©tant un √©l√©ment.\nPar exemple, pour cr√©er une liste L de 10 z√©ros, il suffit d\u0026rsquo;√©crire L = [0]*10.\n¬†par append successifs : On initialise une liste vide ([]), puis on la garnit √©l√©ment par √©l√©ment gr√¢ce √† la m√©thode append.\nExemple :\nL = [] for i in range(10) : L.append(i/10) L [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8]\n¬†par compr√©hension La construction par compr√©hension d\u0026rsquo;une liste est une m√©thode concise et √©l√©gante. L\u0026rsquo;id√©e est d\u0026rsquo;int√©grer les boucles et enventuelles conditions dans une seule expression entre crochets pour aboutir √† une d√©finition plus directe de la liste.\nExemples :\nL1 = [i/10 for i in range(9)] L2 = [k**2 if (k%2==0) else k**3 for k in range(9)] print(f\u0026#34;{L1 = }\u0026#34;) print(f\u0026#34;{L2 = }\u0026#34;) L1 = [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8]\nL2 = [0, 1, 4, 27, 16, 125, 36, 343, 64]\n¬†Copie d\u0026rsquo;une liste Si on copie une liste en l\u0026rsquo;affectant √† un nouveau nom, alors toute modification de l\u0026rsquo;ancienne liste se r√©percutera sur la nouvelle (et inversement). Les deux noms pointent en r√©alit√© vers le m√™me espace m√©moire. En effet, lorsqu\u0026rsquo;on affecte une liste √† un nom de variable via =, ce n\u0026rsquo;est pas la liste mais sa r√©f√©rence (son adresse m√©moire) qui est assign√©e √† la variable. Et donc lorsqu\u0026rsquo;on affecte la liste √† une nouvelle variable, c\u0026rsquo;est une copie de la r√©f√©rence et non des valeurs qui est faite.\nL_originelle = [\u0026#39;üçì\u0026#39;, \u0026#39;üçá\u0026#39;, \u0026#39;üçä\u0026#39;] L_copie = L_originelle L_originelle[1] = \u0026#39;?\u0026#39; print(L_originelle,L_copie) ['üçì', '?', 'üçä'] ['üçì', '?', 'üçä']\nAucune diff√©rence !\nSi on veut que la liste copi√©e conserve ses √©l√©ments tels qu\u0026rsquo;ils √©taient au moment de la copie, on peut soit utiliser une \u0026ldquo;copie par tranche\u0026rdquo;, en affectant une tranche compl√®te (avec [:]) de la liste, soit utiliser la m√©thode copy(), soit utiliser la fonction list.\nL_originelle = [\u0026#39;üçì\u0026#39;, \u0026#39;üçá\u0026#39;, \u0026#39;üçä\u0026#39;] L_copie_1 = L_originelle[:] L_copie_2 = L_originelle.copy() L_copie_3 = list(L_originelle) L_originelle[1] = \u0026#39;?\u0026#39; print(L_originelle,L_copie_1,L_copie_2,L_copie_3) ['üçì', '?', 'üçä'] ['üçì', 'üçá', 'üçä'] ['üçì', 'üçá', 'üçä'] ['üçì', 'üçá', 'üçä']\n'?' ne se retrouve pas dans les copies !\nMais ces deux copies n\u0026rsquo;en restent pas moins superficielles. En effet, si la liste originelle contient des √©l√©ments mutables (comme une autre liste), alors seule l\u0026rsquo;adresse de ceux-ci est copi√©e, et s\u0026rsquo;ils sont modifi√©s, la copie aussi le sera :\nL = [\u0026#39;üçã\u0026#39;,\u0026#39;üçë\u0026#39;,[\u0026#39;üçà\u0026#39;,\u0026#39;üçí\u0026#39;],\u0026#39;üçè\u0026#39;] L_copie = L[:] L.append(\u0026#39;ü••\u0026#39;) L[2].append(\u0026#39;üçå\u0026#39;) print(L_copie) ['üçã', 'üçë', ['üçà', 'üçí', 'üçå'], 'üçè']\n'ü••' ne se retrouve pas dans la copie, mais üçå y est bien\u0026hellip;\n¬†Retirer un √©l√©ment La m√©thode pop() permet de retirer le dernier √©l√©ment d\u0026rsquo;une liste.\nL = [\u0026#39;ü••\u0026#39;, \u0026#39;üçê\u0026#39;, \u0026#39;üçã\u0026#39;, \u0026#39;üçí\u0026#39;] print(f\u0026#34;{L.pop() = }\u0026#34;) print(f\u0026#34;{L = }\u0026#34;) L.pop() = 'üçí'\nL = ['ü••', 'üçê', 'üçã']\nComme on le voit, pop retourne l\u0026rsquo;√©l√©ment retir√© (c\u0026rsquo;est une expression), et une fois que pop a √©t√© utilis√©, l\u0026rsquo;√©l√©ment a disparu.\nSi on veut retirer un autre √©l√©ment que le dernier et qu\u0026rsquo;on conna√Æt son indice i, on peut utiliser pop(i), mais on peut aussi utiliser le slicing (L[i:i+1]=[]) ou encore le mot cl√© del (del L[i]).\nL1 = [\u0026#39;ü••\u0026#39;, \u0026#39;üçê\u0026#39;, \u0026#39;üçã\u0026#39;, \u0026#39;üçí\u0026#39;] L2 = [\u0026#39;ü••\u0026#39;, \u0026#39;üçê\u0026#39;, \u0026#39;üçã\u0026#39;, \u0026#39;üçí\u0026#39;] L3 = [\u0026#39;ü••\u0026#39;, \u0026#39;üçê\u0026#39;, \u0026#39;üçã\u0026#39;, \u0026#39;üçí\u0026#39;] # Si on veut retirer la poire L1.pop(1) L2[1:2]=[] del L3[1] print(L1) print(L2) print(L3) ['ü••', 'üçã', 'üçí']\n['ü••', 'üçã', 'üçí']\n['ü••', 'üçã', 'üçí']\nEt si plut√¥t que l\u0026rsquo;indice de l\u0026rsquo;√©l√©ment √† retirer, on veut utiliser sa valeur, on emploie la m√©thode remove.\nL = [\u0026#39;ü••\u0026#39;, \u0026#39;üçê\u0026#39;, \u0026#39;üçã\u0026#39;, \u0026#39;üçí\u0026#39;] # Si on veut retirer la poire L.remove(\u0026#39;üçê\u0026#39;) print(L) ['ü••', 'üçã', 'üçí']\n¬†Dictionnaires Un dictionnaire (type dict) est une collection d\u0026rsquo;objets, comme une liste ou un tuple, mais au lieu d\u0026rsquo;indicer les objets s\u0026rsquo;y trouvant (appel√©s valeurs) par un nombre, on utilise une cl√©.\nLes dictionnaires sont l\u0026rsquo;impl√©mentation en Python des tables de hachage.\n Une cl√© peut √™tre n\u0026rsquo;importe quel objet immuable, mais il s\u0026rsquo;agit le plus souvent d\u0026rsquo;une cha√Æne de caract√®res.\nPour cr√©er un dictionnaire, on utilise la syntaxe {cl√©1 : valeur1, cl√©2 : valeur2, ...}.\nExemple o√π les cl√©s sont des pr√©noms et les valeurs, des notes :\nnote = {\u0026#39;Giselle\u0026#39; : 7.5, \u0026#39;Alphonse\u0026#39; : 12, \u0026#39;Dudule\u0026#39; : 7.5, \u0026#39;Berthe\u0026#39; : 16.5} Chaque valeur peut √™tre r√©cup√©r√©e gr√¢ce √† la cl√© comme s\u0026rsquo;il s\u0026rsquo;agisait d\u0026rsquo;un indice : note['Dudule'] donne 7.5\n¬†Ajouter une cl√© √† un dictionnaire On peut ajouter une entr√©e au dictionnaire en √©crivant simplement dico[nouvelleCl√©]=valeur.\nnote[\u0026#39;Raoul\u0026#39;] = 14 # ajoute la note de Raoul au dictionnaire note print(note) {'Giselle': 7.5, 'Alphonse': 12, 'Dudule': 7.5, 'Berthe': 16.5, 'Raoul': 14}\nOn peut partir d\u0026rsquo;un dictionnaire vide {} et le construire ainsi √©tape par √©tape :\ncoef = {} # dictionnaire vide coef[\u0026#39;maths\u0026#39;] = 9 coef[\u0026#39;physique\u0026#39;] = 10 coef[\u0026#39;philo\u0026#39;] = 9 print(coef) {'maths': 9, 'physique': 10, 'philo': 9}\nComme les listes, les dictionnaires sont des objets mutables.\nnote[\u0026#39;Berthe\u0026#39;] = 18 # modifie la note de Berthe dans le dictionnaire note print(note) {'Giselle': 7.5, 'Alphonse': 12, 'Dudule': 7.5, 'Berthe': 18, 'Raoul': 14}\nChaque cl√© doit √™tre unique, mais les valeurs peuvent √™tre identiques (comme les notes de Dudule et Giselle).\n Tenter d\u0026rsquo;acc√©der √† une cl√© qui ne figure pas dans le dictionnaire se solde par une erreur.\n print(note[\u0026#39;Gourmandine\u0026#39;]) # la cl√© Gourmandine n\u0026#39;existe pas KeyError: 'Gourmandine'\nPour y √©chapper, on peut tester la pr√©sence d\u0026rsquo;une cl√© gr√¢ce √† in.\nExemple : √† partir d\u0026rsquo;une liste de 12 √©l√©ments pris au hasard parmi les entiers de 1 √† 10, fabriquons un dictionnaire qui compte les occurrences de chacun des 10 entiers¬†:\nfrom random import randint L = [] for i in range(12) : L = L+[randint(1,10)] effectifs = {} for e in L : if not e in effectifs : effectifs[e] = 1 else : effectifs[e] = effectifs[e]+1 print(effectifs) {5: 3, 10: 1, 9: 1, 4: 1, 8: 1, 6: 2, 1: 3}\nSans la condition, effectifs[e]+1 aurait lev√© une KeyError car le dictionnaire n\u0026rsquo;a initialement aucune entr√©e et donc effectifs[e] n\u0026rsquo;est pas d√©fini.\n¬†Retirer une cl√© On peut retirer une cl√© d\u0026rsquo;un dictionnaire gr√¢ce au mot cl√© del.\ndel note[\u0026#39;Alphonse\u0026#39;] print(note) {'Giselle': 7.5, 'Dudule': 7.5, 'Berthe': 18, 'Raoul': 14}\nSi on utilise del sur une cl√© inexistante, une erreur KeyError est l√† encore produite.\n ¬†Parcourir un dictionnaire Les m√©thodes keys et values permettents de r√©cup√©rer les cl√©s et valeurs d\u0026rsquo;un dictionnaire sous forme d\u0026rsquo;it√©rables, ce qui peut s\u0026rsquo;av√©rer pratique pour un trac√©, par exemple.\nimport matplotlib.pyplot as plt cl√©s = effectifs.keys() valeurs = effectifs.values() plt.bar(cl√©s, valeurs) plt.show() La m√©thode items regroupe cl√©s et valeurs au sein de tuples (cl√©,valeur).\nfor cl√©, valeur in effectifs.items() : print(\u0026#39;nombre de\u0026#39;,cl√©,\u0026#39;:\u0026#39;,valeur) nombre de 5 : 3\nnombre de 10 : 1\nnombre de 9 : 1\nnombre de 4 : 1\nnombre de 8 : 1\nnombre de 6 : 2\nnombre de 1 : 3\nLes dictionnaires sont des ensemble de paires cl√©-valeur qui n\u0026rsquo;ont aucun ordre particulier. Les dictionnaires ne sont donc pas des s√©quences.\n Comme pour les listes, une affectation d\u0026rsquo;un dictionnaire existant √† une nouvelle variable n\u0026rsquo;en copie que la r√©f√©rence. Toute modification de l\u0026rsquo;un se retrouve dans l\u0026rsquo;autre.\nEt si on veut conserver invariante les valeurs copi√©es, on peut ici aussi utiliser la m√©thode copy().\ninfos = {\u0026#39;pr√©nom\u0026#39;: \u0026#39;Russell\u0026#39;, \u0026#39;nom\u0026#39;: \u0026#39;Bell\u0026#39;, \u0026#39;alias\u0026#39;: \u0026#39;Stringer\u0026#39;, \u0026#39;notes\u0026#39;: [13,18,7]} infos_copie = infos.copy() infos[\u0026#39;pr√©nom\u0026#39;] = infos.pop(\u0026#39;alias\u0026#39;) infos[\u0026#39;notes\u0026#39;][:] = [\u0026#39;abs\u0026#39;] print(infos) print(infos_copie) {'pr√©nom': 'Stringer', 'nom': 'Bell', 'notes': ['abs']}\n{'pr√©nom': 'Russell', 'nom': 'Bell', 'alias': 'Stringer', 'notes': ['abs']}\nOn remarque que le remplacement du pr√©nom par l\u0026rsquo;alias et la suppression de l\u0026rsquo;alias n\u0026rsquo;ont pas √©t√© r√©percut√©s sur la copie, par contre la modification de la liste de notes, objets mutable, oui.\n"
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_2/",
	"title": "Semestre 2",
	"tags": [],
	"description": "",
	"content": "Semestre 2 On consolide certains concepts rencontr√©s pendant les TP du semestre 1 :\n les bonnes pratiques en programmation la correction et la terminaison d\u0026rsquo;un algorithme la complexit√©  Puis on d√©veloppe deux nouveaux points :\n la repr√©sentation des nombres les graphes  "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/python/structcontr/",
	"title": "Strucutres de contr√¥le",
	"tags": [],
	"description": "",
	"content": "Structures de contr√¥le Instruction d\u0026rsquo;affectation D√©finition Lorsqu\u0026rsquo;un objet est cr√©√© dans un programme Python, une certaine place en m√©moire lui est allou√©e. Cette place est rep√©r√©e par une adresse dont la valeur peut √™tre obtenue gr√¢ce √† la fonction id().\nid(3.7) 4387417928\nIl est beaucoup plus pratique de pouvoir r√©cup√©rer une valeur en m√©moire gr√¢ce √† un petit nom plut√¥t que par son adresse. C\u0026rsquo;est √† √ßa que servent les variables. Une variable est li√©e √† un objet gr√¢ce √† une affectation et identifie cet objet pour les calculs suivants. Une affectation est une instruction (pas de retour).\nEn Python, une affectation s\u0026rsquo;op√®re avec le symbole =.\nEn pseudocode, on utilise g√©n√©ralement := ou ‚Üê pour les affectations.\n La variable est un tiroir avec une √©tiquette. Et comme on l\u0026rsquo;a vu, en Python, pas besoin de choisir un tiroir correspondant au type d\u0026rsquo;objet qu\u0026rsquo;il va contenir, c\u0026rsquo;est l\u0026rsquo;interpr√©teur qui s\u0026rsquo;en charge pour nous (le typage est dynamique).\na = 3 b = -2 a * b -6\nSi on veut pouvoir utiliser le r√©sultat de a * b pour des calculs ult√©rieurs, il faut lui aussi le stocker en m√©moire.\nc = a * b c -6\nOn peut interroger le type d\u0026rsquo;une variable avec la fonction type() :\nc = 3,2 type(c) \u0026lt;class 'tuple'\u0026gt;\n¬†Instruction plut√¥t qu\u0026rsquo;expression Le fait que l\u0026rsquo;affectation soir une instruction plut√¥t qu\u0026rsquo;une expression est un choix d\u0026rsquo;√©criture du langage (en C, l\u0026rsquo;affectation est une expression).\nD\u0026rsquo;ailleurs, Python 3.8 a introduit l\u0026rsquo;op√©rateur := (dit le walrus op√©rator ou op√©rateur de morse du fait de sa ressemblance √† un morse\u0026hellip;) permettant justement une expression d\u0026rsquo;affectation au sein d\u0026rsquo;une expression plus large. L\u0026rsquo;int√©r√™t est de permettre de raccourcir l\u0026rsquo;√©criture ou d\u0026rsquo;√©viter les r√©p√©titions dans certains cas.\nL\u0026rsquo;op√©rateur de morse n\u0026rsquo;est pas √† conna√Ætre, mais il va nous permettre, dans les deux exemples suivants, de bien faire la diff√©rence entre une instruction et une expression.\nif (n := len(a)) \u0026gt; 5: print(f\u0026#34;La liste est trop grande ({n} √©lements alors qu\u0026#39;on en attend 5 au plus)\u0026#34;)  Montrer que sans :=, on aurait soit une r√©p√©tition, soit une ligne en plus.\n Autre exemple :\nwhile (choix := input(\u0026#39;Entrer q ou p : \u0026#39;)) != \u0026#39;q\u0026#39;: if choix == \u0026#39;p\u0026#39;: print(\u0026#34;Salut !\u0026#34;)  Comment aurait-on d√ª √©crire ce code sans := ?\n ¬†R√©affectation Une affectation ne retourne rien mais a un effet sur la m√©moire : l\u0026rsquo;adresse de la variable est modifi√©e √† chaque nouvelle affectation. C\u0026rsquo;est ce qui rend possible les r√©affectations √† partir de la variable elle-m√™me.\nid(a) 4304751488\nid(a+1) 4304751520\na = a + 1 id(a) 4304751520\nCes types de r√©affectation sont si fr√©quents qu\u0026rsquo;il existe une notation raccourcie : +=, -=, *=, /=, //=, %=.\nAinsi, a += 1 √©quivaut √† a = a + 1 et b /= 5 √©quivaut √† b = b/5.\n ¬†Affectation parall√®le Comment faire si on veut permuter les valeurs auxquelles sont li√©es deux variables ? D√®s qu\u0026rsquo;on √©crit a = b, la valeur initiale de a est perdue. Et si on commence par b = a, c\u0026rsquo;est la valeur initiale de b qui est perdue. Il faudrait donc utiliser une variable temporaire et √©crire : tmp = a, a = b et b = tmp.\nMais l\u0026rsquo;affectation parall√®le de Python va nous permettre d\u0026rsquo;√™tre plus √©l√©gants. Il suffit en effet d\u0026rsquo;une petite ligne :\na = \u0026#39;haut\u0026#39; b = \u0026#39;bas\u0026#39; a , b = b , a print(a,b) bas haut\nL\u0026rsquo;affectation parall√®le repose sur le d√©paquetage (unpacking) de tuples.\nEn effet, des objets s√©par√©s par des virgules forment un tuple (pas besoin de parenth√®ses). Donc a,b,c = 1,2,3 correspond au d√©paquetage du tuple (1,2,3) sur les 3 variables a, b et c.\n ¬†Noms de variable R√®gles sur les noms de variables :\n ils sont sensibles √† la casse (minuscule ou majuscule) ils peuvent contenir n\u0026rsquo;importe quelles lettres ou chiffres et le tiret-bas \u0026ldquo;_\u0026rdquo; mais ne doivent pas commencer par un chiffre. certains noms sont interdits (attention en particulier √† lambda) :  and assert break class continue def del elif else except finally for from global if\nimport in is lambda nonlocal not or pass print raise return try while yield\nIl est important pour la lisibilit√© de son code de donner les noms les plus explicites possibles aux variables. Les rapports de jury le r√©p√®te tous les ans\u0026hellip;\n Rapport 2019 de l\u0026rsquo;√©preuve de Centrale par exemple :\n Des noms de variables explicites aident √† la compr√©hension du code. De trop nombreux candidats utilisent des noms de variables quelconques (a, b, c\u0026hellip;) ce qui nuit √† la compr√©hension du programme. La clart√© du programme (en particulier le choix des noms de variables) ainsi que la pr√©sence de commentaires opportuns sont prises en compte dans l‚Äô√©valuation.\n ¬†Instuction conditionnelle Les instructions conditionnelles permettent de rediriger le flot d\u0026rsquo;ex√©cution d\u0026rsquo;un programme en proposant des alternatives.\nif,elif,else La structure if ... elif ... else permet d\u0026rsquo;ex√©cuter des instructions seulement si une condition, donn√©e par le r√©sultat d\u0026rsquo;un ou plusieurs tests logiques, est v√©rifi√©e.\nif \u0026lt;expression logique 1\u0026gt; :\n\u0026lt;bloc d\u0026rsquo;instructions 1\u0026gt;\nelif \u0026lt;expression logique 2\u0026gt; :\n\u0026lt;bloc d\u0026rsquo;instructions 2\u0026gt;\n\u0026hellip;\nelse :\n\u0026lt;bloc d\u0026rsquo;instructions\u0026gt;\nSi l'\u0026lt;expression¬†logique¬†1\u0026gt; est √©valu√©e comme vraie, le \u0026lt;bloc¬†d\u0026rsquo;instructions¬†1\u0026gt; est ex√©cut√© ; dans le cas contraire, si l'\u0026lt;expression logique¬†2\u0026gt; est √©valu√©e comme vraie, le \u0026lt;bloc¬†d\u0026rsquo;instructions¬†2\u0026gt; est ex√©cut√©, et ainsi de suite¬†; et si aucune des expressions logiques pr√©c√©dentes n\u0026rsquo;est vraie, le bloc d\u0026rsquo;instructions faisant suite au else: est ex√©cut√©.\nPar exemple :\nfor x in range(10) : if x\u0026lt;= 3 : print(x,\u0026#39;est inf√©rieur ou √©gal √† 3\u0026#39;) elif x \u0026gt; 5 : print(x,\u0026#39;est plus grand que 5\u0026#39;) else : print(x,\u0026#39;doit √™tre 4 ou 5\u0026#39;) 0 est inf√©rieur ou √©gal √† 3 1 est inf√©rieur ou √©gal √† 3 2 est inf√©rieur ou √©gal √† 3 3 est inf√©rieur ou √©gal √† 3 4 doit √™tre 4 ou 5 5 doit √™tre 4 ou 5 6 est plus grand que 5 7 est plus grand que 5 8 est plus grand que 5 9 est plus grand que 5  Python reconna√Æt comme vrai n\u0026rsquo;importe quel type de donn√©e (m√™me pas besoin d\u0026rsquo;expression logique) du moment qu\u0026rsquo;il ne s\u0026rsquo;agit ni de l\u0026rsquo;entier 0, du d√©cimal 0., de la cha√Æne de caract√®res vide '', du tuple vide (), de la liste vide [], ou encore de la valeur None.\n Exemple :\nDans le calendrier gr√©gorien, une ann√©e est bissextile si elle est divisible par 4 sauf si elle est aussi divisible par 100 √† l\u0026rsquo;exception des ann√©es divisibles par 400 qui sont bien bissextiles.\nLe programme suivant d√©termine si une ann√©e est bissextile :\nann√©e = 2022 if not ann√©e % 400 : est_bissextile = True elif not ann√©e % 100 : est_bissextile = False elif not ann√©e % 4 : est_bissextile = True else : est_bissextile = False s = \u0026#39;est une\u0026#39; if est_bissextile else \u0026#34;n\u0026#39;est pas une\u0026#34; print(\u0026#34;L\u0026#39;ann√©e\u0026#34;, ann√©e , s ,\u0026#34;ann√©e bissextile.\u0026#34;) L'ann√©e 2022 n'est pas une ann√©e bissextile.\n¬†¬†Boucle while Une boucle while ou \u0026ldquo;tant que\u0026rdquo; permet de r√©p√©ter une suite d\u0026rsquo;instructions tant qu' une condition est respect√©e.\nLa suite d\u0026rsquo;instructions r√©p√©t√©es devra √™tre indent√©e et forme alors le corps de la boucle.\nLes boucles while sont dangereuses ! Rien ne dit en effet que la condition sera un jour fausse et la boucle peut donc tourner ind√©finiment.\nLes boucles infinis posent le probl√®me de la terminaison d\u0026rsquo;un programme.\n i = 0 while i \u0026lt; 10 : i += 1 print(i,end =\u0026#39;.\u0026#39;) print(\u0026#39;\\nLa boucle est finie...\u0026#39;) 1.2.3.4.5.6.7.8.9.10. La boucle est finie...  Le compteur i est initialis√© √† 0 et comme 0 est inf√©rieur √† 10, la boucle while d√©marre. √Ä chaque it√©ration, i est incr√©ment√© de 1 et sa valeur affich√©e. Puis i atteint 10 et √† l\u0026rsquo;it√©ration suivante i \u0026lt; 10 devient faux, la boucle s\u0026rsquo;arr√™te et l\u0026rsquo;√©x√©cution reprend apr√®s la boucle.\nUn exemple plus int√©ressant :\nimpl√©mentons l\u0026rsquo;algorithme d\u0026rsquo;Euclide permettant de d√©terminer le plus grand diviseur commun de deux entiers.\na , b = 1920 , 1080 print(f\u0026#39;pgcd({a},{b}) = \u0026#39;,end = \u0026#39;\u0026#39;) while b : a , b = b, a % b print(a) pgcd(1920,1080) = 120\nLa boucle continue jusqu\u0026rsquo;√† ce que b divise a. √Ä chaque it√©ration, b prend la valeur du reste de la division euclidienne de a par b et a prend l\u0026rsquo;ancienne valeur de b.\nwhile b est √©quivalent √† while b != 0 puisque la valeur 0 est √©valu√©e comme fausse.\n¬†break L\u0026rsquo;instruction break, plac√©e dans le bloc d\u0026rsquo;instructions d\u0026rsquo;une boucle, met imm√©diatement fin √† cette boucle lorsqu\u0026rsquo;arrive son tour d\u0026rsquo;√™tre ex√©cut√©e.\nL\u0026rsquo;ex√©cution reprend √† l\u0026rsquo;instruction suivant la boucle.\nx = 0 while True : x += 1 if not (x % 15 or x % 25) : break print(x,\u0026#39;est divisible √† la fois par 15 et 25.\u0026#39;) 75 est divisible √† la fois par 15 et 25.\nLa condition du while est ici litt√©ralement toujours vraie donc la seule sortie possible de la boucle passe par une ex√©cution de l\u0026rsquo;instruction break, ce qui ne peut arriver que si x est √† la fois divisible par 15 et 25 (c\u0026rsquo;est une pratique risqu√©e !).\nDe la m√™me mani√®re, pour trouver l\u0026rsquo;indice de la premi√®re occurrence d\u0026rsquo;un nombre n√©gatif dans une liste :\nliste = [5, 2, 99, 0, 100, -2, 37, 43, -124] for i, a in enumerate(liste) : if a \u0026lt; 0 : break print(\u0026#34;L\u0026#39;√©l√©ment d\u0026#39;indice\u0026#34;,i,\u0026#34;valant\u0026#34;,a,\u0026#34;est le premier √©l√©ment n√©gatif.\u0026#34;) L'√©l√©ment d'indice 5 valant -2 est le premier √©l√©ment n√©gatif.\nApr√®s la sortie de la boucle, les variables i et a gardent les valeurs qu\u0026rsquo;elles ont au moment de l\u0026rsquo;instruction break.\n ¬†return L\u0026rsquo;instruction return permet elle aussi de s\u0026rsquo;√©chapper d\u0026rsquo;une boucle.\nEn effet, l\u0026rsquo;utilisation du return a pour effet de sortir du corps d\u0026rsquo;une fonction donc √† fortiori, si une boucle est utilis√©e dans la d√©finition de cette fonction, le return permet aussi d\u0026rsquo;en sortir.\ndef vol(i) : t = 0 while(1) : if not i%2 : i //= 2 elif i != 1 : i = 3*i+1 else : return t t += 1 vol(27) renvoie alors 111.\n¬†¬†Boucle for Une boucle for se diff√©rencie d\u0026rsquo;une boucle while en ce que le nombre d\u0026rsquo;it√©rations est connu √† l\u0026rsquo;avance.\nLa structure d\u0026rsquo;une telle boucle est en effet :\nfor \u0026lt;√©l√©ment\u0026gt; in \u0026lt;it√©rable\u0026gt; :\n\u0026lt;bloc d\u0026rsquo;instructions\u0026gt;\nL\u0026rsquo;it√©rable est une collection d\u0026rsquo;√©l√©ments et le bloc d\u0026rsquo;instructions est alors r√©p√©t√© autant de fois que l\u0026rsquo;it√©rable contient d\u0026rsquo;√©l√©ments.\nPassons en revue quelques it√©rables.\nrange range permet d\u0026rsquo;it√©rer sur une suite arithm√©tique d\u0026rsquo;entiers :\nfor i in range(5) : print(i,end=\u0026#34;.\u0026#34;) 0.1.2.3.4.\nL\u0026rsquo;it√©ration sur range(n) va de $0$ √† $n-1$ par pas de 1.\n On peut sp√©cifier un point de d√©part et un pas diff√©rents en les passant en argument : range(depart,fin,pas).\nfor i in range(5,10) : print(i,end=\u0026#34;.\u0026#34;) 5.6.7.8.9.\nfor i in range(0,100,20) : print(i,end=\u0026#34;.\u0026#34;) 0.20.40.60.80.\n¬†une cha√Æne de caract√®res It√©rer sur une cha√Æne de caract√®res d√©compose la cha√Æne caract√®re par caract√®re :\nfor car in \u0026#39;abcüò±\u0026#39; : print(car*2,end=\u0026#39; \u0026#39;) aa bb cc üò±üò± \n¬†une liste, un tuple On peut de m√™me parcourir une liste ou un tuple √©l√©ment par √©l√©ment.\nL = [(\u0026#39;üôà\u0026#39;,\u0026#39;üôä\u0026#39;,\u0026#39;üôâ\u0026#39;),(\u0026#39;üåñ\u0026#39;,\u0026#39;üåó\u0026#39;,\u0026#39;üåò\u0026#39;),] s = \u0026#39;\u0026#39; i = 1 for tuple in L : for element in tuple : s += element*i i += 1 print(s) üôàüôäüôäüôâüôâüôâüåñüåñüåñüåñüåóüåóüåóüåóüåóüåòüåòüåòüåòüåòüåò\n¬†un dictionnaire Pour pacourir uniquement les cl√©s d\u0026rsquo;un dictionnaire, on peut utiliser la m√©thode keys :\nDico = {\u0026#39;pwd_1\u0026#39; : \u0026#39;123456\u0026#39;, \u0026#39;pwd_2\u0026#39; : \u0026#39;qwerty\u0026#39;, \u0026#39;pwd_3\u0026#39; : \u0026#39;password\u0026#39;} for cle in Dico.keys() : print(cle,\u0026#39;-\u0026gt;\u0026#39;,Dico[cle]) pwd_1 -\u0026gt; 123456\npwd_2 -\u0026gt; qwerty\npwd_3 -\u0026gt; password\nEt gr√¢ce √† la m√©thode items, on peut d√©baller cl√©s et valeurs associ√©es dans un tuple :\nfor cle,valeur in Dico.items() : print(cle,\u0026#39;-\u0026gt;\u0026#39;,valeur) pwd_1 -\u0026gt; 123456\npwd_2 -\u0026gt; qwerty\npwd_3 -\u0026gt; password\nConstruisons par exemple un nouveau dictionnaire inversant cl√©s et valeurs :\nDico = {\u0026#39;$\u0026#39; : \u0026#39;dollar\u0026#39;, \u0026#39;‚Ç¨\u0026#39; : \u0026#39;euro\u0026#39;, \u0026#39;¬•\u0026#39; : \u0026#39;yen\u0026#39;, \u0026#39;¬£\u0026#39; : \u0026#39;livre\u0026#39;} Dico_inv = {} for cle,valeur in Dico.items() : Dico_inv[valeur] = cle print(Dico_inv) {'dollar': '$', 'euro': '‚Ç¨', 'yen': '¬•', 'livre': '¬£'}\nDernier exemple, modifions une √† une chaque valeur d\u0026rsquo;un dictionnaire :\ndico_notes = {\u0026#39;Kurt\u0026#39; : 19, \u0026#39;Kris\u0026#39; : 11, \u0026#39;Dave\u0026#39; : 13, \u0026#39;Pat\u0026#39; : 10, \u0026#39;Courtney\u0026#39; : 15} for eleve,note in dico_notes.items() : dico_notes[eleve] = note+1 print(dico_notes) {'Kurt': 20, 'Kris': 12, 'Dave': 14, 'Pat': 11, 'Courtney': 16} ¬†D√©finition d\u0026rsquo;une fonction Une fonction est un ensemble d\u0026rsquo;instructions auxquelles on acc√®de par un raccourci : le nom de la fonction. Elles se comportent comme des sous-programmes √† l\u0026rsquo;int√©rieur du programme principal. Et comme tout programme, elles peuvent agir sur des donn√©es, les entr√©es, et fournir de nouvelles donn√©es, les sorties.\nLa signature d\u0026rsquo;une fonction r√©sume ces points cl√©s : son nom, les diff√©rents arguments et leurs types, les diff√©rentes sorties et leur type. nom(arg_1:type, arg_2:type, etc) -\u0026gt; sortie_1:type, sortie_2:type, etc\nOn d√©finit une fonction gr√¢ce au mot cl√© def en suivant la structure suivante :\n def nom(arguments s√©par√©s par des virgules) :\n\u0026lt; corps de la fonction contenant les diff√©rentes instructions \u0026gt;\n La d√©finition d\u0026rsquo;une fonction est une instruction.\ndef addition(a,b) : c = a+b print(c) On appelle une fonction en utilisant son nom et en affectant chaque argument dans les parenth√®ses qui suivent son nom.\nLes instructions du corps de la fonction sont alors ex√©cut√©e une par une et si des variables correspondant aux nom des arguments (on parle alors d'arguments formels) sont rencontr√©es, ce sont les valeurs utilis√©es lors de l\u0026rsquo;appel (les arguments effectifs) qui les remplacent.\naddition(5,2) 7 On utilise aussi le terme \u0026ldquo;param√®tre\u0026rdquo; pour d√©signer les arguments formels, c\u0026rsquo;est-√†-dire les variables qui entrent dans la d√©finition de la fonction. Et on r√©serve alors le terme argument aux valeurs donn√©es √† ces variables au moment de l\u0026rsquo;appel.\nDans l\u0026rsquo;exemple, a et b sont alors les param√®tres (= arguments formels) et 5 et 2 sont les arguments (= arguments effectifs).\n Malgr√© ce que l\u0026rsquo;affichage peut laisser croire, la fonction pr√©c√©dente ne retourne rien !\nLa valeur de c est prisonni√®re du corps de la fonction, elle n\u0026rsquo;est pas accessible dans le code principal. C\u0026rsquo;est une variable locale.\nSi on veut pouvoir acc√©der √† c ailleurs que dans la fonction, il faut l\u0026rsquo;extirper en utilisant un return.\nIl ne faut ainsi pas confondre print et return !\nLe return transforme l\u0026rsquo;appel de la fonction en expression puisqu\u0026rsquo;une valeur est retourn√©e.\nLe print n\u0026rsquo;a qu\u0026rsquo;un effet de bord. La valeur est affich√©e mais inutilisable. L\u0026rsquo;appel de la fonction n\u0026rsquo;est alors qu\u0026rsquo;une instruction et on nomme proc√©dure une telle fonction.\n Ainsi, addition(5,2) + 7 va lever une erreur : TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'.\nEn effet, comme addition ne retourne rien, Python la consid√®re de type NoneType et ne comprend pas pourquoi on cherche √† additionner quelque chose √† rien.\nArrangeons cela gr√¢ce √† un return :\ndef addition(a,b) : c = a+b return c Maintenant, addition(5,2) + 7 retourne gentiment 12.\nD√®s que l\u0026rsquo;instruction return est rencontr√©e lors de l\u0026rsquo;appel de la fonction le flot d\u0026rsquo;ex√©cution du code de la fonction est interrompu et reprend √† la ligne suivant l\u0026rsquo;appel.\ndef demo() : print(\u0026#34;Ligne ex√©cut√©e car avant le return\u0026#34;) return print(\u0026#34;Ligne non ex√©cut√©e car apr√®s le return\u0026#34;) demo() Ligne ex√©cut√©e car avant le return\nL\u0026rsquo;exemple pr√©c√©dent nous montre aussi qu\u0026rsquo;une fonction n\u0026rsquo;a pas n√©cessairement d\u0026rsquo;argument et qu\u0026rsquo;un return peut ne rien retourner (il ne sert alors qu\u0026rsquo;√† interrompre l\u0026rsquo;ex√©cution).\nComme on l\u0026rsquo;a vu pr√©c√©demment, un return, √† l\u0026rsquo;instar d\u0026rsquo;un break, peut donc interrompre une boucle dans le corps d\u0026rsquo;une fonction.\nL\u0026rsquo;appel d\u0026rsquo;une fonction est la valeur qu\u0026rsquo;elle retourne, qu\u0026rsquo;il s\u0026rsquo;agisse d\u0026rsquo;un entier, d\u0026rsquo;une liste, d\u0026rsquo;un dictionnaire, etc.\nUne fonction peut retourner plusieurs variables s√©par√©es par des virgules. L\u0026rsquo;appel est alors un tuple qui peut √™tre d√©ball√©.\ndef somme_moyenne(liste) : s = 0 for e in liste : s += e m = s/len(liste) return s,m L = [1,2,3,4] print(type(somme_moyenne(L))) a,b = somme_moyenne(L) print(\u0026#34;somme :\u0026#34;,a,\u0026#34;et moyenne :\u0026#34;,b) print(somme_moyenne(L)[1]) \u0026lt;class 'tuple'\u0026gt;\nsomme : 10 et moyenne : 2.5\n2.5\nUne fonction peut aussi ne pas avoir d\u0026rsquo;argument :\ndef HelloWorld() : print(\u0026#39;\\x4B\\x49\\x4C\\x4C\\n\\x41\\x4C\\x4C\\n\\x48\\x55\\x4D\\x41\\x4E\u0026#39;) "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_1/tp4dicho/",
	"title": "TP 4 : algorithmes dichotomiques",
	"tags": [],
	"description": "",
	"content": "Algorithmes dichotomiques Cliquez sur cette invitation pour r√©cup√©rer le repository du TP. Recherche dichotomique L\u0026rsquo;algorithme de recherche mis au point dans le tp1 compte dans le pire des cas autant d\u0026rsquo;√©tapes que l\u0026rsquo;ensemble scrut√© contient d\u0026rsquo;√©l√©ments.\nPeut-on faire mieux ?\nDans le cas, d\u0026rsquo;un ensemble ordonn√© tri√©, la r√©ponse est oui. On peut m√™me faire beaucoup mieux !\nImaginons que l\u0026rsquo;on cherche une carte dans un jeu tri√© en ordre croissant. L\u0026rsquo;id√©e est de regarder d\u0026rsquo;abord au milieu du paquet. Si la carte du milieu est plus petite (repectivement plus grande) que la carte cherch√©e, on en d√©duit que celle-ci ne peut √™tre que dans la deuxi√®me partie (respectivement dans la premi√®re partie) du paquet (si elle est bien pr√©sente).\nOn peut alors se d√©barrasser de la moiti√© des cartes environ et on recommence la man≈ìuvre avec les cartes restantes.\n  Voil√† ci-dessous une tentative d\u0026rsquo;impl√©mentation de cet algorithme :\ndef recherche_dicho(L,x) : n = len(L) g, d = 0, n-1 while g \u0026lt; d : i = (g + d)//2 if x \u0026lt; L[i] : d = i - 1 elif x \u0026gt; L[i] : g = i + 1 else : return True return False  Testez cet algorithme et constatez qu\u0026rsquo;il contient une erreur.\nRecopier ci-dessous une liste tri√©e et un √©l√©ment √† rechercher qui mettent en √©chec l\u0026rsquo;algorithme.\n  Corrigez l\u0026rsquo;algorithme recherche_dicho_corr en ajoutant un seul caract√®re.\nAttention, tout autre ajout, m√™me un espace, rendra faux l\u0026rsquo;exercice.\n La figure suivante est un arbre binaire d√©crivant tous les chemins possibles que prend l\u0026rsquo;algorithme √† partir d\u0026rsquo;une liste de 16 √©l√©ments (en vert, le nombre d\u0026rsquo;√©l√©ments restant).\nCet algorithme peut se montrer bien plus rapide que la recherche simple du TP1.\nR√©ouvrons la liste de mots de passe du TP2 mais en la transformant en liste de mots plut√¥t qu\u0026rsquo;en long texte.\n# importation de la classique liste de mots de passe rockyou (cela prend quelques secondes) from urllib.request import urlopen url = \u0026#39;http://cordier-phychi.toile-libre.org/Info/github/rockyou.txt\u0026#39; rockyou = urlopen(url).read().decode(\u0026#39;latin-1\u0026#39;).split() rockyou = sorted(rockyou) print(len(rockyou),\u0026#39;mots de passe\u0026#39;) 14445388 mots de passe\ndef trouve_indice(L, x): \u0026#39;\u0026#39;\u0026#39; trouve_indice(L : liste, x : type des √©l√©ments de L) -\u0026gt; soit un entier, soit un bool√©en postcondition : renvoie l\u0026#39;indice d\u0026#39;un √©l√©ments x lorsqu\u0026#39;il est pr√©sent dans la liste L et renvoie False lorsqu\u0026#39;il est absent \u0026#39;\u0026#39;\u0026#39; for indice, element in enumerate(L): if element == x: return indice return False Rq : enumerate est une fonction native souvent tr√®s pratique.\nhelp(enumerate) Help on class enumerate in module builtins: class enumerate(object) | enumerate(iterable, start=0) | | Return an enumerate object. | | iterable | an object supporting iteration | | The enumerate object yields pairs containing a count (from start, which | defaults to zero) and a value yielded by the iterable argument. | | enumerate is useful for obtaining an indexed list: | (0, seq[0]), (1, seq[1]), (2, seq[2]), ... | | Methods defined here: | | __getattribute__(self, name, /) | Return getattr(self, name). | | __iter__(self, /) | Implement iter(self). | | __next__(self, /) | Implement next(self). | | __reduce__(...) | Return state information for pickling. | | ---------------------------------------------------------------------- | Static methods defined here: | | __new__(*args, **kwargs) from builtins.type | Create and return a new object. See help(type) for accurate signature. from time import time from random import randint import matplotlib.pyplot as plt plt.style.use(\u0026#39;seaborn\u0026#39;) plt.rcParams[\u0026#39;figure.figsize\u0026#39;] = (15, 6) Indice, T_ch = [], [] liste_noms = [\u0026#39;567890\u0026#39;,\u0026#39;billgates\u0026#39;,\u0026#39;dollars\u0026#39;,\u0026#39;jklmno\u0026#39;,\u0026#39;pupuce\u0026#39;,\u0026#39;zorro\u0026#39;] for nom in liste_noms: start = time() i = trouve_indice(rockyou,nom) stop = time() Indice.append(i) T_ch.append(stop-start) print(f\u0026#34;{stop -start:.2e} s pour trouver \u0026#39;{nom}\u0026#39; qui est √† la position {i}\u0026#34;) plt.plot(Indice,T_ch,\u0026#39;--\u0026#39;) plt.plot(Indice,T_ch,\u0026#39;o\u0026#39;,c=\u0026#39;C2\u0026#39;) plt.xlabel(\u0026#34;Position dans la liste\u0026#34;) plt.ylabel(\u0026#34;Temps pour trouver le nom (s)\u0026#34;) 1.84e-01 s pour trouver '567890' qui est √† la position 2612528\n3.93e-01 s pour trouver 'billgates' qui est √† la position 5584305\n4.85e-01 s pour trouver 'dollars' qui est √† la position 6925245\n6.32e-01 s pour trouver 'jklmno' qui est √† la position 8867150\n8.32e-01 s pour trouver 'pupuce' qui est √† la position 11949039\n1.01e+00 s pour trouver 'zorro' qui est √† la position 14416270\n Comment semble √©voluer le temps de recherche en fonction de la position dans la liste ?\n Avec l\u0026rsquo;algorithme de recherche dichotomique, on obtient :\nT_ch = [] liste_noms = [\u0026#39;567890\u0026#39;,\u0026#39;billgates\u0026#39;,\u0026#39;dollars\u0026#39;,\u0026#39;jklmno\u0026#39;,\u0026#39;pupuce\u0026#39;,\u0026#39;zorro\u0026#39;] for i,nom in zip(Indice,liste_noms): start = time() recherche_dicho_corr(rockyou,nom) stop = time() T_ch.append(stop-start) print(f\u0026#34;{stop -start:.2e} s pour trouver {nom} qui est √† la position {i}\u0026#34;) plt.plot(Indice,T_ch,\u0026#39;--\u0026#39;) plt.plot(Indice,T_ch,\u0026#39;o\u0026#39;,c=\u0026#39;C2\u0026#39;) for i in range(len(liste_noms)) : plt.text(Indice[i]+max(Indice)/100,T_ch[i],liste_noms[i]) plt.xlabel(\u0026#34;Position dans la liste (s)\u0026#34;) plt.ylabel(\u0026#34;Temps pour trouver le nom\u0026#34;) plt.savefig(\u0026#39;graph.png\u0026#39;,dpi=600) 1.41e-05 s pour trouver 567890 qui est √† la position 2612528\n1.41e-05 s pour trouver billgates qui est √† la position 5584305\n1.10e-05 s pour trouver dollars qui est √† la position 6925245\n2.19e-05 s pour trouver jklmno qui est √† la position 8867150\n1.12e-05 s pour trouver pupuce qui est √† la position 11949039\n1.41e-05 s pour trouver zorro qui est √† la position 14416270\nOn constate que l\u0026rsquo;algorithme dichotomique met beaucoup moins de temps et qu\u0026rsquo;il ne semble pas d√©pendre clairement de la position de l\u0026rsquo;√©l√©ment.\nTentons de comparer le comportement des deux algorithmes quand la longueur de la liste augmente.\nQuel que soit l\u0026rsquo;algorithme de recherche, la pire situation possible correspond √† la recherche d\u0026rsquo;un √©l√©ment absent de la liste.\nSe placer dans ce pire des cas permet une comparaison plus s√ªre des algorithmes ; on sait √† quoi s\u0026rsquo;attendre !\nMesurer un temps d√©pend de trop de param√®tres (processeur, utilisation de la m√©moire par le syst√®me, etc.).\nUne information plus universelle est le nombre d\u0026rsquo;√©tapes de l\u0026rsquo;algorithme.\nPlus pr√©cis√©ment, concentrons sur le nombre de comparaisons entre l\u0026rsquo;√©l√©ment recherch√© x et les √©l√©ments de la liste L.\nOn a construit ci-dessous la fonction trouve_indice_etapes dont la description est donn√©e :\ndef trouve_indice_etapes(L,x): \u0026#34;\u0026#34;\u0026#34; trouve_indice_etapes(liste : list, valeur : type des √©l√©ments de la liste) -\u0026gt; bool, int postcondition : retourne √† la fois un bool√©en qui traduit la pr√©sence ou non de l\u0026#39;√©l√©ment et un entier correspondant au nombre de comparaisons effectu√©es entre x et les √©l√©ments de L \u0026#34;\u0026#34;\u0026#34; nb_comp = 0 for indice, element in enumerate(L): nb_comp += 1 if element == valeur: return True,nb_comp return False,nb_comp  √Ä vous de jouer pour construire sur le m√™me mod√®le recherche_dico_etapes :\n def recherche_dicho_etapes(L,x) : \u0026#34;\u0026#34;\u0026#34; recherche_dicho_etapes(liste : list, valeur : type des √©l√©ments de la liste) -\u0026gt; bool, int postcondition : doit retourner √† la fois un bool√©en qui traduit la pr√©sence ou non de l\u0026#39;√©l√©ment et un entier correspondant au nombre de comparaisons effectu√©es entre x et les √©l√©ments de L \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE Maintenant, comparons :\nimport pandas as pd NB_elts, NB_comp = [], [] nom = \u0026#39;???#!!!\u0026#39; liste_longueurs = [10*2**i for i in range(1,19)] for longueur in liste_longueurs: start = time() nb_comp = trouve_indice_etapes(rockyou[:longueur],nom)[1] stop = time() NB_elts.append(longueur) NB_comp.append(nb_comp) d = {\u0026#39;taille\u0026#39; : NB_elts,\u0026#39;# comparaisons\u0026#39;: NB_comp} tableau = pd.DataFrame(data=d) display(tableau) fig, axs = plt.subplots(2,figsize=(15,12)) axs[0].plot(NB_elts,NB_comp,\u0026#39;--\u0026#39;) axs[0].plot(NB_elts,NB_comp,\u0026#39;o\u0026#39;,c=\u0026#39;C2\u0026#39;) axs[1].semilogx(NB_elts,NB_comp,\u0026#39;--\u0026#39;) axs[1].semilogx(NB_elts,NB_comp,\u0026#39;o\u0026#39;,c=\u0026#39;C2\u0026#39;) axs[0].set(xlabel=\u0026#39;Longueur de la liste\u0026#39;, ylabel=\u0026#39;Nb de comparaisons\u0026#39;) axs[1].set(xlabel=\u0026#39;Longueur de la liste (axe logarithmique)\u0026#39;, ylabel=\u0026#39;Nb de comparaisons\u0026#39;)   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    taille # comparaisons     0 20 20   1 40 40   2 80 80   3 160 160   4 320 320   5 640 640   6 1280 1280   7 2560 2560   8 5120 5120   9 10240 10240   10 20480 20480   11 40960 40960   12 81920 81920   13 163840 163840   14 327680 327680   15 655360 655360   16 1310720 1310720   17 2621440 2621440     NB_elts, NB_comp = [], [] nom = \u0026#39;???#!!!\u0026#39; liste_longueurs = [10*2**i for i in range(1,19)] for longueur in liste_longueurs: start = time() nb_comp = recherche_dicho_etapes(rockyou[:longueur],nom)[1] stop = time() NB_elts.append(longueur) NB_comp.append(nb_comp) d = {\u0026#39;taille\u0026#39; : NB_elts,\u0026#39;# comparaisons\u0026#39;: NB_comp} tableau = pd.DataFrame(data=d) display(tableau) fig, axs = plt.subplots(2,figsize=(15,12)) axs[0].plot(NB_elts,NB_comp,\u0026#39;--\u0026#39;) axs[0].plot(NB_elts,NB_comp,\u0026#39;o\u0026#39;,c=\u0026#39;C2\u0026#39;) axs[1].semilogx(NB_elts,NB_comp,\u0026#39;--\u0026#39;) axs[1].semilogx(NB_elts,NB_comp,\u0026#39;o\u0026#39;,c=\u0026#39;C2\u0026#39;) axs[0].set(xlabel=\u0026#39;Longueur de la liste\u0026#39;, ylabel=\u0026#39;Nb de comparaisons\u0026#39;) axs[1].set(xlabel=\u0026#39;Longueur de la liste (axe logarithmique)\u0026#39;, ylabel=\u0026#39;Nb de comparaisons\u0026#39;)   .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    taille # comparaisons     0 20 5   1 40 6   2 80 7   3 160 8   4 320 9   5 640 10   6 1280 11   7 2560 12   8 5120 13   9 10240 14   10 20480 15   11 40960 16   12 81920 17   13 163840 18   14 327680 19   15 655360 20   16 1310720 21   17 2621440 22     Recherche dichotomique d\u0026rsquo;une racine On cherche √† appliquer la m√©thode de la dichotomie (d√©coupage en deux syst√©matique d\u0026rsquo;un intervalle) √† la recherche d\u0026rsquo;une racine.\nPlus pr√©cis√©ment, on souhaite d√©terminer une approximation d‚Äôune racine (ou z√©ro) sur un intervalle $[a, b]$, avec une pr√©cision $Œµ$, d‚Äôune fonction continue et monotone $f$ sur cet intervalle et telle que $f(a)$ et $f(b)$ sont de signes oppos√©s ($f(a)f(b)‚â§0)$. Elle consiste √† comparer le signe de l‚Äôimage $f\\left(\\frac{a + b}{2}\\right)$ du milieu de l‚Äôintervalle $[a, b]$ avec le signe de $f(a)$ et $f(b)$ pour r√©duire l‚Äôintervalle de recherche de mani√®re it√©rative.\nPour d√©terminer $x_0$, racine de la fonction $f$, strictement monotone sur l‚Äôintervalle $[a, b]$, avec une pr√©cision $Œµ,$ on proc√®de comme suit :\n On d√©termine le milieu de l‚Äôintervalle $m = \\frac{a+b}{2}$ ; On compare le signe de $f(m)$ avec celui de $f(a)$ et $f(b)$ pour d√©terminer dans quel intervalle $[a, m]$ ou $[m, b]$ se trouve la racine $x_0$ ; On affecte √† $a$ (resp. $b$) la valeur de $m$ si la racine se trouve entre $m$ et $b$ (resp. $a$) ; On it√®re tant que $|a ‚àí b| \u0026gt; Œµ$, (Œµ est la pr√©cision d√©finie initialement), et on renvoie $m$.   Construisez une fonction racine prenant en argument une fonction f, les bornes d\u0026rsquo;un intervalle a et b, et une pr√©cision eps et retournant la racine ainsi que le nombre d\u0026rsquo;it√©rations n√©cessaires. Vous vous assurerez gr√¢ce √† un assert qu\u0026rsquo;au moins une racine existe bel et bien dans l\u0026rsquo;intervalle choisi et vous s√©curiserez la boucle while en ajoutant une condition emp√®chant l\u0026rsquo;algorithme d\u0026rsquo;utiliser plus de 100 it√©rations.\n def racine(f,a,b,eps) : \u0026#34;\u0026#34;\u0026#34; racine(f : fonction, a : flottant, b : flottant, eps : flottant) -\u0026gt; racine : flottant, nbiter : entier pr√©condition : f doit √™tre une fonction n\u0026#39;ayant qu\u0026#39;un argument (un flottant) et ne retournant qu\u0026#39;un flottant. \u0026#34;\u0026#34;\u0026#34; ### BEGIN SOLUTION  Comment √©volue l\u0026rsquo;accroissement du nombre d\u0026rsquo;iterations en fonction de l\u0026rsquo;accroissement du nombre de chiffres significatifs obtenus pour la racine ?\n "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_2/tp8correc/",
	"title": "TP 8 : correction et complexit√©",
	"tags": [],
	"description": "",
	"content": "TP 8 : correction et complexit√© Cliquez sur cette invitation pour r√©cup√©rer le repository du TP. Multiplication √©gyptienne Consid√©rons le code suivant, qui impl√©mente un ancien algorithme √©gyptien.\na et b sont suppos√©s √™tre des entiers positifs.\ndef multegy(a, b) : p = 0 while a \u0026gt; 0 : if a%2 == 1 : p += b b *= 2 a //= 2 return p  Qui est le variant de boucle permettant de prover que meltegy termine toujours ?\n a : a b : b c : p d : autre r√©ponse    D√©taillez l\u0026rsquo;√©x√©cution de multegy(23,5) en affectant √† a_i, b_i, c_i, les valeurs rencontr√©es √† chaque it√©ration.\n Construisons la preuve de l\u0026rsquo;algorithme :\non va montrer que $a\\times b + p$ est un invariant de boucle et l\u0026rsquo;utiliser pour prouver que l\u0026rsquo;algorithme retourne bien le produit entre $a$ et $b$.\nNotons $a_k$, $b_k$, $p_k$, les valeurs de $a$, $b$ et $p$ apr√®s la ke it√©ration et supposons $a_k\\times b_k + p_k = cste$.\n initialisation : pour $k=0$, $a_0=a$, $b_0=b$ et $p_0=0$. D\u0026rsquo;o√π $a_0\\times b_0+p_0=a\\times b$ conservation : √† la boucle $k+1$, deux cas se pr√©sentent :  si $a$ est impair : $a_{k+1} = X$, $b_{k+1} = Y$ et $p_{k+1}= Z$.\nD\u0026rsquo;o√π $a_{k+1}\\times b_{k+1} + p_{k+1} = a_k\\times b_k - b_k +p_k+ b_k = a_k\\times b_k+p_k$ si $a$ est pair : $a_{k+1} = \\frac{a_k}{2}$, $b_{k+1} = b_k\\times 2$ et $p_{k+1}=p_k$.\nD\u0026rsquo;o√π $a_{k+1}\\times b_{k+1} + p_{k+1} = a_k\\times b_k + p_k$\nPar cons√©quent, $a_k\\times b_k + p_k$ est bien un invariant pour tout $k$.   terminaison : en sortie de boucle (it√©ration $f$), $a_f = 0$, donc $a_f\\times b_f+p_f = p_f$. Or comme l\u0026rsquo;invariant est\u0026hellip; invariant, il garde toujours la valeur qu\u0026rsquo;il poss√®de en entr√©e (pour $k=0$) : d\u0026rsquo;o√π $p_f = a\\times b$. Et comme la fonction retourne $p_f$, cqfd.   Que vallent X,Y et Z ?\n a : $a_k$, $b_k$, $p_k+b_k$ b : $\\frac{a_k-1}{2}$, $b_k\\times 2$, $p_k+b_k$ c : $\\frac{a_k+1}{2}$, $b_k\\times 2$, $p_k$    Quelle est la complexit√© de multegy (en supposant chacun des calculs comme √©l√©mentaire) ?\n a : $O(a)$ b : $O(a\\times b)$ c : $O(a\\log b)$ d : $O(\\log a)$ e : $O(b)$   ¬†Deux fonctions de recherche def cherche(s, m) : for k in range(len(s) - len(m) + 1) : b = True for i in range(len(m)) : if s[k + i] != m[i] : b = False if b : return True return False def cherche2(s, m) : for k in range(len(s) - len(m) + 1) : if s[k:k + len(m)] == m : return True return False  Quelle est la complexit√© de la fonction cherche ? Et celle de cherche2 ?\nAppelons len(s) n et len(m) p.\n a : les deux en $O(n\\times p)$ b : cherche en $O(n\\times p)$ et cherche2 en en $O(n)$ c : une autre r√©ponse   Ex√©cuter le code suivant peut vous aider √† confirmer votre r√©ponse.\nimport time from random import randint abc = \u0026#39;abcdefghijklmnopqrstuvwxyz\u0026#39; def motdenlettres(n) : mot = \u0026#39;\u0026#39; for i in range(n) : mot += abc[randint(0,25)] return mot print(\u0026#39;-\u0026#39;*30) print(\u0026#39;| n | p | cherche2 |\u0026#39;) print(\u0026#39;-\u0026#39;*30) for j in range(2,6) : n = 10**5*2**j s = motdenlettres(n) for k in range(3) : p = 10**4*2**k m = motdenlettres(p) d = time.time() cherche2(s,m) f = time.time() t = f - d print(f\u0026#39;|{n:^9d}|{p:^8d}|{t:^10.2E}|\u0026#39;) print(\u0026#39;-\u0026#39;*30)  Quelle est la complexit√© au meilleur de la fonction cherche ?\n a : $O(n)$ b : $O(p)$ c : $O(1)$   Remarque :\nOn peut d√©terminer ce que fait la fonction cherche en mettant en lumi√®re deux invariants, un pour chaque boucle.\nLa boucle interne a pour invariant \u0026ldquo;b √©quivaut √† s[k:k+i]==m[:i]\u0026rdquo;.\nEt la boucle externe a pour invariant \u0026ldquo;s[j:j+len(m)] != m pour tout j\u0026lt;k\u0026rdquo; car s\u0026rsquo;il y avait √©galit√©, on serait sorti de la boucle avec le return True.\nOn en conclut que si la boucle n‚Äôest jamais interrompue par le return True alors m n‚Äôest pas un sous-mot de s.\nSi la boucle est interrompue, d‚Äôapr√®s l‚Äôinvariant de la boucle int√©rieure, on a trouv√© m dans s.\n"
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_2/nombre/",
	"title": "Les nombres en machine",
	"tags": [],
	"description": "",
	"content": "Repr√©sentation des nombres Comment un nombre est-il repr√©sent√© √† l\u0026rsquo;int√©rieur d\u0026rsquo;un ordinateur ?\nL\u0026rsquo;espace pour repr√©senter un nombre en machine est limit√©. Si cette limitation n\u0026rsquo;a pas trop d\u0026rsquo;impact pour les entiers (surtout en Python !) elle devient tr√®s handicapante pour repr√©senter les r√©els.\nLa repr√©sentation machine d\u0026rsquo;un nombre est appel√©e mot machine. Sa taille est g√©n√©ralement aujourd\u0026rsquo;hui de 64 bits.\n ¬†Les diff√©rentes bases Une √©criture en base $b$ utilise $b$ chiffres diff√©rents :\n 0, 1, 2, 3, 4, 5, 6, 7, 8 et 9 pour la base d√©cimale 0 et 1 pour la base binaire 0, 1, 2, 3 pour la base 4 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E et F pour la base hexad√©cimale  Un nombre $a$ √©crit dans une basse $b$ se note $(a_n a_{n-1}\\cdots a_0)_b$ avec $(a_n a_{n-1}\\cdots a_0)_b = a_n\\times b^n + a_{n-1} \\times b^{n-1}+ \\cdots + a_0 = \\sum\\limits_{i=0}^{n} a_i,b^i$\n¬†Conversions La conversion d‚Äôune base √† une autre n‚Äôest pas un objectif de formation d\u0026rsquo;apr√®s le B.O. N√©anmoins, la comparaison et les pi√®ges des algorithmes qui suivent d√©passent le simple enjeu de la conversion. Moralit√©, pas besoin d\u0026rsquo;apprendre par c≈ìur ces algorithmes, mais leur √©tude est conseill√©e.\n  Pour convertir un nombre d\u0026rsquo;une base $b\u0026lt;10$ vers la base 10 :  Il suffit de calculer la somme pr√©c√©dente (si $b\u0026gt;10$, il faut en plus donner la valeur des nouveaux chiffres).\nComparaison de deux algorithmes :\n Algorithme classique :  def convbvers10(a,b) : \u0026#34;\u0026#34;\u0026#34; Convertit a de la base b √† la base 10 le nombre √† convertir a doit √™tre pass√© en argument sous la forme d\u0026#39;une chaine de caract√®res \u0026#39;a_n...a_0\u0026#39; b, la base, est un entier inf√©rieur √† 10. La fonction retourne un entier en base 10. \u0026#34;\u0026#34;\u0026#34; s = 0 n = len(a)-1 for e in a : s += int(e)*b**n n -= 1 return s convbvers10(\u0026#39;100101101\u0026#39;,2) 301\nconvbvers10(\u0026#39;10231\u0026#39;,4) 301\n M√©thode de Horner (qui utilise des multiplications imbriqu√©es) :  $a = ((((a_nb+a_{n-1})b+a_{n-2})b+\\cdots)b+a_1)b+a_0$\nImpl√©ment√©e en Python, cela donne :\ndef convbvers10_Horner(a,b) : \u0026#34;\u0026#34;\u0026#34; Convertit a de la base b √† la base 10 en utilisant la m√©thode de Horner le nombre √† convertir a doit √™tre pass√© en argument sous la forme d\u0026#39;une chaine de caract√®res \u0026#39;a_n...a_0\u0026#39; b, la base, est un entier inf√©rieur √† 10. La fonction retourne un entier en base 10. \u0026#34;\u0026#34;\u0026#34; s = 0 for i in range(0,len(a)) : s = s*b + int(a[i]) return(s) convbvers10_Horner(\u0026#39;100101101\u0026#39;,2) 301\n Lequel de ces deux algorithmes est le plus eficace ?\n ¬†la fonction Python native int() permet aussi de convertir un nombre √©crit dans une base $b$ vers la base d√©cimale en ajoutant $b$ en argument.\n int(\u0026#39;10231\u0026#39;,4) 301\n¬† Pour convertir de la base 10 vers la base $b$ :  On peut remarquer que le quotient de la division euclidienne de $a=(a_n a_{n-1}\\cdots a_0)_b$ par $b$ vaut $(a_n a_{n-1}\\cdots a_1)_b$ et que le reste vaut $a_0$. De m√™me, le quotient de la division euclidienne de $(a_n a_{n-1}\\cdots a_1)_b$ par $b$ vaut $(a_n a_{n-1}\\cdots a_2)_b$ et le reste vaut $a_1$. Et on continue tant que le quotient est non nul. On obtient ainsi la d√©composition de $a$ dans la base $b$.\nUn algorithme en d√©coule naturellement :\ndef conv10versb(a,b) : \u0026#34;\u0026#34;\u0026#34; Arguments : nombre √† convertir et base cible la fonction retourne une cha√Æne de caract√®re correspondant au nombre a dans la base b. \u0026#34;\u0026#34;\u0026#34; s = \u0026#39;\u0026#39; while a \u0026gt; 0 : s = str(a%b) + s # le dernier terme est ajout√© √† gauche de la cha√Æne ! a //= b return s conv10versb(301,2) '100101101'\n¬†les fonctions Python natives bin() et hex() permettent de convertir directement un nombre de la base 10 vers les bases respectives 2 et 16 (ces fonctions retournent des cha√Ænes de caract√®res).\n bin(301,2) '0b100101101'\n¬†Usages des diff√©rentes bases  La base binaire :  C\u0026rsquo;est la base naturelle de l\u0026rsquo;ordinateur. Avec ses deux caract√®res (0 et 1), c\u0026rsquo;est la seule que peut adresser directement un ordinateur dont la nature m√™me n\u0026rsquo;est qu\u0026rsquo;interrupteurs, passant ou non. Chaque bit est un chiffre binaire.\nEn base 2, les calculs sont facilit√©s et la plupart des algorithmes scolaires des op√©rations de base marchent, voir sont simplifi√©s.\nPrenons l\u0026rsquo;exemple de la multiplication : chaque 1 du second facteur d√©cale le premier facteur d\u0026rsquo;autant de rangs que son propre rang dans le second facteur, puis on additionne entre eux tous les diff√©rents termes obtenus (on utilisera cette m√©thode dans l\u0026rsquo;algorithme de multiplication √©gyptienne du TP8) .\nEn Python, on peut √©crire un nombre directement en base 2 si on le pr√©c√®de des caract√®res 0b.\na = 0b1011011 b = 0b1011 a*b bin(a*b) '0b1111101001'\n¬† La base hexad√©cimale :  La base 16 joue un r√¥le particulier en informatique. Pour quelle raison ? L‚Äô√©criture binaire d‚Äôun nombre pr√©sente l‚Äôinconv√©nient d‚Äô√™tre tr√®s longue. Une base plus √©lev√©e est √† cet √©gard pr√©f√©rable. Le choix de la base 10 pourrait para√Ætre naturel, mais malheureusement, convertir un nombre de la base 10 √† la base 2 ou inversement n‚Äôest pas simple. En revanche, nous allons voir que passer de la base 2 √† la base 16 est naturel.\nPour √©crire un nombre en base 16, nous avons besoin d‚Äôun caract√®re pour chacun des entiers de 0 √† 15 ; on compl√®te donc les chiffres de 0 √† 9 par les lettres a, b, c, d, e et f.\nAinsi, $(\\text{a})_{16} = 10$, $(\\text{b})_{16} = 11$, $(\\text{c})_{16} = 12$, $(\\text{d})_{16} = 13$, $(\\text{e})_{16} = 14$, $(\\text{f})_{16} = 15$.\nSachant que $2^4 = 16$, tout nombre √©crit en base 2 √† l‚Äôaide de 4 chiffres s‚Äô√©crit en base 16 √† l‚Äôaide d‚Äôun seul chiffre :\nAussi, pour convertir un nombre quelconque de la base 2 √† la base 16, il suffit de regrouper les chiffres qui le composent par paquet de 4 et convertir chacun de ces paquets en un chiffre en base 16.\nPar exemple $(1100,0111,1110,1011)_2$ = $(\\text{c}7\\text{eb})_{16}$.\nUn octet (8 bits) est donc repr√©sent√© par au plus deux caract√®res hexad√©cimaux, ce qui explique l\u0026rsquo;int√©r√™t de cette base (les octets, unit√© de m√©moire, sont partout en informatique).\nExemple : une couleur peut √™tre d√©finie par trois octets repr√©sentant ses composantes RVB. Ci-dessous, chaque mot de 3 octets sert aussi √† coder la couleur en HTML :\nff0000 ¬†00ff00 ¬†0000ff ¬†aa00aa ¬†777777 ¬†a3850e ¬†07ab98  (code HTML du dernier mot : \u0026lt;font color=#07ab98\u0026gt; 07ab98 \u0026lt;/font\u0026gt;)\n$256^3 = 16\\,777\\,216$ couleurs diff√©rentes sont ainsi accessibles.\nChoix couleur :  Comme pour les nombres binaires, Python permet d\u0026rsquo;√©crire directement en base 16 si on pr√©c√®de le nombre des caract√®res 0x.\n0xd 13\nbin(0xd) '0b1101'\nhex(0b11110111) '0xf7'\nLa plus \u0026ldquo;efficace\u0026rdquo; des bases est la base ternaire, suivie de pr√®s par la base binaire (o√π la notion d\u0026rsquo;efficacit√© est d√©finie dans l\u0026rsquo;article en lien).\n ¬†Codage des nombres entiers en machine Nombres entiers naturels Les entiers naturels sont essentiellement utilis√©s pour repr√©senter les adresses en m√©moire.\nUn mot machine de n bits permet de repr√©senter tous les nombres naturels compris entre 0 et $2^n ‚àí 1$. Ainsi, un octet permet de coder les entiers allant de $0 = (00)_{16} = (0000,0000)_2$ √† $255 = (\\text{ff})_{16} = (1111,1111)_2$, et 64 bits (soit 8 octets) tous les nombres allant de $0 = (0000,0000,0000,0000)_{16}$ √† $2^{64}‚àí1 = (\\text{ffff},\\text{ffff},\\text{ffff},\\text{ffff})_{16}$.\nNombres entiers relatifs Il faut un bit suppl√©mentaire pour coder le signe. Le premier bit, 0 pour un nombre positif et 1 pour un nombre n√©gatif, est donc r√©serv√©.\nAinsi, le plus grand entier relatif repr√©sentable sur n bits vaut $2^{n-1}-1$. Pour un processeur 64 bits, cela correspond √† $2^{63}-1=(7\\text{fff},\\text{ffff},\\text{ffff},\\text{ffff})_{16}$\n2**63-1 9223372036854775807\n¬† codage binaire naturel sign√©  La m√©thode paraissant la plus simple pour coder les nombres relatifs est alors le codage binaire naturel sign√© : on place le bit de signe devant la valeur absolue de l\u0026rsquo;entier cod√© normalement sur $n-1$ bits. Par exemple, sur 4 bits, 3 est cod√© par le mot 0011 et -3 par 1011.\nSimple, oui, mais cela pose 2 probl√®mes :\n il y a 2 repr√©sentations de 0 (les mots 0000 et 1000 sur 4 bits), les op√©rations arithm√©tiques ne sont pas faciles (l\u0026rsquo;addition \u0026ldquo;normale\u0026rdquo; de 3 et -3 cod√©s ainsi sur 4 bits donnerait 1110, soit -6\u0026hellip;).  ¬† compl√©ment √† 2  La solution qui a √©t√© adopt√©e pour √©viter ces probl√®mes est le compl√©ment √† 2 :\nCe codage d√©coule du probl√®me pos√© par l\u0026rsquo;addition pr√©c√©dente : comment faire pour que l\u0026rsquo;addition de 2 nombres oppos√©s vaille 0 ? La solution est d\u0026rsquo;utiliser l\u0026rsquo;absence du bit $n+1$ dans un codage √† $n$ bits. Par exemple, √† 4 bits, si on additionne $5$ ($0101$) avec $11$ ($1011$), on obtient $16$ ($\\color{red}{1}\\color{green}{0000}$) qui devient $0$ ($\\color{green}{0000}$) puisqu\u0026rsquo;il n\u0026rsquo;y a pas de 5e bit. Il suffit donc d\u0026rsquo;associer 11 √† -5, et de la m√™me fa√ßon, 8 √† -8, 9 √† -7, 10 √† -6, 12 √† -4, 13 √† -3, 14 √† -2, et 15 √† -1.\nDe mani√®re g√©n√©rale, pour un codage sur n bits, les $2^{n-1}$ premiers entiers, tous commen√ßants par 0, sont les entiers positifs et on associe les $2^{n-1}$ entiers suivants, commen√ßant par 1, donc n√©gatifs, de fa√ßon √† ce qu\u0026rsquo;il compl√®te chaque entier positif √† la puissance de 2 sup√©rieure, $2^n$ (d\u0026rsquo;o√π \u0026ldquo;compl√©ment √† 2\u0026rdquo;).\nLes nombres n√©gatifs sont donc plac√©s au-dessus plut√¥t qu\u0026rsquo;en dessous et on peut visualiser √ßa comme un enroulement sur un cercle des nombres positifs et n√©gatifs.\nEn pratique, si on veut le mot codant -3, il suffit d\u0026rsquo;inverser chaque bit du codage de 3 et d\u0026rsquo;ajouter 1¬†:\n$0011 \\rightarrow 1100$\n$1100+1 = 1101$\ndonc $-3 \\rightarrow 1101$\n ¬†D√©passement de capacit√© : On remarque qu\u0026rsquo;avec ce type de codage, un d√©passement de capacit√© (ou overflow en anglais) ne l√®vera pas d\u0026rsquo;erreur, mais aboutira √† des valeurs aberrantes.\nSupposons par exemple que l\u0026rsquo;on veuille additionner 5 et 7 sur un codage 4 bits. On obtiendra\u0026hellip; -4¬†!\n¬†  ¬†C\u0026rsquo;est un bug de ce type, un overflow, qui a fait exploser la fus√©e Ariane 5 lors de son vol inaugural (le vol 501) causant la perte de la fus√©e et de sa charge utile (4 satellites). Ce bug est un des plus co√ªteux de l\u0026rsquo;histoire (370 millions d\u0026rsquo;euros).\nC\u0026rsquo;est au niveau de la plateforme inertielle (ensemble des capteurs, acc√©l√©rom√®tres et gyroscopes, permettant de guider la fus√©e), h√©rit√©e de la fus√©e pr√©c√©dente Ariane 4, que le bug apparut. Plus pr√©cis√©ment, c\u0026rsquo;est le capteur d\u0026rsquo;acc√©l√©ration horizontale qui fut d√©bord√© pendant sa phase de calibrage (lors des premi√®res 40 s du vol). Cod√©e sur 8 bits, la valeur d\u0026rsquo;acc√©l√©ration maximum repr√©sentable √©tait donc de $2^7-1=127$, ce qui √©tait suffisant pour Ariane 4 (valeur max : 64). Mais plus puissante et avec une trajectoire de d√©collage diff√©rente, Ariane 5 engendre des acc√©l√©rations horizontales qui peuvent √™tre jusqu\u0026rsquo;√† 5 fois plus fortes pendant la phase de d√©collage (valeur max : 300). Cela aboutit √† une valeur absurde que le guidage essaya de compenser\u0026hellip; boom.\nEt comble de la frustration : ce calibrage en d√©but de vol √©tait devenu inutile pour Ariane 5.\n¬†Qu\u0026rsquo;en est-il de Python ?\nContrairement √† la plupart des langages, Python n\u0026rsquo;alloue pas de taille √† priori aux entiers. Par cons√©quent, ils peuvent d√©passer la taille maximale adressable par le processeur et sont donc de pr√©cision arbitraire, la seule limite √©tant la taille totale de la RAM.\n2**200 1606938044258990275541962092341162602522202993782792835301376\nSi cela facilit√© pas mal les op√©rations arithm√©tiques sur les grands nombres, cela complique l\u0026rsquo;√©tude de la complexit√©, car si un entier prend plusieurs mots m√©moires, la plupart de ses manipulations ne sont plus des √©tapes √©l√©mentaires.\\\nD\u0026rsquo;autre part, certain package tr√®s utilis√©, et particuli√®rement NumPy, utilisent des entiers de pr√©cision fix√©e.\nimport numpy as np a = np.array(2**63-1) a.dtype dtype('int64')\nAjouter 1 √† a va causer un overflow sans lever d\u0026rsquo;erreurs :\nb = a+1 b -9223372036854775808\na + b -1\n¬†Codage des nombres d√©cimaux en machine Nombres dyadiques Un nombre d√©cimal $x$ est un nombre pouvant s\u0026rsquo;√©crire sous la forme $\\frac{x}{10^n}$. Son d√©veloppement d√©cimal s\u0026rsquo;obtient en d√©composant $x$ sur les puissances de 10 positives et n√©gatives d\u0026rsquo;exposants allant au maximum jusqu\u0026rsquo;√† -n : $\\frac{5}{8}=0,625=\\frac{625}{10^3} = \\frac{6}{10^1}+ \\frac{2}{10^2} + \\frac{5}{10^3}$. Mais la plupart des nombres ne poss√®de pas un d√©veloppement d√©cimal fini ($\\frac{1}{3}=0,33333\\cdots$ par exemple).\nL\u0026rsquo;√©quivalent binaire des nombres d√©cimaux correspond aux nombres dyadiques. Ainsi, $\\frac{5}{8}=\\frac{5}{2^3}$ est un nombre dyadique et son d√©veloppement dyadique s\u0026rsquo;√©crit : $\\frac{5}{8}=\\frac{1\\times 2^2+0\\times 2^1+1\\times 2^0}{8}=\\frac{1}{2^1}+\\frac{0}{2^2}+\\frac{1}{2^3}=(0,101)_2$\nComme pour les d√©cimaux, la plupart des nombres ne poss√®dent pas un d√©veloppement dyadique fini, mais cela ne correspond pas aux m√™mes nombres ! C\u0026rsquo;est le cas par exemple de $0,1$ : $\\frac{1}{10} = (0,0001,1001,1001,1001\\cdots)_2$.\nLa repr√©sentation de $0,1$ sera donc n√©cessairement tronqu√©e par la machine :\n0.1**2 0.010000000000000002\n0.1**2 == 0.01 False\nConclusion : cela n\u0026rsquo;a pas de sens de tester une √©galit√© sur autre chose que des entiers.\nIl faut se restreindre √† tester des in√©galit√©s :\nabs(0.1**2 - 0.01) \u0026lt; 1e-10 True\n¬†Nombres en virgule flottante Nous connaissons la notation scientifique qui normalise tous les nombres d√©cimaux avec une mantisse comprise entre 1 et 9,999‚Ä¶ et une puissance de dix restituant la grandeur du nombre.\nLes nombres en virgule flottante (ou au format flottant) peuvent √™tre vus comme l\u0026rsquo;√©quivalent informatique de la notation scientifique.\nLa notation flottante comprend trois composantes :\n le signe s, la mantisse m, l\u0026rsquo;exposant e de la puissance de b.  Un nombre $x$ s\u0026rsquo;√©crit donc $x=s\\times m\\times b^e$ o√π $b$ est la base.\nEn faisant varier l\u0026rsquo;exposant, on fait ¬´ flotter ¬ª la virgule.\nLe format flottant est le format privil√©gi√© pour repr√©senter les nombres d√©cimaux en machine (la base est alors 2 bien s√ªr).\n¬†Norme IEEE-754 La norme elle-m√™me n\u0026rsquo;est pas √† conna√Ætre, mais son principe permet de comprendre comment les mots machines correspondant aux flottants sont construits.\n Cette norme est actuellement le standard pour la repr√©sentation des nombres √† virgule flottante en binaire.\nPour une architecture 64 bits, le signe est cod√© sur 1 bit, l\u0026rsquo;exposant sur 11 et la mantisse sur 52. Le format est alors dit double pr√©cision pour le distinguer du simple pr√©cision stock√© sur 32 bits.\nComme le premier chiffre significatif d\u0026rsquo;un nombre binaire est n√©cessairement 1, ce 1 n\u0026rsquo;est pas inclus dans les 52 bits de la mantisse. Les 52 bits permettent donc 53 bits de pr√©cision gr√¢ce √† ce bit cach√©. On dit alors que le flottant est normalis√©.\n Exemple : comment est repr√©sent√© le nombre d√©cimal $13256,625$ ?\n$13256,625 = (11001111001000.101)_2 = 1,1001111001000101\\times 2^{13}$\nDonc l\u0026rsquo;exposant vaut 13, et comme on l\u0026rsquo;a dit, on omet le premier 1 dans la mantisse qui s\u0026rsquo;√©crit donc :\n$1001111001000101000000000000000000000000000000000000$ (les 16 bits apr√®s le premier 1 de l\u0026rsquo;√©criture binaire de $13256,625$ suivis de 36 z√©ros).\nL\u0026rsquo;exposant est repr√©sent√© avec un d√©calage : on lui ajoute $2^{10}-1=1023$.\nCela permet de stocker des exposants allant de $-1022$ √† $1023$ sur des valeurs toutes positives allant de $1$ √† $2046$.\nDans notre cas, l\u0026rsquo;exposant est repr√©sent√© avec la valeur $13+1023=1036=10000001100$\nAu final, la repr√©sentation au format flottant 64 bits normalis√© de $13256,625$ est :\n$0\\;10000001100\\;1001111001000101000000000000000000000000000000000000$\nElle est exacte.\n Par contre, la repr√©sentation de $0,1$ est, elle, tronqu√©e :\n$0\\;01111111011\\;1001100110011001100110011001100110011001100110011010$\nEn d√©cimal, ce nombre correspond √† $0,100000000000000005551115123126$.\n¬†Les soucis des flottants En g√©n√©ral, les 53 bits (en incluant le bit cach√©) permettent 15 chiffres significatifs en d√©cimal ($\\log_{10} 2^{53} = 15,95$).\nTout calcul impliquant un nombre de chiffres plus grands sera sujet √† une erreur d\u0026rsquo;arrondi.\nLa limite sup√©rieure de l\u0026rsquo;erreur d\u0026rsquo;approximation relative caus√©e par l\u0026rsquo;arrondi est appel√©e epsilon de la machine $\\varepsilon$.\nPour Python :\nimport sys eps = sys.float_info.epsilon eps 2.220446049250313e-16\nCette valeur est logiquement $2^{-52}$, la derni√®re position de la mantisse.\nCons√©quence de ces arrondis : lors de l\u0026rsquo;addition de deux nombres √† l\u0026rsquo;√©cart relatif tr√®s important, il peut y avoir absorption du petit par le grand !\nL\u0026rsquo;addition de flottants n\u0026rsquo;est plus associative.\n (1 + 2.**53) - 2.**53 0.0\n1 + (2**53 - 2**53) 1\nExplication : $1+2^{53} = (1, \\underbrace{000\\cdots000}_\\text{52 z√©ros}\\,\\color{red}{1}\\color{black}{)_2 \\times 2^{53}} \\Rightarrow$ Le dernier 1 se voit tronqu√©.\n¬†De plus, la multiplication de flottants n\u0026rsquo;est en g√©n√©ral pas distributive.\n a, b, c = 100, 0.1, 0.2 a*b + a*c 30.0\na*(b+c) 30.000000000000004\n¬†Beaucoup de calculs en flottants entra√Ænent la perte de chiffres significatifs.\nLes cas les plus spectaculaires intervenant lorsqu\u0026rsquo;on soustrait deux nombres tr√®s proches.\n Prenons, pour simplifier, l\u0026rsquo;exemple de flottants d√©cimaux dont la mantisse s\u0026rsquo;√©crit sur 6 bits et repr√©sentons le calcul dont la forme exacte est :\n$1,2345432 - 1,23451 = 0,0000332$\nNotre syst√®me hypoth√©tique est oblig√© de tronquer le premier terme $1,2345432 \\rightarrow 1,23454$.\nLe r√©sultat de la soustraction donne alors :\n$1,23454 - 1,23451 = 0,00003$ On n\u0026rsquo;a plus qu\u0026rsquo;un seul chiffre significatif alors que le r√©sultat exact avec ses 3 chiffres significatifs pouvait tr√®s bien √™tre repr√©sent√© par notre syst√®me √† mantisse de 6 bits.\nOn parle alors de catastrophic cancellation.\nM√™me si les 15 chiffres significatifs des flottants double pr√©cision semblent beaucoup, des op√©rations r√©p√©t√©es entra√Ænent une cascade d\u0026rsquo;arrondis qui peuvent aboutir √† des r√©sultats dramatiques comme le montre l\u0026rsquo;exemple du missile patriot du TP.\nUne autre cons√©quence de la mani√®re dont les flottants sont g√©r√©s est l\u0026rsquo;existence de valeur minimale et maximale stockable.\nLes calculs bay√©siens, par exemple, requi√®rent de fr√©quentes multiplications entre petites probabilit√©s. Mais en dessous d\u0026rsquo;une certaine valeur, un soupassement de capacit√© ou underflow am√®ne le programme √† afficher z√©ro.\nP = 1 for i in range(1,101) : if (i\u0026lt;6 or P\u0026lt;1e-306) : print(P) elif i == 10 : print(\u0026#39;...\u0026#39;) P *= 5e-4 1\n0.0005\n2.5e-07\n1.25e-10\n6.250000000000001e-14\n...\n1.0097419586828971e-307\n5.0487097934146e-311\n2.5243548965e-314\n1.2621776e-317\n6.31e-321\n5e-324\n0.0\nOn voit que la pr√©cision est progressivement abaiss√©e avec l\u0026rsquo;affichage de nombres dits subnormaux (ce processus est appel√© \u0026ldquo;gradual underflow\u0026rdquo;) avant l\u0026rsquo;affichage de z√©ro.\\\nLe plus petit nombre qui peut √™tre repr√©sent√© avec une pr√©cision compl√®te est :\nsys.float_info.min 2.2250738585072014e-308\nDe l\u0026rsquo;autre c√¥t√©, on a la possibilit√© d\u0026rsquo;un d√©passement de capacit√© ou overflow. Le plus grand nombre affichable est :\nsys.float_info.max 1.7976931348623157e+308\n"
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_1/tp5recu/",
	"title": "TP 5 : fonctions r√©cursives",
	"tags": [],
	"description": "",
	"content": "Fonctions r√©cursives   import numpy as np import matplotlib.pyplot as plt from matplotlib.patches import Rectangle plt.style.use(\u0026#39;seaborn\u0026#39;) plt.rcParams[\u0026#39;figure.figsize\u0026#39;] = (10, 10) fig, ax = plt.subplots() ax.set_aspect(1) couleurs = plt.rcParams[\u0026#39;axes.prop_cycle\u0026#39;].by_key()[\u0026#39;color\u0026#39;] ¬†Visualisation des appels r√©cursifs Installons un module permettant de repr√©senter sous forme de graphe les diff√©rents appels r√©cursifs d\u0026rsquo;une fonction.\n%%capture !pip install recursionvisualisation==0.2 On construit une fonction r√©cursive somme(n) qui retourne la somme des n premiers entiers et on utilise un d√©corateur (fonction qui modifie le comportement d\u0026rsquo;autres fonctions) pour visualiser les diff√©rents appels r√©cursifs faits par somme.\ncg = CallGraph() @viz(cg) # d√©corateur def somme(n): if n \u0026lt; 1: return 0 return n + somme(n - 1) print(somme(5)) cg.render() somme(5) = 15 On observe l\u0026rsquo;empilement des appels successifs de somme jusqu\u0026rsquo;√† ce que le cas de base soit touch√©. Ces appels forment une pile d\u0026rsquo;ex√©cution (ou pile d\u0026rsquo;appels, \u0026ldquo;call stack\u0026rdquo; en anglais).\nLe cas de base correspond √† la premi√®re valeur retourn√©e (0 ici) et donc au premier appel retir√© de la pile. Tous les appels pr√©c√©dents sont rest√©s en attente.\nOn remonte ensuite chronologiquement la pile des appels avec √† chaque fois une nouvelle valeur retourn√©e, jusqu\u0026rsquo;√† l\u0026rsquo;appel initial, appel√© appel terminal.\n Combien l\u0026rsquo;expression somme(100) va-t-elle provoquer d\u0026rsquo;appels de la fonction somme ?\n Les choses se compliquent si plusieurs appels r√©cursifs sont faits dans la d√©finition de la fonction.\nLe nombre d\u0026rsquo;appels progresse maintenant exponentiellement mais pas la taille de la pile d\u0026rsquo;ex√©cution qui correspond au nombre de niveaux (√† la profondeur de l\u0026rsquo;arbre).\ncg = CallGraph() @viz(cg) def fib(n): if n \u0026lt; 2: return n return fib(n-1) + fib(n-2) print(f\u0026#39;{fib(5) = }\u0026#39;) cg.render() fib(5) = 5 Comme on le voit ci-dessus, fib(5) fait 15 appels √† la fonction mais la pile ne d√©passe jamais 6 appels en attente.\nEn effet, fib(5) appelle fib(4) qui appelle fib(3)qui appelle fib(2) qui appelle fib(1). Comme fib(1) est un des deux cas de base possible, il retourne la valeur 1 et est retir√© de la pile. Le dernier appel en attente de la pile est alors fib(2), on y retourne.\nfib(2) fait son deuxi√®me appel : fib(0). fib(0) √©tant l\u0026rsquo;autre cas de base, il retourne une valeur (0) et est retir√© de la pile. fib(2) peut maintenant elle aussi retourner une valeur (1+0) et est √† son tour retir√©e de la pile.\nLe dernier appel en attente est dor√©navant fib(3) qui fait maintenant son deuxi√®me appel : fib(1). fib(1) retourne 1 et est retir√© de la liste, fib(2) retourne 2 (1+1) et est retir√©e √† son tour, et on remonte √† fib(4) qui fait son deuxi√®me appel, fib(2), qui elle-m√™me appelle fib(1), etc.\n Quelle sera la taille maximale de la pile d\u0026rsquo;ex√©cution de fib(100) ?\n ¬†Deux tris r√©cursifs Construisons les deux tris r√©cursifs pr√©sent√©s dans la vid√©o.\nTri insertion  √âcrire la fonction insertion qui insert au bon endroit un nombre dans une liste tri√©e afin qu\u0026rsquo;elle reste tri√©e.\n def insertion(element,Ltriee) : \u0026#34;\u0026#34;\u0026#34; insertion(element : nombre, Ltriee : liste de nombres) -\u0026gt; Lsortie : liste de nombres insertion insert \u0026#39;nombre\u0026#39; au bon endroit dans \u0026#39;Ltriee\u0026#39; et retourne cette nouvelle liste. pr√©conditions : \u0026#39;element\u0026#39; est un entier ou un flottant, \u0026#39;Ltriee\u0026#39; est une liste de nombres tri√©e en ordre croissant postconditions : \u0026#39;Lsortie\u0026#39; est tri√©e dans l\u0026#39;ordre croissant (et len(Lsortie)==len(Ltriee)+1) \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE Exemple : insertion(5,[-12,1e-2,0,3,18]) doit renvoyer [-12,1e-2,0,3,5,18] .\n Combien d\u0026rsquo;it√©rations sont n√©cessaires dans le pire des cas pour ins√©rer un √©l√©ment dans une liste de longueur n ?\n  A : $n$ B : $2n$ C : $n^2$   Ajouter le cas de base √† la fonction tri_insertion :\n def tri_insertion(liste) : n = len(liste) ### VOTRE CODE else : element = liste[0] reste = liste[1:] return insertion(element,tri_insertion(reste)) # si pas de return dans le else alors tous les appels de tri_insertion avec un len \u0026gt; 1 sont de type None !!!  Combien d\u0026rsquo;appels √† tri_insertion sont faits au sein de tri_insertion(L) quand L √† une taille n ?\n  A : $n-1$ B : $2^n$ C : $\\log_2(n)$  ¬†Tri fusion    √âcrire la fonction fusion qui fusionne deux listes tri√©es en une seule liste tri√©e.\n def fusion(Ltrie1,Ltrie2) : \u0026#34;\u0026#34;\u0026#34; fusion(Ltrie1 : liste de nombres, Ltrie2 : liste de nombres) -\u0026gt; liste_sortie : liste de nombres fusion retourne une seule liste ordonn√©e √† partir de deux sous-listes ordonn√©es. pr√©conditions : Ltrie1 et Ltrie2 sont tri√©es dans l\u0026#39;ordre croissant. postconditions : \u0026#39;Lfus\u0026#39; est tri√©e dans l\u0026#39;ordre croissant (et len(Lfus)==len(Ltrie1)+len(Ltrie2)). \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE Exemple : fusion([-12,3.5,18],[-2,15]) doit renvoyer [-12,-2,3.5,15,18].\n Compl√©ter la d√©finition de tri_fusion pour le rendre op√©rant.\n def tri_fusion(L) : n = len(L) if n == 1 : return L else : L = fusion(trifusion(L[:n//2]),trifusion(L[\u0026#39;...\u0026#39;])) return L Supposons que la longueur de la liste L soit une puissance de 2.\nAu niveau de r√©cursivit√© $j$ (√† l\u0026rsquo;appel initial de tri_fusion(L), $j=0$, pour les deux appels √† tri_fusion au sein de tri_fusion(L), $j=1$, etc.), on a d√©compos√© le probl√®me initial en \u0026hellip; fusions, chacune op√©rant sur des sous-listes de taille \u0026hellip; .\n Par quoi faut-il compl√©ter les pointill√©s respectivement ?\n  A : $2^j$ et $2^j$ B : $n/2^j$ et $n/2^j$ C : $2^j$ et $n/2^j$ D : $n/2^j$ et $2^j$  ¬†Algorithme d\u0026rsquo;Euclide Un des plus vieux algorithmes connus, l\u0026rsquo;algorithme d\u0026rsquo;Euclide, suit un raisonnement r√©cursif et s\u0026rsquo;√©crit donc naturellement de cette fa√ßon.\nPrincipe de l\u0026rsquo;algorithme : le plus grand commun divisieur (pgcd) entre deux nombres a et b est le m√™me que celui entre b et le reste de la division euclidienne de a par b ($a\\pmod b$). Alg√©briquement, cela donne $\\text{pgcd}(a,b)=\\text{pgcd}(b,a\\pmod b)$.\nOn a donc ainsi r√©duit le probl√®me initial en un probl√®me plus simple, ce qui permet d\u0026rsquo;appliquer la technique algorithmique diviser pour r√©gner.\n √âcrivez une fonction r√©cursive pgcd permettant de calculer le pgcd entre deux nombres (n\u0026rsquo;oubliez pas le cas de base qu\u0026rsquo;il vous faudra d√©terminer).\n def pgcd(a,b) : \u0026#34;\u0026#34;\u0026#34; pgcd(a:int,b:int)-\u0026gt;int \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE pgcd(1080,480) 120\nUne utilit√© g√©om√©trique du pgcd : le pavage d\u0026rsquo;un rectangle par les plus grands carr√©s possibles.\nax.clear() a = 1080 b = 480 ax.set_xlim([0, a]) ax.set_ylim([0, b]) ax.add_patch(Rectangle((0,0), a, b, color=\u0026#39;white\u0026#39;)) # Le c√¥t√© du plus gros carr√© pavant le rectangle de longueur a et largeur b vaut pgcd(a,b) ! for i in range(a//pgcd(a,b)) : # a//pgcd(a,b) : nombre de carr√©s dans la longueur for j in range(b//pgcd(a,b)) : # b//pgcd(a,b) : nombre de carr√©s dans la largeur ax.add_patch(Rectangle((pgcd(a,b)*i, pgcd(a,b)*j), pgcd(a,b), pgcd(a,b),color=couleurs[(i+j)%2])) fig ¬†Dessins r√©cursifs def dessine_cercle(centre,rayon) : theta = np.linspace(0, 2*np.pi, 100) # permet d\u0026#39;avoir 100 valeurs entre 0 et 2pi x0,y0 = centre x = rayon*np.cos(theta)+x0 y = rayon*np.sin(theta)+y0 ax.plot(x, y) ax.fill(x, y) return fig ax.clear() dessine_cercle((4,6),5) # cercle de centre (4,6) et de rayon 5 def cercles(centre,rayon) : dessine_cercle(centre,rayon) if rayon \u0026gt; 0.1 : cercles(centre,rayon*0.9) return fig ax.clear() cercles((10,10),20)  D√©finir une fonction r√©cursive dessin qui affiche l\u0026rsquo;image ci-dessous avec l\u0026rsquo;appel dessin((0,0),20).\n def dessin(centre,rayon) : ### VOTRE CODE return fig # La figure qui s\u0026#39;affiche en ex√©cutant cette cellule doit √™tre identique √† l\u0026#39;image pr√©c√©dente. ax.clear() dessin((0,0),20) ¬†L-syst√®me (syst√®me de Lindenmayer) plt.rcParams[\u0026#39;figure.figsize\u0026#39;] = (7, 7) ax.clear() Pour tracer une ligne bris√©e allant du point $\\left(0;0\\right)$ au point $\\left(2;0\\right)$ en passant par le point $\\left(1;1\\right)$ avec matplotlib, on peut faire l\u0026rsquo;appel suivant √† plot :\nax.plot([0, 1, 2], [0, 1, 0]) # [0, 1, 2] sont les valeurs des x # et [0, 1, 0] sont les valeurs des y fig Comme c\u0026rsquo;est plus courant de penser en termes de coordonn√©es, on va construire une fonction dessine_points qui permet de tracer des lignes joignant une liste de points donn√©s sous le format (x,y).\n Compl√©tez la d√©finition de dessine_points ci-dessous.\n def dessine_points(liste_points) : \u0026#34;\u0026#34;\u0026#34; pr√©condition : liste_points est une liste de tuples contenant chacun deux nombres (x1,y1),(x2,y2),etc. \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE ax.plot(X,Y) return fig # les instructions suivantes doivent afficher le m√™me graphe que plus haut. ax.clear() dessine_points([(0,0),(1,1),(2,0)]) Le \u0026ldquo;graphisme tortue\u0026rdquo; est un style de graphique o√π on commande le crayon en vue subjective ; on bouge un curseur (la tortue) sur le plan cart√©sien en retenant syst√©matiquement sa position et sa direction actuelles (o√π est la tortue et vers o√π elle est tourn√©e).\nDans la suite, on va faire en sorte de pouvoir envoyer trois ordres √† la tortue cod√©s chacun par un caract√®re :\n 'A' : avance d\u0026rsquo;une certaine longueur dans ta direction actuelle '+' : tourne dans le sens des aiguilles d\u0026rsquo;une montre d\u0026rsquo;un certain angle sans avancer '-' : tourne dans le sens inverse des aiguilles d\u0026rsquo;une montre d\u0026rsquo;un certain angle sans avancer  On va donc devoir convertir une suite de consignes comme 'A+A-A+A-A' en une liste de points.\nfrom math import pi, sin, cos  Compl√©ter la d√©finition de consigne_vers_points de fa√ßon √† ce que le nouveau point (x_new,y_new) corresponde √† une tortue ayant avanc√© de la distance D dans la direction actuelle depuis (x_old,y_old) (il manque seulement la d√©finition de y_new).\n def consigne_vers_points(consigne,angle) : \u0026#34;\u0026#34;\u0026#34; consigne_vers_points(consigne : string) -\u0026gt; liste_de_points : list precondition : angle est donn√© en radian postcondition : liste_de_points est une liste de tuples contenant chacun deux nombres \u0026#34;\u0026#34;\u0026#34; liste_de_points = [(0,0)] # point de d√©part D = 1 # distance de laquelle la tortue avance √† chaque F direction = 0 # direction initiale de la tortue (vers la droite) for c in consigne : x_old,y_old = liste_de_points[-1] if c == \u0026#39;A\u0026#39; : # cr√©ation de x_new et y_new x_new = x_old + D*cos(direction) ### VOTRE CODE liste_de_points.append((x_new,y_new)) elif c == \u0026#39;+\u0026#39; : direction -= angle elif c == \u0026#39;-\u0026#39; : direction += angle return liste_de_points L\u0026rsquo;ex√©cution des deux lignes suivantes doit afficher le graphe ci-dessous.\nax.clear() dessine_points(consigne_vers_points(\u0026#39;A-A+A--A-A\u0026#39;,pi/4))  Donner la consigne et l\u0026rsquo;angle permettant de tracer le triangle √©quilat√©ral suivant (ne pas utiliser plus de points que n√©cessaires (3) sous peine de voir sa solution non valid√©e) :  ax.clear() consigne = \u0026#39;...\u0026#39; angle = 0 dessine_points(consigne_vers_points(consigne,angle)) Ajoutons un jeu de r√®gles capables de transformer une cha√Æne de caract√®res.\nImaginons la s√©quence \u0026lsquo;abca\u0026rsquo; et les r√®gles suivantes :\n 'a' -\u0026gt; 'b' 'b' -\u0026gt; 'aba'  Alors la s√©quence \u0026lsquo;abca\u0026rsquo; transform√©e par la r√®gle devient \u0026lsquo;babacb\u0026rsquo; (\u0026lsquo;c\u0026rsquo; n\u0026rsquo;√©tant pas touch√© par la r√®gle, il n\u0026rsquo;est pas modifi√©).\nOn va construire une fonction transformation prenant en argumant une cha√Æne de caract√®res appel√©e axiome et une r√®gle donn√©e sous la forme d\u0026rsquo;un dictionnaire et retournant la s√©quence transform√©e.\nPour la r√®gle de notre exemple, le dictionnaire serait {'a':'b','b':'aba'}.\ndef transformation(axiome,regle) : \u0026#34;\u0026#34;\u0026#34; transformation(axiome : string, regle : dictionnary) -\u0026gt; nvelle_chaine : string \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE axiome = \u0026#39;abca\u0026#39; regle = {\u0026#39;a\u0026#39;:\u0026#39;b\u0026#39;,\u0026#39;b\u0026#39;:\u0026#39;aba\u0026#39;} transformation(axiome,regle) Doit donner 'babacb'.\nFaisons maintenant en sorte de pouvoir appliquer la transformation √† elle-m√™me :\n si le niveau de r√©cursivit√© vaut z√©ro, on retourne juste l\u0026rsquo;axiome, sinon, on retourne le r√©sultat de la transformation appliqu√©e non plus sur l\u0026rsquo;axiome, mais sur la transformation de l\u0026rsquo;axiome par la r√®gle, et on diminue le niveau d\u0026rsquo;une unit√© (il faut n√©cessairement faire en sorte d\u0026rsquo;atterrir sur le cas de base).   Compl√©tez la d√©finition de la fonction ci-dessous et testez-la dans la cellule suivante (il ne manque que l\u0026rsquo;appel r√©cursif).\n def transformation_recu(axiome,regle,niveau) : \u0026#34;\u0026#34;\u0026#34; transformation_recu(axiome : string , regle : dictionnary , niveau : int) -\u0026gt; nvelle_chaine : string precondition : niveau doit √™tre un entier positif ! \u0026#34;\u0026#34;\u0026#34; if niveau \u0026gt; 0 : return transformation_recu(...,...,...) else : nvelle_chaine = axiome return nvelle_chaine axiome = \u0026#39;aba\u0026#39; regle = {\u0026#39;a\u0026#39;:\u0026#39;b\u0026#39;,\u0026#39;b\u0026#39;:\u0026#39;aba\u0026#39;} for i in range(6) : print(transformation_recu(axiome,regle,i)) # doit s\u0026#39;afficher : #aba #babab #abababababa #babababababababababab #abababababababababababababababababababababa #babababababababababababababababababababababababababababababababababababababababababab √Ä partir d\u0026rsquo;un axiome, d\u0026rsquo;une r√®gle de transformation, et de l\u0026rsquo;application r√©cursive de la transformation sur l\u0026rsquo;axiome, on obtient une consigne permettant de faire dessiner des fractales √† la tortue !\nPour le flacon de Koch, on part d\u0026rsquo;un triangle √©quilat√©ral comme axiome, et pour chaque segment de droite, on suit la r√®gle de transformation induite par le sch√©ma suivant.\\\n √Ä vous de d√©terminer l\u0026rsquo;axiome (le triangle √©quilat√©rale demand√© plus haut) et la bonne r√®gle.\n axiome = \u0026#39;...\u0026#39; regle_Koch = {\u0026#39;A\u0026#39;:\u0026#39;...\u0026#39;} ax.clear() dessine_points(consigne_vers_points(transformation_recu(axiome,regle_Koch,5),pi/3)) Autre exemple : comment construire une surface 2D √† partir d\u0026rsquo;une courbe 1D avec la courbe de Hilbert.\naxiome = \u0026#39;L\u0026#39; regle_Hilbert = {\u0026#39;L\u0026#39;:\u0026#39;-RA+LAL+AR-\u0026#39;,\u0026#39;R\u0026#39;: \u0026#39;+LA-RAR-AL+\u0026#39;} ax.clear() dessine_points(consigne_vers_points(transformation_recu(axiome,regle_Hilbert,6),pi/2)) Autre exemple : un triangle de Sierpinski.\naxiome = \u0026#34;YA\u0026#34; regle = {\u0026#34;X\u0026#34;:\u0026#34;YA+XA+Y\u0026#34;, \u0026#34;Y\u0026#34;:\u0026#34;XA-YA-X\u0026#34;} angle = pi/3 ax.clear() dessine_points(consigne_vers_points(transformation_recu(axiome,regle,7),angle)) Et enfin, une jolie courbe du dragon.\naxiome = \u0026#34;AX\u0026#34; regle = {\u0026#34;X\u0026#34;:\u0026#34;X+YA+\u0026#34;, \u0026#34;Y\u0026#34;:\u0026#34;-AX-Y\u0026#34;} angle = pi/2 ax.clear() dessine_points(consigne_vers_points(transformation_recu(axiome,regle,16),angle)) En donnant de la m√©moire √† la tortue, on va pouvoir dessiner des branches.\nPour cela, il faut ajouter deux nouvelles consignes √† consigne_vers_points_branche :\n '[' : qui ajoute √† une liste (la \u0026ldquo;m√©moire\u0026rdquo;), la position actuelle de la tortue. '[' : qui permet √† la tortue de retourner √† la derni√®re position en m√©moire.  Voici une impl√©mentation possible d\u0026rsquo;une fonction consigne_vers_points_branche int√©grant ces deux nouvelles consignes :\ndef consigne_vers_points_branche(consigne,angle) : liste_de_points = [(0,0)] D = 1 direction = pi/2 memoire = [] for c in consigne : x_old,y_old = liste_de_points[-1] if c == \u0026#39;A\u0026#39; : x_new = x_old+D*cos(direction) y_new = y_old+D*sin(direction) liste_de_points.append((x_new,y_new)) elif c == \u0026#39;+\u0026#39; : direction -= angle elif c == \u0026#39;-\u0026#39; : direction += angle elif c == \u0026#39;[\u0026#39; : memoire.append(((x_old,y_old),direction)) elif c == \u0026#39;]\u0026#39; : souvenir = memoire.pop() x_new,y_new = souvenir[0] direction = souvenir[1] liste_de_points.append((float(\u0026#39;nan\u0026#39;),float(\u0026#39;nan\u0026#39;))) liste_de_points.append((x_new,y_new)) return liste_de_points ax.clear() dessine_points(consigne_vers_points_branche(\u0026#39;A[-A]+A\u0026#39;, pi/4))  Reproduisez la figure suivante en d√©finissant la bonne consigne et le bon angle :  Et en utilisant la r√©cursivit√©, on peut d√©sormais dessiner de jolis arbres :\naxiome = \u0026#39;P\u0026#39; regle = {\u0026#39;A\u0026#39;: \u0026#39;AA\u0026#39;, \u0026#39;P\u0026#39;: \u0026#39;A[+PA-[P]--P][---P]\u0026#39;} angle = pi*0.11 ax.clear() dessine_points(consigne_vers_points_branche(transformation_recu(axiome,regle,8),angle)) "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_1/tp6tri/",
	"title": "TP 6 : algorithmes de tri",
	"tags": [],
	"description": "",
	"content": "algorithmes de tri Trier c\u0026rsquo;est partir d\u0026rsquo;une structure de donn√©es d√©sordonn√©e et la remettre en ordre.\nLes tris sont omnipr√©sents en informatique et Tim Roughgarden (auteur d'Algorithms illuminated) en parle m√™me comme de la \u0026ldquo;m√®re de tous les probl√®mes algorithmiques\u0026rdquo;.\nPlusieurs strat√©gies existent. On va en passer certaines en revue et essayer de trier les algorithmes de tri.\n Tris par comparaison La plupart des algorithmes de tri sont dits par comparaison car ils reposent sur des comparaisons deux √† deux des √©l√©ments de la liste.\nOn a d√©j√† rencontr√© deux algorithmes de tri par comparaison dans le TP sur la r√©cursivit√© : le tri par insertion et le tri fusion.\nTri fusion def fusion(L1,L2) : \u0026#34;\u0026#34;\u0026#34; fusion(L1:list,L2:list)-\u0026gt;Lfus:list fusion retourne une seule liste ordonn√©e √† partir de deux sous-listes ordonn√©es pr√©conditions : L1 et L2 sont tri√©e dans l\u0026#39;ordre croissant postconditions : \u0026#39;Lfus\u0026#39; est tri√©e dans l\u0026#39;ordre croissant (et len(Lfus)==len(L1)+len(L2)) \u0026#34;\u0026#34;\u0026#34; if L1 == [] : return L2 if L2 == [] : return L1 if L1[0] \u0026lt;= L2[0] : # devient instable si \u0026lt; au lieu de \u0026lt;= ! return [L1[0]] + fusion(L1[1:],L2) else : return [L2[0]] + fusion(L1,L2[1:]) def tri_fusion(L) : n = len(L) if n \u0026lt;= 1 : return L else : return fusion(tri_fusion(L[:n//2]),tri_fusion(L[n//2:]))  Combien de comparaisons effectue l\u0026rsquo;algorithme de tri fusion pour ordonner [1,2,3,4,5,6,7,8] et [8,7,6,5,4,3,2,1] ?\n  A : 0 et 8 B : 8 et 16 C : 12 et 12 D : 16 et 8  Vous pouvez trouver la r√©ponse √† la main, mais vous pouvez aussi int√©grer √† fusion une variable globale nb_comp qui est incr√©ment√©e √† chaque comparaison entre deux √©l√©ments de la liste.\nPensez √† syst√©matiquement r√©initialiser nb_comp √† 0 avant chaque appel de tri_fusion, car sinon la valeur continue √† courir. C\u0026rsquo;est un des dangers des variables globales.\n¬†Tri par insertion On va √©crire une version it√©rative de l\u0026rsquo;algorithme de tri par insertion.\nSon principe : on compare chacun des √©l√©ments i de la liste donn√©e en argument (√† partir du deuxi√®me) √† ceux qui le pr√©c√®dent en remontant la liste un par un (i-1,i-2,etc.). Tant qu\u0026rsquo;un des √©l√©ments qui pr√©c√®dent est plus grand que l\u0026rsquo;√©l√©ment i, on les permute, jusqu\u0026rsquo;√† ce que l\u0026rsquo;√©l√©ment i soit √† la bonne place.\nConstruisez d\u0026rsquo;abord une fonction permute(L,i,j) qui permute les √©l√©ments i et j d\u0026rsquo;une liste L.\ndef permute(L,i,j) : \u0026#34;\u0026#34;\u0026#34; permute(L:list,i:int,j:int)-\u0026gt;list 0 \u0026lt; i,j \u0026lt; len(L) \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE Puis compl√©tez la fonction tri_insertion en utilisant permute.\ndef tri_insertion(L) : \u0026#34;\u0026#34;\u0026#34; tri_insertion(L:list)-\u0026gt;list \u0026#34;\u0026#34;\u0026#34; for i in range(1,len(L)) : j = i X = L[i] while j \u0026gt; 0 and L[j-1] \u0026gt; X : ### VOTRE CODE j -= 1 return L La cellule suivante permet de comparer le r√©sultat de la fonction tri_insertion √† la fonction native de tri sorted sur 1000 listes de 10 nombres tir√©s au hasard entre -5 et 5\nfrom random import randint,shuffle for i in range(1000) : L_desord = [randint(-5,5) for i in range(10)] assert tri_insertion(L_desord) == sorted(L_desord), f\u0026#34;y a un probl√®me avec {L_desord} :\\ndonne {tri_insertion(L_desord)}\\nau lieu de {sorted(L_desord)}\u0026#34;  Combien de comparaisons effectue l\u0026rsquo;algorithme de tri insertion pour ordonner [1,2,3,4,5,6,7,8] et [8,7,6,5,4,3,2,1] ?\n  A : 7 et 28 B : 0 et 7 C : 28 et 28 D : 5 et 35   Combien de comparaisons demande le tri par insertion d\u0026rsquo;une liste de 200 √©l√©ments rang√©s en ordre inverse ?\n ¬†Tri par s√©lection Principe : parmi les √©l√©ments de la liste, on cherche le plus petit, et on le permute avec le premier √©l√©ment. Puis on recommence avec tous les √©l√©ments restants (tous moins le premier) : on cherche le plus petit et on le permute avec le deuxi√®me √©l√©ment. On recommence jusqu\u0026rsquo;√† √©puiser la liste\nfonction tri_selection(liste L)\nn ‚Üê longueur(L)\npour i de 0 √† n - 2\nmin ‚Üê i\npour j de i + 1 √† n - 1\nsi L[j] \u0026lt; L[min], alors min ‚Üê j\nfin pour\nsi min ‚â† i, alors √©changer L[i] et L[min]\nfin pour\nretourner L\nfin fonction\n Traduisez le peudocode ci-dessus en python.\n def tri_selection(L) : ### VOTRE CODE  Combien de comparaisons effectue l\u0026rsquo;algorithme de tri par s√©lection pour ordonner [1,2,3,4,5,6,7,8] et [8,7,6,5,4,3,2,1] ?\n  A : 7 et 28 B : 0 et 7 C : 28 et 28 D : 5 et 35  Le tri par s√©lection ressemble beaucoup au tri par insertion. Dans les deux, apr√®s k travers√©es de la liste, les k premiers √©l√©ments sont tri√©s. Cependant la diff√©rence fondamentale entre les deux algorithmes est le sens dans lequel ces tris s\u0026rsquo;op√®rent ; le tri par insertion trie de la fin vers le d√©but alors que le tri par s√©lection tri du d√©but vers la fin. Cons√©quence : dans le tri par s√©lection, les k premiers √©l√©ments de la liste en cours de tri sont les plus petits de la liste enti√®re alors que dans le tri par insertion, ce sont seulement les k premiers √©l√©ments d\u0026rsquo;origine tri√©s.\nLe tri par s√©lection doit toujours inspecter tous les √©l√©ments restant pour trouver le plus petit, tandis que le tri par insertion ne requiert qu\u0026rsquo;une seule comparaison quand le (k+1)e √©l√©ment est plus grand que le ke ; lorsque c\u0026rsquo;est fr√©quent (si la liste est d√©j√† partiellement tri√©e), le tri par insertion est bien plus efficace. En moyenne, le tri par insertion n√©cessite de comparer et d√©caler la moiti√© des √©l√©ments seulement, ce qui correspond donc √† la moiti√© des comparaisons que le tri par s√©lection doit faire.\nDans le pire des cas pour le tri par insertion (liste tri√©e en sens inverse), les deux tris op√®rent autant d\u0026rsquo;op√©rations l\u0026rsquo;un que l\u0026rsquo;autre, mais le tri par insertion va n√©cessiter plus de permutations puisqu\u0026rsquo;il d√©cale toujours d\u0026rsquo;une position voisine √† l\u0026rsquo;autre. Le dernier √©l√©ment d\u0026rsquo;une liste renvers√©e, par exemple, va devoir traverser toute la liste en √©changeant sa place avec chacun des √©l√©ments qui le pr√©c√®dent, alors qu\u0026rsquo;avec le tri par s√©lection, il n\u0026rsquo;y a jamais au plus qu\u0026rsquo;une permutation par √©l√©ment.\nEn g√©n√©ral, le tri par insertion va √©crire dans la liste $O(n^2)$ fois (chaque permutation √©crit dans la liste), alors que le tri par s√©lection va √©crire seulement $O(n)$ fois. Pour cette raison, le tri par s√©lection peut √™tre pr√©f√©rable au tri par insertion lorsque l\u0026rsquo;√©criture sur la m√©moire est significativement plus co√ªteuse que la lecture (comme sur les EEPROM ou sur les m√©moires flash). Ce point est illustr√© dans l\u0026rsquo;animation interactive du d√©but car limiter les permutations y correspond √† limiter les d√©placements, ce qui donne l\u0026rsquo;illusion d\u0026rsquo;un algorithme plus rapide.\n¬†Tri √† bulles Le tri √† bulles est surtout √† vis√©e p√©dagogique, il ne sert quasiment jamais r√©ellement. Il tire son nom du fait qu\u0026rsquo;on pousse vers la fin de la liste, de proche en proche, des √©l√©ments de plus en plus grands, comme une bulle qui grossit en remontant √† la surface.\ndef tri_a_bulles(L) : n = len(L) for i in range(n-1): for j in range(n-i-1): if L[j] \u0026gt; L[j+1] : L = permute(L,j,j+1) return L  Combien de comparaisons effectue l\u0026rsquo;algorithme de tri √† bulles pour ordonner [1,2,3,4,5,6,7,8] et [8,7,6,5,4,3,2,1] ?\n  A : 7 et 28 B : 0 et 7 C : 28 et 28 D : 5 et 35   Combien de comparaisons demande le tri √† bulles d\u0026rsquo;une liste de 200 √©l√©ments rang√©s en ordre inverse ?\n ¬†Tri rapide Le tri rapide n\u0026rsquo;est pas toujours le plus rapide\u0026hellip; Mais il peut l\u0026rsquo;√™tre (surtout sur les grandes listes) !\nC\u0026rsquo;est un algorithme r√©cursif utilisant une partition de la liste √† trier.\nSon avantage sur le tri fusion est d\u0026rsquo;√™tre un tri en place.\nD√©savantage : il est instable.\n  def partitionner(L, g, d, pivot) : permute(L,pivot,d) j = g for i in range(g,d) : if L[i] \u0026lt;= L[d] : permute(L,i,j) j += 1 permute(L,d,j) return j def tri_rapide(L, g, d) : if g \u0026lt; d : pivot = randint(g,d) pivot = partitionner(L, g, d, pivot) tri_rapide(L, g, pivot-1) tri_rapide(L, pivot+1, d) return L La figure pr√©c√©dente permet de supposer que la complexit√© dans le pire des cas du tri fusion est √©gale √† sa complexit√© dans le meilleur des cas et √† la complexit√© en moyenne du tri rapide.\nGr√¢ce aux listes par compr√©hension, on peut √©crire une version beaucoup plus courte et claire du tri rapide. Son d√©faut est qu\u0026rsquo;elle n√©cessit√© la construction de nouvelles listes (le tri n\u0026rsquo;est alors plus en place !).\nOn va visualiser les diff√©rents appels r√©cursifs gr√¢ce au module introduit dans le TP pr√©c√©dent et pour que l\u0026rsquo;analyse soit simple, on choisit syst√©matiquement le premier √©l√©ment de la liste comme pivot.\nLa vid√©o suivante montre une impl√©mentation de cette version avec des danseurs hongrois\u0026hellip;\n  from recursionvisualisation import viz, CallGraph cg = CallGraph() @viz(cg) def triRapide(elements) : if len(elements) \u0026lt;= 1 : return elements else : pivot = elements[0] plusPetit = triRapide([e for e in elements[1:] if e \u0026lt;= pivot]) plusGrand = triRapide([e for e in elements[1:] if e \u0026gt; pivot]) return plusPetit + [pivot] + plusGrand print(triRapide(\u0026#34;hanniballecter\u0026#34;)) cg.render() ['a', 'a', 'b', 'c', 'e', 'e', 'h', 'i', 'l', 'l', 'n', 'n', 'r', 't'] Placer le pivot en premier √©l√©ment a un inconv√©nient : triRapide devient tr√®s lent avec les listes d√©j√† tri√©es (ou quasi tri√©es).\n Quelle sera la taille de la pile d\u0026rsquo;ex√©cution si on demande √† triRapide de trier une liste de 500 √©l√©ments ?\n ¬† Les tris par comparaison n\u0026rsquo;on que faire de la nature des √©l√©ments de la liste √† trier du moment qu\u0026rsquo;on peut les comparer entre eux. On peut ainsi trier tout aussi bien des cha√Ænes de caract√®res que des flottants.\nPar contre, si les √©l√©ments de la liste sont contraints d\u0026rsquo;une fa√ßon ou d\u0026rsquo;une autre, on peut essayer de tirer parti de la situation.\n ¬†Tris non comparatifs Tri par d√©nombrement (ou par comptage) Si la liste √† trier n\u0026rsquo;est constitu√©e que d\u0026rsquo;entiers positifs, on peut mettre au point un tri tr√®s rapide n\u0026rsquo;utilisant aucune comparaison : le tri par d√©nombrement (counting sort).\nPrincipe : on construit un histogramme des valeurs de la liste √† trier L dans une liste interm√©diaire L_eff.\n Si m est la plus grande valeur des √©l√©ments de la liste √† trier, alors la taille de L_eff doit valoir m+1. Et on initialise toutes ses valeurs √† z√©ros. Chaque valeur L[i] de la liste √† trier est donc aussi un indice de la liste L_eff ! On parcourt ensuite la liste √† trier et on incr√©mente de 1 la valeur de l\u0026rsquo;√©l√©ment L_eff[L[i]] de la liste interm√©diaire. On obtient bien ainsi les effectifs pour chaque valeur de la liste √† trier. Il suffit enfin de parcourir L_eff depuis le d√©but et pour chaque √©l√©ment L_eff[i] non nul, d\u0026rsquo;ajouter √† une nouvelle liste L_sortie autant de fois i que la valeur de L[i]. Plus qu\u0026rsquo;√† retourner L_sortie.  Impl√©mentez la fonction tri_par_denombrement telle qu\u0026rsquo;elle est d√©crite ci-dessus.\ndef tri_par_denombrement(L,m) : \u0026#34;\u0026#34;\u0026#34; tri_par_denombrement(L:list,m:int)-\u0026gt;L_sortie:list m est la valeur maximum des √©l√©ments de L \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE  Le nombre d\u0026rsquo;√©tapes de tri_denombrement peut s\u0026rsquo;√©crire en fonction du nombre d\u0026rsquo;√©l√©ments n de la liste comme :\n  A : $a$ B : $a\\times n + b$ C : $a\\times n^2+b\\times n + c$ D : $a\\times n^3+b\\times n^2 + c\\times n + d$  ¬†Comparer les tris Essayons maintenant de classer ces tris suivant diff√©rents crit√®res.\nCommen√ßons par ce qui est souvent le plus critique : leur complexit√© en temps. √Ä quoi doit-on s\u0026rsquo;attendre lorsque la taille de la liste √† trier prend un facteur d\u0026rsquo;√©chelle ?\nComplexit√© en temps Le graphe suivant pr√©sente le temps mis par les diff√©rents algorithmes pour trier des listes de taille croissante.\nOn peut classer ces algorithmes en 3 cat√©gories de complexit√© temporelle :\n les tris par insertion, s√©lection et √† bulles sont de complexit√© quadratique ($O(n^2)$) les tris fusion et rapide sont quasilin√©aires ($O(n\\log n)$) le tri par d√©nombrement est lin√©aire ($O(n)$)  Pour des petites listes (et lorsque des tris non comparatifs ne sont pas applicables), le tri par insertion est en moyenne plus rapide que les autres alors que pour des grandes listes, c\u0026rsquo;est le tri rapide qui domine.\n¬†Complexit√© en espace : en place ou non ? L\u0026rsquo;algorithme a-t-il besoin d\u0026rsquo;utiliser une liste interm√©diaire pour op√©rer son tri ou parvient-il √† √©crire directement sur la liste d\u0026rsquo;origine. Dans ce dernier cas, les tri est dit en place.\n Dans la liste suivante, affectez √† chaque variable correspondant √† un algorithme de tri le caract√®re 'O' si son tri se fait en place ou 'X' sinon.\n # Retirer la mauvaise r√©ponse triinsertion = \u0026#39;O\u0026#39; \u0026#39;X\u0026#39; tiselection = \u0026#39;O\u0026#39; \u0026#39;X\u0026#39; triabulles = \u0026#39;O\u0026#39; \u0026#39;X\u0026#39; trifusion = \u0026#39;O\u0026#39; \u0026#39;X\u0026#39; trirapide = \u0026#39;O\u0026#39; \u0026#39;X\u0026#39; tridenombrement = \u0026#39;O\u0026#39; \u0026#39;X\u0026#39; ¬†Stabilit√© Un algorithme de tri est stable s\u0026rsquo;il conserve l\u0026rsquo;ordre relatif de d√©part entre deux valeurs √©gales.\nDans l\u0026rsquo;animation suivante, un algorithme est stable si les deux barres noires et blanches restent toujours dans le m√™me ordre apr√®s et avant le tri.\n On compte le nombre de fois que les caract√®res \u0026lsquo;r\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026lsquo;q\u0026rsquo; et \u0026lsquo;p\u0026rsquo; apparaissent dans cette phrase :\n \u0026lsquo;r\u0026rsquo; : 6 \u0026lsquo;c\u0026rsquo; : 5 \u0026lsquo;q\u0026rsquo; : 2 \u0026lsquo;p\u0026rsquo; : 5  On cr√©e √† partir de ces donn√©es le tuple (('r',6),('c',5),('q',2),('p',5)).\nSi on trie ce tuple selon le premier √©l√©ment de chacune des paires qu\u0026rsquo;il contient (tri alphab√©tique), tous les tris donnent le m√™me r√©sultat :\n(('c',5),('p',5),('q',2),('r',6))\nMais si maintenant, on part de ce tuple tri√© et qu\u0026rsquo;on le trie en fonction des effectifs, les algorithmes ne sont pas tous d\u0026rsquo;accords !\nPour vous en convaincre triez √† la main (('c',5),('p',5),('q',2),('r',6)) en suivant l\u0026rsquo;algorithme du tri √† bulle, puis en suivant l\u0026rsquo;algorithme de tri insertion.\nNotez ci-dessous les tuples obtenus.\n# tuple obtenu avec le tri √† bulle (modifiez le tuple pour qu\u0026#39;il corresponde √† ce que vous avez trouv√©) T1 = ((\u0026#39;c\u0026#39;,5),(\u0026#39;p\u0026#39;,5),(\u0026#39;q\u0026#39;,2),(\u0026#39;r\u0026#39;,6)) # tuple obtenu avec le tri insertion (modifiez le tuple pour qu\u0026#39;il corresponde √† ce que vous avez trouv√©) T2 = ((\u0026#39;c\u0026#39;,5),(\u0026#39;p\u0026#39;,5),(\u0026#39;q\u0026#39;,2),(\u0026#39;r\u0026#39;,6)) On dit alors que le tri insertion n\u0026rsquo;est pas stable car il ne conserve pas n√©cessairement l\u0026rsquo;ordre de deux √©l√©ments √©gaux.\n tris instables : le tri s√©lection et le tri rapide.\n tris stables : le tri insertion, le tri √† bulle et le tri fusion  Un tri instable peut sans trop de peine √™tre rendu stable, il suffit de garder la trace de l\u0026rsquo;ordre initial pour les √©l√©ments √©gaux, mais cela a un co√ªt !\nL\u0026rsquo;instabilit√© du tri par s√©lection peut √™tre √©limin√©e en utilisant une fonction interm√©diaire minimum cherchant le plus petit des √©l√©ments restant √† trier et en inserrant successivement les √©l√©ments trouv√©s en partant du d√©but de la liste (attention √† rester en place = pas de liste interm√©diaire).\n Donnez le code de minimum et tri_selection_stable (avec une contrainte suppl√©mentaire : le code de tri_selection_stable ne devra pas d√©passer 3 lignes).\n def minimum(L) : \u0026#34;\u0026#34;\u0026#34; renvoie le plus petit √©l√©ment de la liste \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE # le code de tri_selection_stable ne devra pas d√©passer 3 lignes pour √™tre consid√©r√© comme juste. def tri_selection_stable(L) : ### VOTRE CODE "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_2/tp9nombre/",
	"title": "TP 9 : nombres en machine",
	"tags": [],
	"description": "",
	"content": "TP9 : nombres Cliquez sur cette invitation pour r√©cup√©rer le repository du TP. Exo 1 : nombres palindromiques  D√©terminer gr√¢ce √† un code Python le plus petit nombre sup√©rieur ou √©gal √† $10,000$ dont l\u0026rsquo;√©criture est palindromique (se lisant pareil dans les deux sens) √† la fois en base 10 et en base 2.\n ### VOTRE CODE # Affectez votre r√©ponse (l\u0026#39;√©criture en base 10 du nombre entier trouv√©) √† la variable nb nb = 3 ¬†Exo 2 : missiles Patriot Une batterie de missiles Patriot d√©tecte les missiles ennemis et les intercepte avec un contre-missile. La batterie mesure le temps pour pr√©voir le d√©placement des missiles ennemis.\nElle dispose d‚Äôun compteur (un entier) que nous appellerons c qui compte le nombre de dixi√®mes de secondes √©coul√©s depuis sa mise en marche. Le temps √©coul√© t est calcul√© par l‚Äôop√©ration t=c*0.1. Nous nous int√©ressons √† l‚Äôerreur de calcul commise lors de cette multiplication.\nD‚Äôapr√®s un rapport du General Accounting Office, le logiciel du Patriot utilise des nombres √† virgule fixe stock√©s dans un registre de 24 bits.\nLa repr√©sentation en virgule fixe utilis√©e est le format $Q1.23$ o√π seulement 1 bit est utilis√© pour la partie enti√®re et 23 bits le sont pour la partie fractionnaire.\nLa partie fractionnaire d\u0026rsquo;un r√©el ${x}=x-\\lfloor x\\rfloor$ est stock√©e sur les 23 bits en la transformant en l\u0026rsquo;entier $\\lfloor {x}\\times 2^{23}\\rfloor$ (o√π $\\lfloor\\rfloor$ est la partie enti√®re), les chiffres au del√† du 23√®me apr√®s la virgule sont donc tronqu√©s.\n √âcrivez en base 2 le nombre 0,1 en ne gardant que 24 chiffres (23 apr√®s la virgule). On notera $z$ le nombre obtenu.\nVous pourrez vous aidez du code suivant (apr√®s l\u0026rsquo;avoir modifi√© de mani√®re ad√©quate) pour d√©terminer la r√©ponse ou utiliser la derni√®re phrase de l\u0026rsquo;√©nonc√© (mais attention alors au petit pi√®ge).\n a = 2.7 avt = bin(int(a))[2:] + \u0026#39;,\u0026#39; n = a - int(a) apres = \u0026#39;\u0026#39; while len(apres)\u0026lt;9 : n *= 2 if n \u0026gt; 1 : apres += \u0026#39;1\u0026#39; n -= 1 else : apres += \u0026#39;0\u0026#39; print(avt+apres) 10,10110011\n# Affectez √† la variable z la cha√Æne de caract√®res correspondant √† l\u0026#39;√©criture binaire demand√©e : z = \u0026#39;0,...\u0026#39; On note $\\varepsilon = |0,1 ‚àí z|$. La batterie de missiles Patriot fait une erreur de $\\varepsilon$ en approximant 0,1.\n Faites calculer par Python la valeur de $\\varepsilon$ et affectez cette valeur √† une variable epsilon.\n # Vous affecterez la valeur √† la variable epsilon epsilon = D√©but f√©vrier 1991, l‚Äôarm√©e isra√©lienne a empiriquement constat√© qu‚Äôau bout de 8h, la pr√©cision des missiles est significativement r√©duite. Puis, le 25 f√©vrier 1991, six batteries de missiles Patriot (un bataillon) ont √©t√© d√©ploy√©es √† Dhahran, en Arabie Saoudite, pendant 100h.\nNous noterons $e_8$ et $e_{100}$ l‚Äôerreur commise sur $t$ par la batterie au bout de 8h puis au bout de 100h.\n Calculez des deux erreurs pr√©c√©dentes.\n # Vous affecterez les valeurs aux variables e_8 et e_100 e_8 = e_100 = Un Scud a une vitesse de croisi√®re de 1676 m/s (Mach 5).\n Pendant une dur√©e $e_{100}$, de quelle distance $d$ (en m) se d√©place un Scud ?\n # Vous affecterez la valeur √† la variable d d = Suite √† cette impr√©cision, un Scud irakien ne fut pas intercept√© et causa 28 morts parmi les soldats am√©ricains.\n¬†Exo 3 : overflows Les 3 \u0026ldquo;√©v√®nements\u0026rdquo; suivant correspondent au m√™me bug : un d√©passement de capacit√© d\u0026rsquo;entiers (sign√©s ou non) cod√©s sur 32 bits.\nLa FAA (Federal Aviation Administration) publie en 2015 une Airworthiness Directive ou AD (notification technique que les compagnies a√©riennes sont oblig√©es de suivre) concernant un bug dans le logiciel des Boeing 787 : \u0026ldquo;This AD was prompted by the determination that a Model 787 airplane that has been powered continuously for 248 days can lose all alternating current (AC) electrical power due to the generator control units (GCUs) simultaneously going into failsafe mode.\u0026rdquo; Le logiciel mesure le temps depuis sa mise en route en incr√©mentant un compteur toutes les centisecondes.  D\u0026rsquo;apr√®s les informations fournies et vos r√©flexions, au bout de combien de centisecondes exactement, la capacit√© du compteur se trouve d√©pass√©e, expliquant le bug ?\n # Vous affecterez la valeur enti√®re √† la variable nb_centi nb_centi = En 2004, l\u0026rsquo;oubli d\u0026rsquo;un technicien de rebooter un serveur a provoqu√© une immense pagaille dans le ciel californien. En effet, le 14 septembre, les aiguilleurs du ciel des a√©roports du sud californien ont perdu le contact vocal avec 400 avions pendant plus de 3 heures, heureusement sans graves cons√©quences (gr√¢ce √† la r√©action rapide des contr√¥leurs qui ont tout de suite utilis√© leurs portables pour contacter d\u0026rsquo;autres centres de contr√¥le a√©rien). La maintenance de routine du syst√®me de communication consistait √† le rebooter tous les 30 jours. Ce syst√®me mesure le temps depuis sa mise en route en incr√©mentant un compteur toutes les millisecondes.  D\u0026rsquo;apr√®s les informations fournies et vos r√©flexions, au bout de combien de millisecondes exactement, la capacit√© du compteur s\u0026rsquo;est trouv√©e d√©pass√©e, expliquant le bug ?\n # Vous affecterez la valeur enti√®re √† la variable nb_milli nb_centi = Le bug de l\u0026rsquo;an 2038 concerne les horloges des syst√®mes unix 32 bits dont le temps 0, appel√© epoch, est le 1 janvier 1970 √† 00:00:00 UT.\nimport time time.gmtime(0) time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0 Cela montre que les serveurs h√©bergeant Colab tournent sous Unix.\n  Au bout de combien de secondes exactement le probl√®me li√© au bug de 2038 se pose ?\n # Vous affecterez la valeur enti√®re √† la variable  nb_sec = "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_2/graphes/",
	"title": "Graphes",
	"tags": [],
	"description": "",
	"content": "Les graphes Quelques points et des traits pour les relier suffisent pour cr√©er un graphe. Cette grande simplicit√© est pourtant √† l\u0026rsquo;origine d\u0026rsquo;un foisonnement math√©matiques impressionnant.\nUn peu d\u0026rsquo;histoire L\u0026rsquo;acte de naissance de la th√©orie des graphes date d\u0026rsquo;une petite √©nigme √† laquelle s\u0026rsquo;attelaient sans succ√®s les habitants de K√∂nigsberg. Comment un voyageur pouvait traverser les sept ponts sans jamais passer deux fois sur le m√™me pont ? Euler r√©sout le probl√®me et fonda du m√™me coup la th√©orie des graphes ! Un graphe permet d\u0026rsquo;extraire l\u0026rsquo;essence du probl√®me : les ar√™tes sont les ponts et les sommets (ou n≈ìuds) sont les zones accessibles depuis ces ponts (s√©par√©es par les bras de rivi√®re).\nLa forme pr√©cise des lignes reliant les points n\u0026rsquo;a pas d\u0026rsquo;importance : elles ne font qu\u0026rsquo;indiquer l\u0026rsquo;existance de laison entre ces points (cela illustre le caract√®re topologique et non g√©om√©trique du probl√®me). Euler compris alors que ce qu\u0026rsquo;on appelerait ensuite un chemin eul√©rien (un chemin reliant chaque sommet en ne passant qu\u0026rsquo;une fois par chaque ar√™te) n\u0026rsquo;est possible que si le graphe ne compte pas plus de deux sommets d\u0026rsquo;o√π partent un nombre impair d\u0026rsquo;ar√™tes. Or dans le cas de K√∂nigsberg, il part un nombre impair d\u0026rsquo;ar√™tes de chacun des sept sommets¬†! Un chemin eul√©rien y est donc impossible.\nLorsqu\u0026rsquo;on trace un chemin eul√©rien sur un graphe, trois types de sommets se pr√©sentent : un sommet peut √™tre soit un point de d√©part, soit un point d\u0026rsquo;arriv√©e, soit un point travers√© (on y arrive puis on en repart). Et pour ces derniers, on aura toujours un nombre pair d\u0026rsquo;ar√™tes (autant d\u0026rsquo;arriv√©es que de d√©parts)\u0026hellip;\n Ce premier pas d\u0026rsquo;Euler eut lieu en 1737, il fallut attendre ensuite plus de cent ans pour que Kirchhoff r√©utilise des graphes pour d√©terminer les intensit√©s circulant dans les diff√©rentes branches d\u0026rsquo;un circuit √©lectrique ; il met alors au point la notion d'arbre, des graphes sans boucle, en 1847.\nDix ans plus tard, c\u0026rsquo;est au tour de la chimie de s\u0026rsquo;attaquer aux graphes. En 1857, Cayley s\u0026rsquo;int√©resse aux diff√©rentes structures possibles (isom√®res) d\u0026rsquo;une mol√©cule ayant $n$ atomes de carbone et $2n+2$ atomes d\u0026rsquo;hydrog√®ne (un alcane). Cela revient √† trouver tous les arbres √† $3n+2$ √©l√©ments tels que de chaque √©l√©ment (chaque sommet) partent exactement une ou quatre ar√™tes (symbolisant les liaisons chimiques).\nEn 1869, enfin, les math√©maticiens red√©couvrent les graphes, par la voix de Jordan qui, sans conna√Ætre les travaux de Cayley, retrouve ses r√©sultats.\nLes jeux ne sont pas en reste : en 1859, le math√©maticien et physicien irlandais William Hamilton invente \u0026ldquo;The Icosian Game\u0026rdquo;, dont le but est de visiter une et une seule fois tous les sommets d\u0026rsquo;un dod√©ca√®dre r√©gulier. Un tel chemin est depuis appel√© hamiltonien.\nApparemment voisin du probl√®me du chemin eul√©rien (visiter une et une seule fois chaque ar√™te), le probl√®me du chemin hamiltonien est en r√©alit√© beaucoup plus difficile.\nPour ce qui est du jeu que vous pouvez tester ci-dessous, une r√®gle suppl√©mentaire impose que la fin du chemin soit adjacente √† son d√©but. En rejoignant le point de d√©part, on formerait alors un cycle et on appelle ainsi cycle hamiltonnien un cycle passant par tous les sommets.\n¬†\nLe deuxi√®me moiti√© du 20e si√®cle et l\u0026rsquo;av√®nement de l\u0026rsquo;informatique voit la th√©orie des graphes prendre son v√©ritable essor : c\u0026rsquo;est en effet l\u0026rsquo;outil id√©al pour d√©crire les r√©seaux complexes modernes.\n  Les r√©seaux sont partout : les r√©seaux sociaux et les r√©seaux de communication, mais on trouve aussi des r√©seaux dans des champs scientifiques tr√®s diff√©rents comme en biologie, logistique, linguistique, √©conomie, etc.\nLa th√©orie des graphes donne un langage commun √† la description de ces r√©seaux.\n¬†Vocabulaire Graphes non orient√©s Un graphe $G$ est un ensemble de sommets (ou n≈ìuds) S (not√©s $s_i$) et d'ar√™tes A (not√©es $\\{s_i,s_j\\}$) reliant deux √† deux ces sommets. On note un tel graphe : $G = (S,A)$.\n Quelques exemples dans des champs vari√©s :\n   R√©seau Sommets Ar√™tes     transport a√©rien a√©roports vols   plans routiers carrefours tron√ßons de routes   r√©seau g√©n√©tique g√®nes facteurs de transcription   cerveau neurones synapses   colonie de fourmis jonctions traces de ph√©romones   appels t√©l√©phoniques num√©ro appel   r√©seau de citation auteur citation    Est repr√©sent√© ci-dessus le graphe $G=(S,A)$ avec $S=\\{1,2,3,4,5,6\\}$ et $A=\\{\\{1,2\\},\\{1,5\\},\\{2,5\\},\\{3,3\\},\\{4,6\\}\\}$\nUne boucle est une ar√™te reliant un sommet √† lui-m√™me.\n Exemple : il y a une boucle sur le sommet $3$.\nL\u0026rsquo;ensemble des sommets adjacents (joints par une ar√™te) au sommet $s_i$, autrement dit les voisins du sommet $s_i$, se note : $Adj(s_i)=\\{s_j \\in S,\\{ s_i,s_j \\}\\in A\\}$.\n Exemple : $Adj(2)=\\{1,5\\}$\n Un graphe non orient√© est dit simple s\u0026rsquo;il ne comporte pas de boucle et jamais plus d\u0026rsquo;une ar√™te entre deux sommets.\n Le graphe ci-dessus n\u0026rsquo;est donc pas simple.\nOn appelle ordre d\u0026rsquo;un graphe le nombre de ses sommets ($card(S)$ ou plus simplement $|S|$).\n Exemple : pour le graphe ci-dessus $|S|=6$\nOn appelle taille d\u0026rsquo;un graphe le nombre de ses ar√™tes ($card(A)$ ou $|A|$).\n Exemple : pour le graphe ci-dessus $|A|=5$\n¬†Graphes orient√©s Les ar√™tes d\u0026rsquo;un graphe non orient√© sont sym√©triques, elles se parcourent indiff√©remment dans les deux sens, mais ce n\u0026rsquo;est pas toujours tr√®s pertinent. Consid√©rons les exemples suivants :\n Supposons que l\u0026rsquo;on veuille mod√©liser un plan routier. On associe naturellement un carrefour √† un sommet et une rue √† une ar√™te. Mais on a besoin en plus d\u0026rsquo;une notion de direction pour repr√©senter les rues √† sens unique. Pour mod√©liser des relations sociales, une ar√™te entre Alice et Bob mod√©lise un lien, mais comment repr√©senter le fait que Bob connaisse Alice, mais que l\u0026rsquo;inverse soit faux ? Dans un r√©seau d\u0026rsquo;ordinateur, en particulier sans fil, le lien entre deux n≈ìuds est g√©n√©ralement non sym√©trique dans le sens o√π un message peut √™tre envoy√© de A vers B, mais pas l\u0026rsquo;inverse.  Pour mod√©liser ce type de situation, on utilise des graphes orient√©s.\nDans un graphe orient√©, les sommets sont reli√©s par des arcs que l\u0026rsquo;on peut identifier √† des couples de sommets (un couple a un ordre) : au couple $(a,b)$ correspond un arc d\u0026rsquo;origine $a$ et d\u0026rsquo;extr√©mit√© $b$.\n L\u0026rsquo;arc $a = (s_i,s_j)$ est dit sortant en $s_i$ et incident ou entrant en $s_j$, et $s_j$ est un successeur de $s_i$, tandis que $s_i$ est un pr√©d√©cesseur de $s_j$.\n L\u0026rsquo;ensemble des successeurs d\u0026rsquo;un sommet $s_i \\in S$ est not√© $Succ(s_i) = \\{s_j \\in S,(s_i,s_j) \\in A\\}$.\nL\u0026rsquo;ensemble des pr√©d√©cesseurs d\u0026rsquo;un sommet $s_i \\in S$ est not√© $Pred(s_i) = \\{s_j \\in S,(s_j,s_i) \\in A\\}$.\n Un graphe orient√© permet, par exemple, de r√©sumer les relations dans un chi-fou-mi (ici dans la variante puits montrant bien que jouer \u0026ldquo;pierre\u0026rdquo; est sans int√©r√™t, ou encore dans la variante pierre-feuille-ciseaux-l√©zard-spock de The Big Bang Theory). Pour \u0026ldquo;pierre-feuille-ciseaux-puits\u0026rdquo;, le graphe $G(S,A)$ a pour sommets $S=\\{pierre,feuille,ciseaux,puits\\}$ et pour ar√™tes $A=\\{(ciseaux,feuille),(feuille,puits),(feuille,pierre),(puits,pierre),(puits,ciseaux),(pierre,ciseaux)\\}$.\n¬†Degr√© d\u0026rsquo;un sommet Dans un graphe non-orient√©, le degr√© d\u0026rsquo;un sommet $s$ est le nombre d\u0026rsquo;ar√™tes incidentes √† ce sommet (une boucle comptant pour 2).\nDans le cas d\u0026rsquo;un graphe simple, on aura $d(s) = |Adj(s)|$ (nombre de sommets adjacents).\n Dans un graphe orient√©, le degr√© sortant d\u0026rsquo;un sommet $s$, not√© $d_+(s)$, est le nombre d\u0026rsquo;arcs partant de $s$ (de la forme $(s,v)$ avec $s,v \\in S$).\nDans le cas d\u0026rsquo;un graphe simple, on aura $d_+(s) = |Succ(s)|$ (nombre de successeurs).\nDe m√™me, le degr√© entrant d\u0026rsquo;un sommet $s$, not√© $d_‚àí(s)$, est le nombre d\u0026rsquo;arcs arrivant en $s$ (de la forme $(v, s)$ avec $s,v \\in S$).\nDans le cas d\u0026rsquo;un graphe simple, on aura $d_‚àí(s) = |Pred(s)|$ (nombre de pr√©d√©cesseurs).\nLe degr√© d\u0026rsquo;un sommet $s$ d\u0026rsquo;un graphe orient√© est donc la somme des degr√© entrant et sortant : $d(s) = d_+(s) + d_‚àí(s)$.\n Exemple : $d_+(puits)=2$ et $d_-(puits)=1$, d\u0026rsquo;o√π $d(puits) = d_+(puits) + d_‚àí(puits)=2+1=3$\n Pour tout graphe, la somme des degr√©s de chaque sommet est le double du nombre d\u0026rsquo;ar√™tes. $$\\sum_{s \\in S} d(s) = 2*|A|$$\n $d(puits)=d(feuille)=d(ciseaux)=d(pierre)=3$ d\u0026rsquo;o√π $\\sum_{s \\in S} d(s) = 12$. Et on a bien $|A|=6$. Et pour un graphe orient√©, la somme des degr√©s entrant vaut la somme des degr√©s sortants et est aussi √©gal au nombre d\u0026rsquo;ar√™tes. $$\\sum_{s \\in S} d_+(s) = \\sum_{s \\in S} d_-(s) = |A|$$\n     $d_+$ $d_-$     puits 2 1   feuille 2 1   ciseaux 1 2   pierre 1 2    $\\sum_{s \\in S} d_+(s) =\\sum_{s \\in S} d_-(s) =|A|=6$\nOn en d√©duit que pour tout graphe, il y a un nombre pair de sommets √† degr√© impair.\n Le degr√© d\u0026rsquo;un sommet est un concept simple, mais f√©cond, utilis√© dans des contextes tr√®s diff√©rents. Dans un r√©seau social, le degr√© d\u0026rsquo;un sommet traduit l\u0026rsquo;importance d\u0026rsquo;une personne dans le groupe. Dans un r√©seau de communication comme Internet, on apprend beaucoup sur l\u0026rsquo;organisation r√©elle du r√©seau √† partir de la distribution obtenue en ordonnant les sommets par leurs degr√©s.\n¬†Chemin, cha√Æne, cycle et circuit Cas des graphes orient√©s Soit $G = (S, A)$ un graphe orient√©.\nUn chemin d\u0026rsquo;un sommet $u$ vers un sommet $v$ est une s√©quence $\u0026lt; s_0,s_1,s_2,\u0026hellip;,s_k \u0026gt;$ de sommets tels que $u = s_0$, $v = s_k$ et $(s_{i‚àí1},s_i) \\in A$ pour tout $i \\in \\{1,\u0026hellip;,k\\}$.\nOn dira que le chemin contient les sommets $s_0,s_1,\u0026hellip;,s_k$ et les arcs $(s_0,s_1),(s_1,s_2),\u0026hellip;,(s_{k‚àí1},s_k)$.\nLa longueur du chemin est le nombre d\u0026rsquo;arcs dans le chemin, c\u0026rsquo;est-√†-dire $k$.\n S\u0026rsquo;il existe un chemin de $u$ √† $v$, on dira que $v$ est accessible √† partir de $u$.\n Un chemin $\u0026lt; s_0,s_1,\u0026hellip;,s_k \u0026gt;$ forme un circuit si $s_0 = s_k$ et si le chemin comporte au moins un arc ($k ‚â• 1$).\n Une boucle est un circuit de longueur $1$.\n  $\u0026lt;6,3,2,1\u0026gt;$ est un chemin du graphe. $\u0026lt;1,5,3,2,1\u0026gt;$ est un circuit.  Cas des graphes non orient√©s Si $G = (S, A)$ est un graphe non orient√©, on parlera de cha√Æne au lieu de chemin, et de cycle au lieu de circuit.\nDans le cas d\u0026rsquo;un cycle, toutes les ar√™tes doivent √™tre distinctes.\nUn graphe sans cycle est dit acyclique.\n  Un arbre est est un graphe acyclique et connexe.\n La ligne A du RER forme un arbre, mais pas la ligne C.\n¬†Distance dans un graphe La notion de longueur de chemin nous permet ensuite de d√©finir la notion de distance dans un graphe.\nSoit un graphe $G=(S,A)$. La distance d\u0026rsquo;un sommet √† un autre est la longueur du plus court chemin/cha√Æne entre ces deux sommets, ou $\\infty$ s\u0026rsquo;il n\u0026rsquo;y a pas un tel chemin/cha√Æne :\n$$ \\forall x,y \\in S,d(x,y)=\\left\\lbrace \\begin{array}{ll} k \\; \u0026amp;\\text{si le plus court chemin de x vers y est de longueur k}\\\\ \\infty \u0026amp;\\text{sinon}\\end{array}\\right. $$\n Le diam√®tre d\u0026rsquo;un graphe est la plus grande distance entre deux sommets.\n Exemple : dans le graphe orient√© ci-dessus $d(2,3)=3$, et $d(3,6)=\\infty$ (le sommet $6$ n\u0026rsquo;est pas accessible depuis le sommet $3$). Le diam√®tre du graphe vaut, lui, 4 (il s\u0026rsquo;agit de $d(6,5)$).\n¬†Connexit√© Un graphe non orient√© est connexe si chaque sommet est accessible √† partir de n\u0026rsquo;importe quel autre (pour tout couple de sommets distincts $(s_i,s_j) \\in S^2$, il existe une cha√Æne entre $s_i$ et $s_j$).\n Le graphe comportant les sommets $1,2,3,4$ n\u0026rsquo;est pas connexe mais celui comportant les sommets $5,6,7,8$ l\u0026rsquo;est !\n¬†Repr√©sentation d\u0026rsquo;un graphe Listes d\u0026rsquo;adjacence Soit le graphe $G = (S,A)$ d\u0026rsquo;ordre $n$. On suppose que les sommets de $S$ sont num√©rot√©s de $1$ √† $n$. La repr√©sentation par listes d\u0026rsquo;adjacence de $G$ consiste en un tableau $T$ de $n$ listes (un par sommet) :\nPour chaque sommet $s_i \\in S$, la liste d\u0026rsquo;adjacence $T[s_i]$ est une liste de tous les sommets $s_j$ tels qu\u0026rsquo;il existe un arc $(s_i,s_j) \\in A$ ou une ar√™te $\\{s_i,s_j\\} \\in A$.\nAutrement dit, pour chaque sommet, on liste ses voisins accessibles.\n Dans chaque liste d\u0026rsquo;adjacence, les sommets sont g√©n√©ralement ordonn√©s arbitrairement.\nPour l\u0026rsquo;impl√©mentation Python, on peut soit utiliser des listes imbriqu√©es, soit un dictionnaire.\nExemple : # Avec un dictionnaire T = {1:[1,3],2:[1,3,4],3:[],4:[1,2,3,4]} # Avec des listes imbriqu√©es T = [[1,3],[1,3,4],[],[1,2,3,4]] L\u0026rsquo;avantage du dictionnaire est qu\u0026rsquo;il n\u0026rsquo;impose pas d\u0026rsquo;avoir une correspondance entre le num√©ro du sommet et la position dans la liste d\u0026rsquo;adjacence (dans le cas de listes imbriqu√©es T[0] sera toujours la liste correspondant au premier sommet, T[1], celle du deuxi√®me, etc.).\nTaille m√©moire n√©cessaire: si le graphe G est orient√©, la somme des longueurs des listes d\u0026rsquo;adjacence est √©gale au nombre d\u0026rsquo;arcs de A, puisque l\u0026rsquo;existence d\u0026rsquo;un arc $(s_i,s_j)$ se traduit par la pr√©sence de $s_j$ dans la liste d\u0026rsquo;adjacence de $T[s_i]$.\nEn revanche, si le graphe n\u0026rsquo;est pas orient√©, la somme des longueurs de toutes les listes d\u0026rsquo;adjacence est √©gale √† deux fois le nombre d\u0026rsquo;ar√™tes du graphe, puisque si ${s_i,s_j}$ est une ar√™te, alors $s_i$ appartient √† la liste d\u0026rsquo;adjacence de $T[s_j]$, et vice versa.\nPar cons√©quent, la liste d\u0026rsquo;adjacence d\u0026rsquo;un graphe ayant $n$ sommets et $m$ arcs ou ar√™tes n√©cessite de l\u0026rsquo;ordre de $O(n + m)$ emplacements m√©moire.\n Op√©rations sur les listes d\u0026rsquo;adjacence : pour tester l\u0026rsquo;existence d\u0026rsquo;un arc $(s_i, s_j)$ ou d\u0026rsquo;une ar√™te ${s_i, s_j }$, on doit parcourir la liste d\u0026rsquo;adjacence de $T[s_i]$ jusqu\u0026rsquo;√† trouver $s_j$.\nEn revanche, le calcul du degr√© d\u0026rsquo;un sommet, ou l\u0026rsquo;acc√®s √† tous les successeurs d\u0026rsquo;un sommet, est tr√®s efficace : il suffit de parcourir la liste d\u0026rsquo;adjacence associ√©e au sommet. D\u0026rsquo;une fa√ßon plus g√©n√©rale, le parcours de l\u0026rsquo;ensemble des arcs/ar√™tes n√©cessite le parcours de toutes les listes d\u0026rsquo;adjacence, et prendra un temps de l\u0026rsquo;ordre de $p$, o√π $p$ est le nombre d\u0026rsquo;arcs/ar√™tes.\n Le calcul des pr√©d√©cesseurs d\u0026rsquo;un sommet n\u0026rsquo;est pas pratique avec cette repr√©sentation. Il n√©cessite le parcours de toutes les listes d\u0026rsquo;adjacences de $T$.\nSi l\u0026rsquo;on a besoin de conna√Ætre les pr√©d√©cesseurs d\u0026rsquo;un sommet, une solution est de maintenir, en plus de la liste d\u0026rsquo;adjacence des successeurs, la liste d\u0026rsquo;adjacence des pr√©d√©cesseurs.\n¬†Matrice d\u0026rsquo;adjacence Soit le graphe $G = (S,A)$ d\u0026rsquo;ordre $n$. On suppose que les sommets de $S$ sont num√©rot√©s de $1$ √† $n$. La repr√©sentation par matrice d\u0026rsquo;adjacence de $G$ consiste en une matrice bool√©enne $M=(m_{i,j})$ de taille $n\\times n$ telle que $m_{i,j} = 1$ si $ (i,j) \\in A$, et $m_{i,j} = 0$ sinon.\n La matrice d\u0026rsquo;adjacence d\u0026rsquo;un graphe non orient√© sera toujours sym√©trique, mais pas n√©cessairement celle d\u0026rsquo;un graphe orient√©.\n Impl√©mentation Python :\nM = [[1,0,1,0],[1,0,1,1],[0,0,0,0],[1,1,1,1]] # pour savoir si un arc joint le sommet 1 au sommet 3 M[0][2] # pour savoir si un arc joint le sommet 3 au sommet 1 M[2][0] Taille m√©moire n√©cessaire : La matrice d\u0026rsquo;adjacence d\u0026rsquo;un graphe ayant $n$ sommets n√©cessite de l\u0026rsquo;ordre de $O(n^2)$ emplacements m√©moire.\nSi le nombre d\u0026rsquo;arcs est tr√®s inf√©rieur √† $n^2$ (on parle alors de graphe creux), cette repr√©sentation est loin d\u0026rsquo;√™tre optimale.\n Op√©rations sur les matrices d\u0026rsquo;adjacence :\nle test de l\u0026rsquo;existence d\u0026rsquo;un arc ou d\u0026rsquo;une ar√™te avec une repr√©sentation par matrice d\u0026rsquo;adjacence est imm√©diat (il suffit de tester directement la case correspondante de la matrice).\nEn revanche, conna√Ætre le degr√© d\u0026rsquo;un sommet n√©cessite le parcours de toute une ligne (ou toute une colonne) de la matrice. D\u0026rsquo;une fa√ßon plus g√©n√©rale, le parcours de l\u0026rsquo;ensemble des arcs/ar√™tes n√©cessite la consultation de la totalit√© de la matrice, et prendra un temps de l\u0026rsquo;ordre de $n^2$.\n Application : Combien y a-t-il de chemins menant d\u0026rsquo;un sommet √† un autre en exactement $n$ coups ?\nOn cherche donc les chemins de longueur $n$ entre deux sommets $i$ et $j$.\nSoit $M = (m_{i,j})$ la matrice d\u0026rsquo;adjacence d\u0026rsquo;un graphe $G(S,A)$. $M$ est donc aussi le nombre de chemin de $i$ √† $j$ de longueur $1$ (une seul ar√™te), que l\u0026rsquo;on va noter $m_{i,j}(1)$.\nL\u0026rsquo;id√©e est alors de d√©couper le chemin de longueur $n$ en un chemin de longueur $n-1$ suivi d\u0026rsquo;un chemin de longueur $1$. Le nombre $m_{i,j}(n)$ de chemins de longueur $n$ est ainsi donn√© par : $$ m_{i,j}(n)=\\sum_{k=1}^{|S|}m_{i,k}(n-1)\\times m_{k,j}(1)$$ Pour $ m_{i,j}(2) $, on obtient $m_{i,j}(n)=\\sum_{k=1}^{|S|}m_{i,k}(1)\\times m_{k,j}(1)$ qui n\u0026rsquo;est autre que $M^2$ (on reconna√Æt en effet la formule du produit matriciel).\nEt par une r√©currence imm√©diate, pour des chemins de longueur $n$, il suffit de calculer $M^n$.\nExemple : combien y a-t-il de chemins de longueur 4 entre les sommets 2 et 3 du graphe repr√©sent√© ci-dessous. La matrice d\u0026rsquo;adjacence du graphe vaut $M = \\begin{pmatrix}1\u0026amp;1\u0026amp;0\\\\0\u0026amp;0\u0026amp;1\\\\1\u0026amp;1\u0026amp;0\\end{pmatrix}$. Utilisons Python pour calculer $M^4$ :\nimport numpy as np # librairie tr√®s utile pour les calculs sur matrices from numpy.linalg import matrix_power M = [[1,1,0],[0,0,1],[1,1,0]] M = np.array(M) # on convertit M en tableau numpy M4 = matrix_power(M,4) print(f\u0026#34;Il y a {M4[2][0]} chemins de longueur 4 du sommet 3 au sommet 1.\u0026#34;) Il y a 3 chemins de longueur 4 du sommet 3 au sommet 1. ¬†Parcours d\u0026rsquo;un graphe Pour d√©terminer si un sommet est accessible depuis un autre sommet, il faut pouvoir parcourir m√©thodiquement l\u0026rsquo;ensemble du graphe.\nAlgorithme de parcours en largeur Une premi√®re m√©thode, l\u0026rsquo;algorithme de parcours en largeur (ou breadth-first algorithm), consiste √† partir d\u0026rsquo;un n≈ìud, d\u0026rsquo;explorer tous ses successeurs, puis les successeurs de chacun de ses successeurs, etc., jusqu\u0026rsquo;√† ce qu\u0026rsquo;il n\u0026rsquo;y ait plus de sommets.\nCela revient √† inspecter le graphe par couche concentrique de plus en plus √©loign√©es du n≈ìud source.\nPour impl√©menter un tel algorithme, la structure de donn√©es adapt√©e est la file.\n Les files (queues en anglais) sont des structures dynamiques (les √©l√©ments sont enfil√©s ou d√©fil√©s) qui, √† l\u0026rsquo;instar d\u0026rsquo;une file d\u0026rsquo;attente √† une caisse, c\u0026rsquo;est le premier arriv√© qui est le premier retir√© (FIFO pour \u0026ldquo;first in first out\u0026rdquo;). Les files sont utilis√©es par exemple lorsqu\u0026rsquo;il y a une possibilit√© d\u0026rsquo;encombrement (pour une imprimante partag√©e par exemple).\n L\u0026rsquo;id√©e est de placer chaque nouveau successeur au bout d\u0026rsquo;une file (enfiler), puis de retirer un √† un (d√©filer) les premiers arriv√©s (donc les plus proches) lorsqu\u0026rsquo;ils sont √† leur tour inspect√©s.\nPour l\u0026rsquo;impl√©mentation des files, on pourrait utiliser des listes python en ajoutant toujours les √©l√©ments √† la fin et les retirant au d√©but, mais ce n\u0026rsquo;est pas tr√®s efficace. En effet, l\u0026rsquo;ajout d\u0026rsquo;un √©l√©ment en d√©but de liste √† un co√ªt lin√©aire (proportionnel √† la taille de la liste). On pourrait pourtant tirer partie de la structure particuli√®rement simple des files o√π seule deux positions (premi√®re et derni√®re) nous int√©ressent.\nMais comme souvent en python, un module d√©di√©, ici collecions.deque, peut nous venir en aide. Il impl√©ment efficacement les files en permettant un enfilage et un d√©filage en temps constant.\nG = {\u0026#34;Bob\u0026#34; : [\u0026#34;Alice\u0026#34;,\u0026#34;Dave\u0026#34;,\u0026#34;Charlie\u0026#34;], \u0026#34;Alice\u0026#34; : [\u0026#34;Elisa\u0026#34;], \u0026#34;Charlie\u0026#34; : [\u0026#34;Elisa\u0026#34;,\u0026#34;Hector\u0026#34;], \u0026#34;Dave\u0026#34; : [\u0026#34;Farid\u0026#34;,\u0026#34;Gus\u0026#34;], \u0026#34;Elisa\u0026#34; : [], \u0026#34;Farid\u0026#34; : [], \u0026#34;Gus\u0026#34; : [], \u0026#34;Hector\u0026#34; : [] } from collections import deque # pr√©conditions: graphe G(S,A) repr√©sent√© par une liste d\u0026#39;adjacence par un dictionnaire et un sommet s de S # postconditions : un sommet est accessible depuis s si et seulement si il est marqu√© comme \u0026#34;vu\u0026#34; (dans la liste vus). def parcours_largeur(G,depart): file = deque() file.append(depart) Sommets = [] Vus = [] while file : sommet = file.popleft() # m√©thode de la classe deque permettant de d√©filer (√©quivaut √† pop(0) sur une liste) if not sommet in Vus : file += G[sommet] Vus.append(sommet) # on marque les sommets vus (√©vite ici d\u0026#39;avoir 2 Elisa, mais √ßa peut √™tre bien pire) Sommets.append(sommet) return Sommets parcours_largeur(G,\u0026quot;Bob\u0026quot;) renvoie ['Bob', 'Alice', 'Dave', 'Charlie', 'Elisa', 'Farid', 'Gus', 'Hector']. Si on ne marque pas les sommets vus (ici gr√¢ce √† la liste vus), on se retrouve avec une boucle infinie d√®s qu\u0026rsquo;il y a un circuit ou un cycle (le simple graphe ü¶â‚áÜüêò par exemple).\n Que vaut la complexit√© temporelle de l\u0026rsquo;algorithme ? Que devient-elle sans l\u0026rsquo;utilisation de la classe deque fournissant une vraie file ?\n¬†Exemples d\u0026rsquo;applications du parcours en largeur :\n utilis√© par les robots d\u0026rsquo;exploration des moteurs de recherche pour construire l\u0026rsquo;index des pages web, recherche dans les r√©seaux sociaux, recherche d\u0026rsquo;un n≈ìud voisin accessible dans les r√©seaux peer-to-peer.  ¬†Algorithme de parcours en profondeur Cette fois-ci, on explore jusqu\u0026rsquo;au bout chaque cha√Æne de successeurs du n≈ìud source avant de passer √† la suivante.\nCette fois-ci, la structure de donn√©es dynamique adapt√©e est la pile.\n Les piles (stacks en anglais) sont des structures dynamiques (des √©l√©ments sont ajout√©s = empil√©s, ou retir√©s = d√©pil√©s) ayant la propri√©t√© que l‚Äô√©l√©ment extrait est celui qui y a √©t√© introduit le plus r√©cemment (\u0026ldquo;dernier entr√©, premier sortie\u0026rdquo; ou LIFO \u0026ldquo;last in first out\u0026rdquo; en anglais). C\u0026rsquo;est l\u0026rsquo;√©quivalent informatique d\u0026rsquo;une pile d\u0026rsquo;assiettes. Cette structure est par exemple utilis√©e dans la fonction \u0026ldquo;annuler\u0026rdquo; (CTR-Z) d\u0026rsquo;un logiciel ou encore dans le traitement des fonctions r√©cursives (les piles seront √©tudi√©es plus en d√©tail en seconde ann√©e).\n def parcours_profondeur(G,depart): pile = deque() pile.append(depart) Sommets = [] Vus = [] while pile : sommet = pile.pop() if not sommet in Vus : pile += G[sommet] Vus.append(sommet) Sommets.append(sommet) return Sommets parcours_largeur(G,\u0026quot;Bob\u0026quot;) renvoie ['Bob', 'Charlie', 'Hector', 'Elisa', 'Dave', 'Gus', 'Farid', 'Alice'].\nOn remarque que les deux algorithmes ne diff√®rent que par la structure de donn√©es utilis√©e, mais loin d\u0026rsquo;√™tre anodin, ce passage de la file √† la pile change compl√®tement le principe du parcours !\nCela illustre bien que la conception d\u0026rsquo;un algorithme est tr√®s d√©pendantes des structures de donn√©es utilis√©es.\nUne structure de donn√©e est une fa√ßon d\u0026rsquo;organiser les donn√©es de telle sorte que certaines op√©rations sur ces donn√©es soient tr√®s rapides. Une structure de donn√©e est donc sp√©cialis√©e dans ces quelques op√©rations.\nLors de la conception, d\u0026rsquo;un algorithme, l\u0026rsquo;identification des diff√©rentes op√©rations √† effectuer va guider le choix de la structure de donn√©e adapt√©e.\nPar exemple, l\u0026rsquo;algorithme de recherche en largeur doit g√©rer un ensemble o√π le premier √©l√©ment ajouter doit toujours √™tre le premier retir√© (logique FIFO) $\\rightarrow$ utilisation d\u0026rsquo;une file qui g√®re l\u0026rsquo;ajout d\u0026rsquo;un √©l√©ment √† la fin d\u0026rsquo;une file d\u0026rsquo;attente et l\u0026rsquo;extraction au d√©but en temps constant (elle est optimis√© pour √ßa, mais en contrepartie, elle ne sait faire que √ßa).\nL\u0026rsquo;algorithme de recherche en profondeur suit lui la logique LIFO $\\rightarrow$ utilisation d\u0026rsquo;une pile.\nDernier exemple : l\u0026rsquo;algorithme de Dijkstra (d√©crit plus loin) a besoin √† chaque it√©ration d\u0026rsquo;ajouter un √©l√©ment √† un ensemble et d\u0026rsquo;en retirer le plus petit √©l√©ment $\\rightarrow$ ce sont les deux op√©rations dont le tas s\u0026rsquo;est fait le sp√©cialiste (le tas est un arbre binaire presque complet ordonn√©). Un tas sp√©cialis√© dans ces deux op√©rations s\u0026rsquo;appelle est aussi appel√© file de priorit√©. Dans quels autres algorithmes pourrait avantageusement √™tre utilis√© un tas ?\n Nous n\u0026rsquo;avions pas r√©ellement besoin de la classe deque pour impl√©menter efficacement la pile. En effet, si ins√©rer un √©l√©ment au d√©but d\u0026rsquo;une liste python de taille $n$ a bien un co√ªt lin√©aire ($O(n)$) et ralentit donc l\u0026rsquo;ex√©cution par rapport √† l\u0026rsquo;utilisation d\u0026rsquo;une file, retirer un √©l√©ment √† la fin (via pop) se fait en temps constant ($O(1)$).\n¬†Exemples d\u0026rsquo;applications du parcours en profondeur :\n utilis√© pour trouver un chemin entre deux sommets, d√©tection de cycles dans un graphe, utilis√© dans le tri topologique, utilis√© pour trouver la sortie d\u0026rsquo;un labyrinthe.  ¬†Graphes pond√©r√©s Dans de nombreuses situations, les ar√™tes d\u0026rsquo;un graphe ne sont pas toutes √©quivalentes. On ajoute alors l\u0026rsquo;information du \u0026ldquo;co√ªt\u0026rdquo; que cela repr√©sente d\u0026rsquo;emprunter telle ou telle ar√™te. On appelle poids ces valeurs ajout√©es aux ar√™tes/arcs.\nPar exemple, pour mod√©liser un r√©seau ferroviaire, on peut attribuer √† chaque ar√™te mod√©lisant les jonctions entre deux gares la distance correspondante. Et pour un r√©seau de communication, le poids d\u0026rsquo;une ar√™te correspondra plut√¥t au temps n√©cessaire pour transf√©rer un message de taille √©l√©mentaire.\nOn obtient alors un graphe pond√©r√©.\nOn utilise aussi souvent des graphes pond√©r√©s, plus particuli√®rement des arbres de probabilit√© (o√π chaque branche est affubl√©e d\u0026rsquo;une probabilit√©) pour calculer des probabilit√©s conditionnelles.\nExemple : Tr√®s souvent (particuli√®rement pour les r√©seaux de communication), l\u0026rsquo;information ajout√©e au graphe un temps ou une distance et se pose alors le probl√®me de l\u0026rsquo;optimisation d\u0026rsquo;un trajet entre deux sommets.\nLe poids d\u0026rsquo;un chemin est la somme des poids des arcs emprunt√©s.\n La distance entre deux sommets (dans un graphe pond√©r√©) correspond au chemin de poids minimum entre ces deux sommets.\n ¬†Probl√®me du plus court chemin Pas au programme de TSI mais plus prudent d\u0026rsquo;en avoir entendu parler pour l\u0026rsquo;√©preuve de Centrale qui jusqu\u0026rsquo;√† maintenant √©tait commune aux autres sections.\n Si le graphe consid√©r√© n\u0026rsquo;est pas pond√©r√©, l\u0026rsquo;algorithme de parcours en largeur, moyennant quelques adaptations, est tout √† fait capable de faire le travail.\nAlgorithme de parcours en largeur Comme l\u0026rsquo;algorithme de parcours en largeur examine le graphe en couches concentriques depuis le sommet de d√©part, lorsqu\u0026rsquo;il parvient au sommet cible, on est s√ªr que le nombre d\u0026rsquo;arcs est minimal.\nIl suffit alors de joindre √† la liste des sommets examin√©s, la liste des chemins permettant de parvenir √† chacun de ces sommets (en incr√©mentant √† chaque tour chacun des chemins du sommet correspondant de la nouvelle couche).\ndef recherche_largeur(G,depart,arrivee): file = [(depart,[depart])] # on remplace la file des sommets par une file de tuples (sommet,chemin) Vus = [] while file : sommet,chemin = file.pop(0) # pop(0) fait la m√™me chose que le popleft des deque if sommet == arrivee : return chemin # si l\u0026#39;arriv√©e est atteinte, on retourne le chemin correspondant if not sommet in Vus : for s in G[sommet] : nv_chemin = chemin+[s] file.append((s,nv_chemin)) Vus.append(sommet) return False # si l\u0026#39;arriv√©e n\u0026#39;est pas atteinte, on renvoie Faux G = {\u0026#34;Minimes\u0026#34; : {\u0026#34;Tasdon\u0026#34;,\u0026#34;H√¥pital\u0026#34;}, \u0026#34;H√¥pital\u0026#34; : {\u0026#34;Verdun\u0026#34;}, \u0026#34;Verdun\u0026#34; : {\u0026#34;Stade\u0026#34;}, \u0026#34;Tasdon\u0026#34; : {\u0026#34;Cognehors\u0026#34;, \u0026#34;Lafond\u0026#34;}, \u0026#34;Cognehors\u0026#34; : {\u0026#34;Verdun\u0026#34;}, \u0026#34;Lafond\u0026#34; : {\u0026#34;Mireuil\u0026#34;}, \u0026#34;Mireuil\u0026#34; : {\u0026#34;Stade\u0026#34;}, \u0026#34;Stade\u0026#34; : {} } recherche_largeur(G,\u0026quot;Minimes\u0026quot;,\u0026quot;Stade\u0026quot;) retourne bien le chemin comportant le moins d\u0026rsquo;ar√™tes : ['Minimes', 'H√¥pital', 'Verdun', 'Stade'].\nMais si on ajoute des poids, l\u0026rsquo;algorithme de recherche en largeur devient inefficace puisqu\u0026rsquo;il se borne √† donner la m√™me r√©ponse (les pond√©rations sont nul part prises en compte !).\n G_pond = {\u0026#34;Minimes\u0026#34; : {\u0026#34;Tasdon\u0026#34;:5,\u0026#34;H√¥pital\u0026#34;:4}, \u0026#34;H√¥pital\u0026#34; : {\u0026#34;Verdun\u0026#34;:21}, \u0026#34;Verdun\u0026#34; : {\u0026#34;Stade\u0026#34;:4}, \u0026#34;Tasdon\u0026#34; : {\u0026#34;Cognehors\u0026#34;:7, \u0026#34;Lafond\u0026#34;:7}, \u0026#34;Cognehors\u0026#34; : {\u0026#34;Verdun\u0026#34;:8}, \u0026#34;Lafond\u0026#34; : {\u0026#34;Mireuil\u0026#34;:5}, \u0026#34;Mireuil\u0026#34; : {\u0026#34;Stade\u0026#34;:3}, \u0026#34;Stade\u0026#34; : {} } recherche_largeur(G_pond,\u0026quot;Minimes\u0026quot;,\u0026quot;Stade\u0026quot;) retourne √† nouveau ['Minimes', 'H√¥pital', 'Verdun', 'Stade'] alors qu\u0026rsquo;il y a maintenant des chemins plus rapides !\n¬†Algorithme de Dijkstra # pr√©conditions : un graphe orient√© Ôøºpond√©r√© G(S,A) avec des poids positifs pour chaque arc repr√©sent√© par une liste d‚Äôadjacence gr√¢ce √† un dictionnaire, un sommet s_0 de S # postcondition : pour chaque sommet Ôøºs_i de S la distance trouv√©e correspond bien au chemin le plus court entre s_0 et s_i (d(s_0,s_i)) def sommet_suivant(scores,vus) : \u0026#34;\u0026#34;\u0026#34; retourne le sommet absent de vus au plus bas score \u0026#34;\u0026#34;\u0026#34; plus_bas_score = float(\u0026#34;inf\u0026#34;) sommet_choisi = None for sommet in scores : score = scores[sommet] if score \u0026lt; plus_bas_score and sommet not in vus : plus_bas_score = score sommet_choisi = sommet return sommet_choisi def Dijkstra(G,depart) : # on construit Scores et Preds dans lesquels on mettra √† jour les scores calcul√©s et les pr√©decesseurs des sommets examin√©s Scores = {} Preds = {} # initialisation for s in G.keys() : Scores[s] = float(\u0026#34;inf\u0026#34;) Preds[s] = None Scores[depart] = 0 Vus = [] # liste pour stocker les sommets examin√©s sommet = sommet_suivant(Scores,Vus) while sommet is not None : score = Scores[sommet] Succ = G[sommet] for n in Succ.keys(): nv_score = score + Succ[n] if Scores[n] \u0026gt; nv_score : Scores[n] = nv_score Preds[n] = sommet Vus.append(sommet) sommet = sommet_suivant(Scores,Vus) return Preds,Scores preds,scores = Dijkstra(G_pond,\u0026#34;Minimes\u0026#34;) print(preds) print(scores) # Ce qui s\u0026#39;affiche : {\u0026#39;Minimes\u0026#39;: None, \u0026#39;H√¥pital\u0026#39;: \u0026#39;Minimes\u0026#39;, \u0026#39;Verdun\u0026#39;: \u0026#39;Cognehors\u0026#39;, \u0026#39;Tasdon\u0026#39;: \u0026#39;Minimes\u0026#39;, \u0026#39;Cognehors\u0026#39;: \u0026#39;Tasdon\u0026#39;, \u0026#39;Lafond\u0026#39;: \u0026#39;Tasdon\u0026#39;, \u0026#39;Mireuil\u0026#39;: \u0026#39;Lafond\u0026#39;, \u0026#39;Stade\u0026#39;: \u0026#39;Mireuil\u0026#39;} {\u0026#39;Minimes\u0026#39;: 0, \u0026#39;H√¥pital\u0026#39;: 4, \u0026#39;Verdun\u0026#39;: 20, \u0026#39;Tasdon\u0026#39;: 5, \u0026#39;Cognehors\u0026#39;: 12, \u0026#39;Lafond\u0026#39;: 12, \u0026#39;Mireuil\u0026#39;: 17, \u0026#39;Stade\u0026#39;: 20}    ¬†La complexit√© de cette impl√©mentation de l\u0026rsquo;algorithme de Dijkstra est en $O(|S|^2)$ o√π comme vu plus haut, $|S|$ est le nombre de sommets du graphe.\n En effet, chaque sommet est inspect√© pour √™tre scor√© et lors de chaque inspection (= chaque it√©ration), on inspecte l\u0026rsquo;ensemble des successeurs de ce sommet (et dans le pire des cas, le sommet a $|S|-1$ successeurs).\nComme √©voqu√© dans une notice pr√©c√©dente, on peut am√©liorer la complexit√© en utilisant une structure de donn√©e adapt√©e au probl√®me : le tas.\nL\u0026rsquo;id√©e est d\u0026rsquo;am√©liorer le choix du prochain sommet inspect√©, celui au plus bas score parmi les sommets pas encore valid√©s. En effet, r√©inspecter syst√©matiquement toute la liste des sommets restants ne semble pas optimal. C\u0026rsquo;est sur ce point que le tas vient √† la rescousse :\nle tas est une structure de donn√©es de type arbre qui permet de retrouver directement l\u0026rsquo;√©l√©ment que l\u0026rsquo;on veut traiter en priorit√©. Le tas garde en permanence le sommet de plus bas score en son sommet avec un co√ªt logarithmique.\nCons√©quence : si on remplace la fonction sommet_suivant par un tas et ses op√©rations d√©di√©es d\u0026rsquo;ajout et d\u0026rsquo;extraction, on passe d\u0026rsquo;une complexit√© lin√©aire √† une complexit√© logarithmique pour cette op√©ration.\nGr√¢ce au tas, la complexit√© de Dijkstra est maintenant quasilin√©aire ($O(|S|\\log|S|)$).\n import heapq # module impl√©mentant un tas (heap en anglais) def Dijkstra(G, depart, arrivee): Scores = {sommet: float(\u0026#39;infinity\u0026#39;) for sommet in G} Preds = {sommet : None for sommet in G} Scores[depart] = 0 Vus = [] tas = [(0, depart)] # liste de tuples contenant le score et le sommet associ√© # le score correspond alors √† la priorit√© du tas while tas : score_actuel, sommet_actuel = heapq.heappop(tas) # on retire l\u0026#39;√©l√©ment prioritaire du tas if sommet_actuel == arrivee : return Preds,Scores,Vus if score_actuel \u0026lt;= Scores[sommet_actuel]: score_voisin = G[sommet_actuel] for voisin in score_voisin.keys(): if voisin not in Vus : Vus.append(voisin) score = score_actuel + score_voisin[voisin] if score \u0026lt; Scores[voisin]: Scores[voisin] = score Preds[voisin] = sommet_actuel heapq.heappush(tas, (score, voisin)) # on ajoute le score et le sommet au tas On verra dans le TP comment encore am√©liorer les choses gr√¢ce √† l\u0026rsquo;utilisation d\u0026rsquo;une heuristique. On passe alors de l\u0026rsquo;algorithme de Dijkstra √† l\u0026rsquo;algorithme A* (A star ou A √©toile).\n"
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_2/tp10graphes/",
	"title": "TP 10 : les graphes",
	"tags": [],
	"description": "",
	"content": "TP10 : les graphes Cliquez sur cette invitation pour r√©cup√©rer le repository du TP.  Le dessin ci-dessus peut se repr√©senter par (choisir la bonne r√©ponse) :\n a : un graphe orient√© b : un graphe non orient√©    Le degr√© du sommet C vaut :\n a : 2 b : 3 c : 5    Le distance de F √† C vaut :\n a : 1 b : 3 c : $\\infty$    En transformant les arcs en ar√™tes, quel serait le diam√®tre du graphe ?\n a : 4 b : 5 c : $\\infty$   ¬†Listes et matrices d\u0026rsquo;adjacence  Construire le graphe G_la correspondant au dessin du haut sous la forme d\u0026rsquo;une liste d\u0026rsquo;adjacence en utilisant un dictionnaire (sur le mod√®le du cours).\nLes sommets devront s\u0026rsquo;appeler \u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;D\u0026quot;,\u0026quot;E\u0026quot; et \u0026quot;F\u0026quot;.\n  Construire maintenant le graphe G_ma correspondant au dessin ci-dessus sous la forme d\u0026rsquo;une matrice d\u0026rsquo;adjacence (en suivant le mod√®le donn√© dans le cours).\n ¬†Manipulation d\u0026rsquo;un graphe Ajouter un sommet √† un graphe  Construire une fonction qui ajoute un sommet S √† un graphe G orient√©. Le graphe G est repr√©sent√© par une liste d\u0026rsquo;adjacence et on donne en argument de la fonction la liste des pr√©d√©cesseurs et des successeurs du sommet S ($Pred(S)$ et $Succ(S)$).\n def ajouteSommet(G,S,pred,succ) : \u0026#34;\u0026#34;\u0026#34; ajouteSommet(G:dict,S:str,pred:list,succ:list)-\u0026gt;G:dict pr√©conditions : G est un graphe dont certains des sommets font partie de la liste pred et certains de la liste succ. S est le nom d\u0026#39;un sommet n\u0026#39;appartenenat pas √† G. G est mod√©lis√© par une liste d\u0026#39;adjacence utilisant un dictionnaire. pred et succ sont les listes des pr√©d√©cesseurs et des successeurs de S. postcondition : la fonction retourne le graphe mis √† jour (mut√©) avec le sommet S ajout√©. \u0026#34;\u0026#34;\u0026#34; # VOTRE CODE Le graphe de gauche est mod√©lis√© ci-dessous par une liste d\u0026rsquo;adjacence :\nGraphe = {\u0026#39;A\u0026#39; : [\u0026#39;E\u0026#39;,\u0026#39;D\u0026#39;], \u0026#39;B\u0026#39; : [\u0026#39;D\u0026#39;], \u0026#39;C\u0026#39; : [\u0026#39;B\u0026#39;], \u0026#39;D\u0026#39; : [\u0026#39;C\u0026#39;,\u0026#39;E\u0026#39;], \u0026#39;E\u0026#39; : [], \u0026#39;F\u0026#39; : [\u0026#39;B\u0026#39;]} On souhaite lui ajouter le sommet 'G'.\n Compl√©ter au pr√©alable les listes Pred et Succ contenant les pr√©d√©cesseurs et les successeurs de 'G'.\n Pred = [] Succ = []  Testez ensuite votre fonction ajouteSommet pour v√©rifier que le graphe est modifi√© comme souhait√©.\n ¬†Retirer un sommet √† un graphe  On souhaite maintenant construire la fonction retireSommet permettant de retirer un sommet d\u0026rsquo;un graphe.\nElle prend en argument le graphe et un sommet du graphe.\nVous utiliserez un assert pour vous assurer que le sommet pass√© en argument appartient bien augraphe.\n def retireSommet(G,S) : \u0026#34;\u0026#34;\u0026#34; retireSommet(G:dict,S:str)-\u0026gt;G:dict pr√©conditions : G est un graphe et S est un de ses sommets. G est mod√©lis√© par une liste d\u0026#39;adjacence utilisant un dictionnaire postcondition : la fonction retourne le graphe mis √† jour (mut√©) avec le sommet S en moins \u0026#34;\u0026#34;\u0026#34; # VOTRE CODE Reprenons le graphe pr√©c√©dent avant l\u0026rsquo;ajout du sommet 'G'.\nGraphe = {\u0026#39;A\u0026#39; : [\u0026#39;E\u0026#39;,\u0026#39;D\u0026#39;], \u0026#39;C\u0026#39; : [\u0026#39;B\u0026#39;], \u0026#39;D\u0026#39; : [\u0026#39;C\u0026#39;,\u0026#39;E\u0026#39;], \u0026#39;E\u0026#39; : [], \u0026#39;F\u0026#39; : [\u0026#39;B\u0026#39;]}  Testez ensuite votre fonction retireSommet pour v√©rifier que le graphe est modifi√© comme souhait√©.\n ¬†Utilisation d\u0026rsquo;un module pour visualiser import networkx as nx from IPython.display import Image import pandas as pd Construisons la matrice d\u0026rsquo;adjacence d\u0026rsquo;un graphe non-orient√© complet.\nmatrice = [[0, 2, 2, 3, 3, 2, 1, 1, 2, 1], [2, 0, 1, 2, 2, 1, 2, 1, 3, 1], [2, 1, 0, 3, 1, 1, 1, 1, 3, 2], [3, 2, 3, 0, 1, 1, 3, 1, 2, 3], [3, 2, 1, 1, 0, 2, 2, 3, 3, 1], [2, 1, 1, 1, 2, 0, 1, 3, 2, 1], [1, 2, 1, 3, 2, 1, 0, 2, 1, 1], [1, 1, 1, 1, 3, 3, 2, 0, 1, 3], [2, 3, 3, 2, 3, 2, 1, 1, 0, 3], [1, 1, 2, 3, 1, 1, 1, 3, 3, 0]]  Construisez √† votre tour une matrice M semblable √† la pr√©c√©dente en tirant chaque √©l√©ment au hasard parmi la liste [1,2,3] gr√¢ce √† la fonction choice du module random (choice(L) retourne un des √©l√©ments de L choisi au hasard).\nCette matrice devra n\u0026rsquo;avoir que des 0 dans sa diagonale et √™tre sym√©trique.\nAttention: le nom de la matrice doit √™tre M.\n from random import choice n = 10 # nombre de sommets # VOTRE CODE Si vous avez r√©ussi √† construire M vous pourrez utilisez votre matrice par la suite.\nOn transforme ensuite la matrice en dataframe pandas qui sera reconnue par le module networkx et on lui ajoute des lettres en en-t√™te de ligne et de colonne pour nommer les sommets.\nabc = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; labels = list(abc[:n]) M_df = pd.DataFrame(matrice, index=labels, columns=labels) print(M_df)     A B C D E F G H I J     A 0 2 2 3 3 2 1 1 2 1   B 2 0 1 2 2 1 2 1 3 1   C 2 1 0 3 1 1 1 1 3 2   D 3 2 3 0 1 1 3 1 2 3   E 3 2 1 1 0 2 2 3 3 1   F 2 1 1 1 2 0 1 3 2 1   G 1 2 1 3 2 1 0 2 1 1   H 1 1 1 1 3 3 2 0 1 3   I 2 3 3 2 3 2 1 1 0 3   J 1 1 2 3 1 1 1 3 3 0    G_complet = nx.from_pandas_adjacency(M_df) # obtention du graphe networkx √† partir de la dataframe weights = [G_complet[u][v][\u0026#39;weight\u0026#39;]*3 for u,v in G_complet.edges()] # liste des poids (*3) # Trac√© options = {\u0026#34;font_size\u0026#34;: 20, \u0026#34;font_weight\u0026#34;:\u0026#34;bold\u0026#34;, \u0026#34;node_size\u0026#34;: 1000, \u0026#34;node_color\u0026#34;: \u0026#34;#34A5DA\u0026#34;, \u0026#34;edge_color\u0026#34;: weights, # couleur en fonction des poids \u0026#34;width\u0026#34;: weights, # √©paisseur des ar√™tes en fonction des poids \u0026#34;edge_cmap\u0026#34;: plt.cm.Set3, \u0026#34;with_labels\u0026#34;: True, \u0026#34;font_color\u0026#34;: \u0026#34;white\u0026#34;, \u0026#34;linewidths\u0026#34;: 5, } pos = nx.shell_layout(G_complet) fig = plt.figure(figsize=(12, 12)) nx.draw(G_complet,pos=pos,**options) labels = nx.get_edge_attributes(G_complet,\u0026#39;weight\u0026#39;) nx.draw_networkx_edge_labels(G_complet, pos=pos,edge_labels=labels) plt.show()  Transformez la matrice matrice en une liste d\u0026rsquo;adjacence G_la n\u0026rsquo;utilisant que des dictionnaires.\nG_la devra ressembler √† :\n {\u0026#39;A\u0026#39; : {\u0026#39;B\u0026#39;: 3, \u0026#39;C\u0026#39;: 3, \u0026#39;D\u0026#39;: 2, \u0026#39;E\u0026#39;: 1, \u0026#39;F\u0026#39;: 1, \u0026#39;G\u0026#39;: 2, \u0026#39;H\u0026#39;: 2, \u0026#39;I\u0026#39;: 1, \u0026#39;J\u0026#39;: 1}, \u0026#39;B\u0026#39; : {\u0026#39;A\u0026#39;: 3, \u0026#39;C\u0026#39;: 1, \u0026#39;D\u0026#39;: 3, \u0026#39;E\u0026#39;: 1, \u0026#39;F\u0026#39;: 3, \u0026#39;G\u0026#39;: 3, \u0026#39;H\u0026#39;: 3, \u0026#39;I\u0026#39;: 2, \u0026#39;J\u0026#39;: 1}, \u0026#39;C\u0026#39; : {\u0026#39;A\u0026#39;: 3, \u0026#39;B\u0026#39;: 1, \u0026#39;D\u0026#39;: 3, \u0026#39;E\u0026#39;: 3, \u0026#39;F\u0026#39;: 1, \u0026#39;G\u0026#39;: 1, \u0026#39;H\u0026#39;: 1, \u0026#39;I\u0026#39;: 2, \u0026#39;J\u0026#39;: 2}, \u0026#39;D\u0026#39; : {\u0026#39;A\u0026#39;: 2, \u0026#39;B\u0026#39;: 3, \u0026#39;C\u0026#39;: 3, \u0026#39;E\u0026#39;: 2, \u0026#39;F\u0026#39;: 3, \u0026#39;G\u0026#39;: 1, \u0026#39;H\u0026#39;: 1, \u0026#39;I\u0026#39;: 3, \u0026#39;J\u0026#39;: 2}, \u0026#39;E\u0026#39; : {\u0026#39;A\u0026#39;: 1, \u0026#39;B\u0026#39;: 1, \u0026#39;C\u0026#39;: 3, \u0026#39;D\u0026#39;: 2, \u0026#39;F\u0026#39;: 2, \u0026#39;G\u0026#39;: 1, \u0026#39;H\u0026#39;: 2, \u0026#39;I\u0026#39;: 1, \u0026#39;J\u0026#39;: 1}, \u0026#39;F\u0026#39; : {\u0026#39;A\u0026#39;: 1, \u0026#39;B\u0026#39;: 3, \u0026#39;C\u0026#39;: 1, \u0026#39;D\u0026#39;: 3, \u0026#39;E\u0026#39;: 2, \u0026#39;G\u0026#39;: 3, \u0026#39;H\u0026#39;: 1, \u0026#39;I\u0026#39;: 2, \u0026#39;J\u0026#39;: 3}, \u0026#39;G\u0026#39; : {\u0026#39;A\u0026#39;: 2, \u0026#39;B\u0026#39;: 3, \u0026#39;C\u0026#39;: 1, \u0026#39;D\u0026#39;: 1, \u0026#39;E\u0026#39;: 1, \u0026#39;F\u0026#39;: 3, \u0026#39;H\u0026#39;: 1, \u0026#39;I\u0026#39;: 3, \u0026#39;J\u0026#39;: 2}, \u0026#39;H\u0026#39; : {\u0026#39;A\u0026#39;: 2, \u0026#39;B\u0026#39;: 3, \u0026#39;C\u0026#39;: 1, \u0026#39;D\u0026#39;: 1, \u0026#39;E\u0026#39;: 2, \u0026#39;F\u0026#39;: 1, \u0026#39;G\u0026#39;: 1, \u0026#39;I\u0026#39;: 1, \u0026#39;J\u0026#39;: 2}, \u0026#39;I\u0026#39; : {\u0026#39;A\u0026#39;: 1, \u0026#39;B\u0026#39;: 2, \u0026#39;C\u0026#39;: 2, \u0026#39;D\u0026#39;: 3, \u0026#39;E\u0026#39;: 1, \u0026#39;F\u0026#39;: 2, \u0026#39;G\u0026#39;: 3, \u0026#39;H\u0026#39;: 1, \u0026#39;J\u0026#39;: 1}, \u0026#39;J\u0026#39; : {\u0026#39;A\u0026#39;: 1, \u0026#39;B\u0026#39;: 1, \u0026#39;C\u0026#39;: 2, \u0026#39;D\u0026#39;: 2, \u0026#39;E\u0026#39;: 1, \u0026#39;F\u0026#39;: 3, \u0026#39;G\u0026#39;: 2, \u0026#39;H\u0026#39;: 2, \u0026#39;I\u0026#39;: 1}} ¬†Une application concr√®te des graphes : l\u0026rsquo;arbre couvrant minimal Supposons que chaque sommet du graphe pr√©c√©dent repr√©sente les n≈ìuds d\u0026rsquo;un r√©seau que l\u0026rsquo;on souhait relier √† moindre co√ªt. Ces sommets peuvent √™tre des villes que l\u0026rsquo;on veut relier √©lectriquement, des champs √† irriguer, des serveurs √† relier, etc. Les diff√©rents poids des ar√™tes mat√©rialisent la difficult√© ou le co√ªt de la liaison entre les deux sommets.\nComment trouver facilement le moyen de relier tout le monde en minimisant les co√ªts ? Il faut trouver un arbre couvrant minimal du graphe.\nUn arbre couvrant est un arbre (graphe sans cycle) qui rejoint tous les sommets d\u0026rsquo;un graphe connexe.\nL\u0026rsquo;arbre couvrant minimal est l\u0026rsquo;arbre couvrant dont la somme des poids des ar√™tes est minimale.\nChercher une solution par force brute devient rapidement impossible quand le nombre de sommets du graphe augmente. La formule de Cayley nous dit qu\u0026rsquo;il y aura $n^{n-2}$ arbres couvrants d\u0026rsquo;un graphe complet connexe comportant n sommets (avec seulement 100 sommets, cela fait plus de possibilit√©s que le nombre d\u0026rsquo;atomes dans l\u0026rsquo;univers).\n Quelle serait donc le type de complexit√© d\u0026rsquo;une exploration par force brute de tous les arbres couvrants ?\n a : logarithmique en n b : polynomiale en n c : exponentielle en n   Gr√¢ce √† l'algorithme de Prim, on peut trouver l\u0026rsquo;arbre couvrant minimal d\u0026rsquo;un graphe connexe pond√©r√© en temps raisonable !\nMais commen√ßons d\u0026rsquo;abord par construire une fonction qui v√©rifie si un graphe est connexe ou non.\nPour cela, on va utiliser l'algorithme de parcours en profondeur (Deep-First Search) sur le graphe √† tester en partant d\u0026rsquo;un sommet quelconque et v√©rifier que tous les sommets sont visit√©s.\nfrom collections import deque def parcours_profondeur(G,depart): pile = deque() pile.append(depart) Sommets = [] Vus = [] while pile : sommet = pile.pop() if not sommet in Vus : pile += G[sommet] Vus.append(sommet) Sommets.append(sommet) return Sommets  Construisez la fonction verifConnexe qui v√©rifie si un graphe est connexe ou non.\nVous utiliserez la fonction parcours_profondeur dans votre code.\nVous pourrez ensuite tester ci-dessous si votre fonction fait le travail sur les deux listes d\u0026rsquo;adjacence G_la et Gt_la.\nDans le premier cas, le graphe est √©videmment connexe, et on a construit le deuxi√®me pour qu\u0026rsquo;il ne le soit pas.\n def verifConnexe(G): \u0026#34;\u0026#34;\u0026#34; verifConnexe(G : dict) -\u0026gt; bool pr√©condition : G est un graphe sous la forme d\u0026#39;une liste d\u0026#39;adjacence repr√©sent√©e par un dictionnaire comme ci-dessus postcondition : la fonction retourne True si le graphe est connexe, False sinon \u0026#34;\u0026#34;\u0026#34; # VOTRE CODE # Construction d\u0026#39;un graphe G_nc non connexe G_nc = nx.Graph() G_nc.add_nodes_from([i for i in range(1,9)]) color_map = [\u0026#39;red\u0026#39; if node \u0026lt;=4 else \u0026#39;green\u0026#39; for node in G_nc] G_nc.add_edges_from([(1, 2), (1, 3),(2,4),(1,4),(5,7),(6,7),(5,8),(7,8)]) posi = nx.kamada_kawai_layout(G_nc) options = {\u0026#34;node_size\u0026#34;: 200, \u0026#34;node_color\u0026#34;: color_map, \u0026#34;edge_color\u0026#34;: color_map, \u0026#34;linewidths\u0026#34;: 1, \u0026#34;width\u0026#34;: 1, \u0026#34;with_labels\u0026#34;: False, } G_nc_la = nx.to_dict_of_dicts(G_nc) nx.draw(G_nc,posi,**options) print(\u0026#39;G_la est connexe :\u0026#39;,verifConnexe(G_la)) print(\u0026#39;G_nc_la est connexe :\u0026#39;,verifConnexe(G_nc_la)) True\nFalse\nImpl√©mentons maintenant une version lente (quadratique) de l'algorithme de Prim.\nComme Dijkstra, Prim est un algorithme glouton. √Ä chaque it√©ration, il se jette sur l\u0026rsquo;ar√™te de poids le plus faible permettant de traverser la fronti√®re entre l\u0026rsquo;ensemble des sommets d√©j√† inspect√©s et l\u0026rsquo;ensemble des autres. Une fois l\u0026rsquo;ar√™te choisie, on ajoute le sommet non inspect√© qu\u0026rsquo;elle relie √† l\u0026rsquo;ensemble des sommets inspect√©s.\n Int√©grez √† l\u0026rsquo;algorithme ci-dessous une assertion testant si le graphe donn√© en argumant est bien connexe et ajoutez une variable cout √† l\u0026rsquo;algorithme qui enregistre le co√ªt de l\u0026rsquo;arbre final retourn√© et qui devra elle aussi √™tre retourn√©e.\nLa sortie doit donc devenir : return A, cout\n def Prim(G) : \u0026#34;\u0026#34;\u0026#34; Prim(G : dict) -\u0026gt; A : liste de tuples , cout : nombre G est donn√© sous la forme d\u0026#39;une liste d\u0026#39;adjacence impl√©ment√© par un dictionnaire A est une liste d\u0026#39;ar√™tes repr√©sent√©es par un tuple (A,B) o√π A et B sont les deux sommets d√©limitant l\u0026#39;ar√™te cout est le co√ªt de l\u0026#39;arbre A (somme des pond√©ration des ar√™tes constituant A) postcondition : A doit √™tre un arbre couvrant minimal \u0026#34;\u0026#34;\u0026#34; inf = float(\u0026#39;inf\u0026#39;) NX = list(G.keys()) S0 = NX[0] # un dictionnaire n\u0026#39;est pas ordonn√© donc pas indi√ßable d\u0026#39;o√π list() X = [S0] NX.remove(S0) A = [] while NX != [] : # invariant : A est l\u0026#39;arbre couvrant minimal de X Min = inf for S1 in X : for S2 in NX : if G[S1].get(S2,inf) \u0026lt; Min : # get(cl√©,v0) renvoie la valeur li√©e √† la cl√© si la cl√© existe et v0 sinon (permet d\u0026#39;√©viter les \u0026#34;key error\u0026#34;) Min = G[S1][S2] # l√†, on sait que S2 est bien un voisin de S1 Fmin = S2 Dmin = S1 X.append(Fmin) NX.remove(Fmin) A.append((Dmin,Fmin)) return A Tra√ßons maintenant l\u0026rsquo;arbre couvrant minimal trouv√© par Prim.\nA = Prim_corr(G_la) H = nx.Graph() for S in abc[:n] : H.add_node(S) for S1,S2 in A[0] : H.add_edge(S1,S2,weight=10) F = nx.compose(G_complet,H) weights = [5 if F[u][v][\u0026#39;weight\u0026#39;]==10 else 0 for u,v in F.edges()] options = {\u0026#34;font_size\u0026#34;: 20, \u0026#34;font_weight\u0026#34;:\u0026#34;bold\u0026#34;, \u0026#34;node_size\u0026#34;: 1000, \u0026#34;node_color\u0026#34;: \u0026#34;#34A5DA\u0026#34;, \u0026#34;edge_color\u0026#34;: weights, \u0026#34;width\u0026#34;: weights, \u0026#34;edge_cmap\u0026#34;: plt.cm.bwr, \u0026#34;with_labels\u0026#34;: True, \u0026#34;font_color\u0026#34;: \u0026#34;white\u0026#34;, \u0026#34;linewidths\u0026#34;: 1, } fig = plt.figure(figsize=(12, 12)) nx.draw(F,pos=pos,**options) plt.show() Et voil√† ! En deux coups de cuill√®re √† pot, on a trouv√© un arbre couvrant minimal sans s\u0026rsquo;infliger l\u0026rsquo;inspection syst√©matique des $10^8$ arbres couvrants possibles\u0026hellip;\n¬†Lien entre structures de donn√©es et graphes, exemple du tas Le tas (ou file de priorit√©) est une structure de donn√©es permettant d\u0026rsquo;obtenir rapidement le plus petit √©l√©ment d\u0026rsquo;un ensemble. On peut se repr√©senter un tas par un arbre binaire presque complet ordonn√©.\n  Pour impl√©menter un tas, on retranscrit l\u0026rsquo;arbre binaire sous la forme d\u0026rsquo;une liste.\n En vous aidant de la vid√©o ci-dessus, choisir parmi les listes suivantes celle qui peut repr√©senter un tas :\n  a : [3,5,8,5,13,11,9,6,12,15,18,11,12] b : [3,5,8,5,13,7,9,6,12,15,18,11,12,10] c : [3,5,8,5,13,11,9,6,12,15,18,11,11,10,12]   Construire une fonction plusPetitEnfant qui retourne la position du petit enfant d\u0026rsquo;un √©l√©ment dans le tas.\nLa fonction prend en argument le tas (repr√©sent√© sous la forme d\u0026rsquo;une liste) et la position du parent.\nLa fonction retourne la position du plus petit enfant.\nSi l\u0026rsquo;√©l√©ment n\u0026rsquo;a pas d\u0026rsquo;enfant, la fonction retourne None.\nAttention : les positions dans le tas vont de 1 √† n (et non de 0 √† n-1) o√π n est le nombre d\u0026rsquo;√©l√©ments dans le tas\n def plusPetitEnfant(tas,position) : \u0026#34;\u0026#34;\u0026#34; plusPetitEnfant(tas : list, position : int) -\u0026gt; int ou Nonetype \u0026#34;\u0026#34;\u0026#34; # VOTRE CODE Tas = [3,7,8,8,7,9,12,7,8,8,8,10] enfants(Tas,2)  Construire les fonctions insert et extractMin (pour cette derni√®re, pensez √† utiliser plusPetitEnfant).\nOn supposera que le tas ne contient que des entiers.\n def insert(tas,x) : \u0026#34;\u0026#34;\u0026#34; insert(tas : list , x : int) -\u0026gt; Nonetype la fonction doit ajouter un √©l√©ment au tas de mani√®re √† ce qu\u0026#39;il reste un arbre binaire presque complet tout en respectant l\u0026#39;invariant : les valeurs des parents doivent √™tre inf√©rieures √† celles des enfants. la fonction ne retourne rien. \u0026#34;\u0026#34;\u0026#34; # VOTRE CODE def extractMin(tas) : \u0026#34;\u0026#34;\u0026#34; extractMin(tas : list) -\u0026gt; Min : int la fonction doit retirer la racine du tas tout en respectant l\u0026#39;invariant : les valeurs des parents doivent √™tre inf√©rieures √† celles des enfants. \u0026#34;\u0026#34;\u0026#34; # VOTRE CODE Construisons maintenant un tri par tas et montrons qu\u0026rsquo;il est bien plus rapide que le tri par s√©lection dont il est issu.\ndef triParSelection(liste) : n = len(liste) for i in range(n-1) : min = i for j in range(i+1,n) : if liste[j]\u0026lt;liste[min] : min = j if min != i : liste[i], liste[min] = liste[min], liste[i] return L def triParTas(liste) : T = [] Ltrie = [] n = len(liste) for e in liste : insert(T,e) for i in range(n) : Ltrie.append(extractMin(T)) return Ltrie L = [-13,12,5,1,95,4] print(triParSelection(L)) print(triParTas(L)) [-13, 1, 4, 5, 12, 95]\n[-13, 1, 4, 5, 12, 95]\nfrom time import time from random import randint import matplotlib.pyplot as plt plt.style.use(\u0026#39;ggplot\u0026#39;) plt.rcParams[\u0026#39;figure.figsize\u0026#39;] = (15, 5) I, T_trisel, T_tritas = [], [], [] for i in range(100,1000,1) : L = [] L = [randint(0,i) for k in range(i)] start1 = time() triParSelection(L) stop1 = time() T_trisel.append(stop1-start1) start2 = time() triParTas(L) stop2 = time() T_tritas.append(stop2-start2) I.append(i) plt.plot(I,T_trisel,label=\u0026#34;tri par s√©lection\u0026#34;) plt.plot(I,T_tritas,label=\u0026#34;tri par tas\u0026#34;) plt.xlabel(\u0026#39;taille de la liste\u0026#39;) plt.ylabel(\u0026#34;temps d\u0026#39;ex√©cution (s)\u0026#34;) plt.legend() Les graphes nous ont donc ici permis de mettre au point une structure de donn√©es capable d\u0026rsquo;upgrader tout algorithme n√©cessitant une d√©termination r√©p√©t√©e d\u0026rsquo;un plus petit (ou grand) √©l√©ment dans un ensemble.\n¬†Parcours d\u0026rsquo;un graphe D√©tecteur de cycle Les graphes orient√©s sont g√©n√©rallement utilis√©s pour repr√©senter un ensemble de d√©pendances (l\u0026rsquo;ensemble des pr√©requis d\u0026rsquo;un cours, l\u0026rsquo;ensemble des installations n√©cessaires au fonctionnement d\u0026rsquo;un programme, etc\u0026hellip;).\nEt la pr√©sence de cycles dans de tels graphes est synonyme de bloquage (exemple : pour faire la premi√®re t√¢che, vous attendez la seconde, et pour faire la seconde, vous attendez la premi√®re\u0026hellip;). Quelle que soit l\u0026rsquo;application, d√©tecter les cycles est donc primordial pour √©viter de se retrouver dans ce type de situation.\nUne id√©e pour d√©tecter un cycle est d\u0026rsquo;utiliser √† nouveau le parcours en profondeur. Si on tombe sur un sommet d√©j√† explor√© au cours de la progression dans une branche, alors on a affaire √† un cycle.\nPoint important : on suppose ici que les graphes donn√©s en argument √† la fonction sont non orient√©s.\nLe probl√®me que pose ce type de graphe pour la recherche de cycle est la pr√©sence syst√©matique du sommet consid√©r√© dans la liste de ses voisins (si \u0026lsquo;A\u0026rsquo; est le voisin de \u0026lsquo;B\u0026rsquo; alors \u0026lsquo;B\u0026rsquo; est le voisin de \u0026lsquo;A\u0026rsquo;) puisqu\u0026rsquo;un graphe non-orient√© permet les aller-retour.\nEn retirant syst√©matiquement de la liste des voisins d\u0026rsquo;un sommet les sommets dont lui-m√™me est le voisin, on peut s\u0026rsquo;assurer de la pr√©sence d\u0026rsquo;un cycle si le parcours en profondeur rencontre un sommet pr√©sent dans Vus.\nAu final, on oriente le graphe non-orient√© pour √©viter d\u0026rsquo;√™tre pi√©g√© par un aller-retour entre deux voisins\u0026hellip; Et on l\u0026rsquo;oriente de fa√ßon √† s\u0026rsquo;√©loiner du sommet choisi comme point de d√©part.\nExemple : on transforme {'A' : ['B'], 'B' : ['A','C'], 'C' : ['B']} en {'A' : ['B'], 'B' : ['C'], 'C' : []}. Et pour {'A' : ['B','C','D'], 'B' : ['A','C'], 'C' : ['A','B','D'], 'D' : ['A','C']}, il y a trois possibilit√©s suivant qu\u0026rsquo;apr√®s \u0026lsquo;A\u0026rsquo;, on continue avec \u0026lsquo;B\u0026rsquo;, \u0026lsquo;C\u0026rsquo; ou \u0026lsquo;D\u0026rsquo;.  Ajoutez donc √† la fonction un bout de code qui transforme G en l\u0026rsquo;orientant.\n from collections import deque def detecteCycles(G,depart): \u0026#34;\u0026#34;\u0026#34; detecteCycles(G : dict , depart) -\u0026gt; bool depart est une des cl√©s de G detecteCycles doit retourner True si un cycle est rencontr√© \u0026#34;\u0026#34;\u0026#34; pile = deque() pile.append(depart) Sommets = [] Vus = [] # on transforme G en un graphe orient√© # VOTRE CODE while pile : sommet = pile.pop() if not sommet in Vus : Voisins = G[sommet].copy() pile += Voisins Vus.append(sommet) Sommets.append(sommet) else : return True return False  Testez votre fonction sur les trois graphes suivants :\n G1 = {\u0026#39;A\u0026#39; : [\u0026#39;B\u0026#39;], \u0026#39;B\u0026#39; : [\u0026#39;A\u0026#39;,\u0026#39;C\u0026#39;], \u0026#39;C\u0026#39; : [\u0026#39;B\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;], \u0026#39;D\u0026#39; : [\u0026#39;C\u0026#39;,\u0026#39;E\u0026#39;], \u0026#39;E\u0026#39; : [\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;]} G2 = {\u0026#39;A\u0026#39; : [\u0026#39;B\u0026#39;,\u0026#39;E\u0026#39;], \u0026#39;B\u0026#39; : [\u0026#39;A\u0026#39;,\u0026#39;C\u0026#39;], \u0026#39;C\u0026#39; : [\u0026#39;B\u0026#39;,\u0026#39;D\u0026#39;], \u0026#39;D\u0026#39; : [\u0026#39;C\u0026#39;,\u0026#39;E\u0026#39;], \u0026#39;E\u0026#39; : [\u0026#39;A\u0026#39;,\u0026#39;D\u0026#39;]} G3 = {\u0026#39;A\u0026#39; : [\u0026#39;B\u0026#39;,\u0026#39;E\u0026#39;], \u0026#39;B\u0026#39; : [\u0026#39;A\u0026#39;,\u0026#39;C\u0026#39;], \u0026#39;C\u0026#39; : [\u0026#39;B\u0026#39;,\u0026#39;D\u0026#39;], \u0026#39;D\u0026#39; : [\u0026#39;C\u0026#39;], \u0026#39;E\u0026#39; : [\u0026#39;A\u0026#39;]} ¬†Plus court chemin Une autre application ultra importante des graphes : trouver le plus vite possible le plus court chemin entre deux points.\nOn peut presque toujours mod√©liser un d√©placement comme un chemin sur un graphe (ou plut√¥t une cha√Æne dans le cas pr√©sent car nos graphes ne seront pas orient√©s).\nRepr√©sentons par exemple la carte d\u0026rsquo;un petit jeu vid√©o sous forme de graphe.\nPour cela, on transforme chaque lieu possible en un sommet et chaque transition possible d\u0026rsquo;un point √† un autre comme une ar√™te.\nCr√©ons une petite carte de 20 cases sur 20 avec des d√©placements possibles horizontaux, verticaux mais aussi diagonaux d\u0026rsquo;une case √† une cas voisine.\nTous les arcs re√ßoivent d\u0026rsquo;abord le m√™me poids de 1.\ncarte = {} imax = 20 jmax = 20 for i in range(imax) : for j in range(jmax) : poids_voisins = {} if i \u0026gt; 0 : poids_voisins[(i-1,j)] = 1 if j \u0026gt; 0 : poids_voisins[(i,j-1)] = 1 if i \u0026gt; 0 and j \u0026gt; 0 : poids_voisins[(i-1,j-1)] = 1 if i \u0026lt; imax-1 : poids_voisins[(i+1,j)] = 1 if j \u0026lt; jmax-1 : poids_voisins[(i,j+1)] = 1 if i \u0026lt; imax-1 and j \u0026lt; jmax-1 : poids_voisins[(i+1,j+1)] = 1 carte[(i,j)] = poids_voisins Compliquons notre carte en y rajoutant diff√©rents environnements : des m√©r√©cages o√π il est difficile de se mouvoir et des murs infranchissables.\nPour mod√©liser les m√©r√©cages on va modifier les pond√©rations : on augmente le poids des ar√™tes amenant √† des sommets s\u0026rsquo;y trouvant. Et pour les murs, on va retirer du graphe les sommets s\u0026rsquo;y trouvant.\n# mar√©cages limites_marecages = ((5,19),(5,12)) # s\u0026#39;√©tendent de 5 √† 19 en largeur, et de 5 √† 12 en hauteur for sommet in carte.keys() : for voisin in carte[sommet].keys() : i,j = voisin if limites_marecages[0][0]\u0026lt;=i\u0026lt;=limites_marecages[0][1] and limites_marecages[1][0]\u0026lt;=j\u0026lt;=limites_marecages[1][1] : carte[sommet][voisin] = 5 # murs (on retire les sommets concern√©s (y compris des voisins)) limites_murs = ((17,11),(16,11),(15,11),(17,12),(16,12),(15,12),(15,13),(15,14),(15,15),(15,16),(15,17),(15,18),(14,18),(13,18),(12,18),(11,18),(11,17)) # chaque couple (a,b) correspond aux coordonn√©es d\u0026#39;une case de mur for sommet in carte.copy().keys() : for voisin in carte[sommet].copy().keys() : i,j = voisin if (i,j) in limites_murs : del carte[sommet][voisin] for sommet in carte.copy().keys() : i,j = sommet if (i,j) in limites_murs : del carte[sommet] D√©finissons les sommets de d√©part et d\u0026rsquo;arriv√©e.\ndepart = (2,2) arrivee = (17,16) Et construsions enfin une fonction permettant de tracer la carte en faisant appara√Ætre les mar√©cages, les murs et les points de d√©part et d\u0026rsquo;arriv√©e.\nimport matplotlib.pyplot as plt from matplotlib.patches import Rectangle plt.style.use(\u0026#39;seaborn\u0026#39;) fig, ax = plt.subplots(figsize=(15,15)) coul_bords = (0/255,110/255,118/255) coul_marec = (155/255,207/255,255/255) coul_prairie = (214/255,232/255,147/255) coul_murs = (0.3,0.3,0.3) coul_depart = (39/255,187/255,40/255) coul_arrivee = (255/255,25/255,0/255) coul_chemin = (255/255,209/255,247/255) def trace_terrain(dim,dep,arr,marec,murs) : for i in range(dim[0]) : for j in range(dim[1]) : ax.add_patch(Rectangle((i, j), 1, 1, edgecolor = coul_bords, facecolor = coul_prairie, fill=True, lw=2)) for i in range(marec[0][0],marec[0][1]+1) : for j in range(marec[1][0],marec[1][1]+1) : ax.add_patch(Rectangle((i, j), 1, 1, edgecolor = coul_bords, facecolor = coul_marec, fill=True, lw=2)) for coord in murs : ax.add_patch(Rectangle((coord[0], coord[1]), 1, 1, edgecolor = coul_bords, facecolor = (0.3,0.3,0.3), fill=True, lw=2)) ax.add_patch(Rectangle(dep, 1, 1, edgecolor = coul_bords, facecolor = coul_depart, fill=True, lw=2)) ax.add_patch(Rectangle(arr, 1, 1, edgecolor = coul_bords, facecolor = coul_arrivee, fill=True, lw=2)) ax.autoscale_view() trace_terrain((20,20),depart,arrivee,limites_marecages,limites_murs) Recherche en largeur Utilisons l'algorithme de recherche en largeur (Breadth-First Search ou BFS) vu en cours pour tenter de trouver la plus petite cha√Æne de sommets reliant le d√©part √† l\u0026rsquo;arriv√©e.\ndef recherche_largeur(G,depart,arrivee): file = [(depart,[depart])] Vus = [] while file : sommet,chemin = file.pop(0) if sommet == arrivee : return chemin,Vus if not sommet in Vus : for s in G[sommet] : nv_chemin = chemin+[s] file.append((s,nv_chemin)) Vus.append(sommet) return False Cha√Æne obtenue :\nrecherche_largeur(carte,depart,arrivee)[0] [(2, 2),(3, 2),(4, 2),(5, 2),(6, 2),(7, 2),(8, 2),(9, 2),(10, 3),(11, 4),(12, 5),(13, 6),(14, 7),\n(15, 8),(16, 9),(17, 10),(18, 11),(18, 12),(18, 13),(17, 13),(17, 14),(17, 15),(17, 16)]\nTra√ßons la cha√Æne en rose sur la carte :\ntrace_terrain((20,20),depart,arrivee,limites_marecages,limites_murs) for sommet in recherche_largeur(carte,depart,arrivee)[0][1:-1] : ax.add_patch(Rectangle(sommet,1, 1,edgecolor=coul_bords,facecolor=coul_chemin,fill=True,lw=2)) fig On constate donc que la recherche en largeur trouve un chemin tr√®s court qui √©vite bien le mur.\nVisualisons aussi (en les blanchissant) l\u0026rsquo;ensemble des sommets inspect√©s par l\u0026rsquo;algorithme pour trouver son chemin.\ntrace_terrain((20,20),depart,arrivee,limites_marecages,limites_murs) for sommet in recherche_largeur(carte,depart,arrivee)[1] : ax.add_patch(Rectangle(sommet,1,1,edgecolor=coul_bords,facecolor=(1,1,1,0.8),fill=True,lw=2)) fig Quasiment toute la carte a √©t√© inspect√©e\u0026hellip;\n R√©pondez aux trois questions suivantes :\n le chemin trouv√© est-il le plus court possible ind√©pendemment des pond√©rations ? le chemin trouv√© est-il le plus court possible si on prend en compte les pond√©rations? l\u0026rsquo;algorithme est-il efficace en terme de nombre de sommets inspect√©s ?   ¬†Dijkstra Passons de la recherche en largeur √† l\u0026rsquo;algorithme de Dijkstra. On utilise l\u0026rsquo;impl√©mentation du cours avec des tas (file de priorit√©) fournis par le module heapq.\nimport heapq def Dijkstra(G, depart, arrivee): Scores = {sommet: float(\u0026#39;inf\u0026#39;) for sommet in G} Preds = {sommet : None for sommet in G} Scores[depart] = 0 Vus = [] tas = [(0, depart)] while tas : score_actuel, sommet_actuel = heapq.heappop(tas) if sommet_actuel == arrivee : return Preds,Scores,Vus if score_actuel \u0026lt;= Scores[sommet_actuel]: score_voisin = G[sommet_actuel] for voisin in score_voisin.keys(): if voisin not in Vus : Vus.append(voisin) score = score_actuel + score_voisin[voisin] if score \u0026lt; Scores[voisin]: Scores[voisin] = score Preds[voisin] = sommet_actuel heapq.heappush(tas, (score, voisin)) Preds = Dijkstra(carte,depart,arrivee)[0]  D√©finissez une fonction qui reconstitue la plus petite cha√Æne √† partir de la liste des pr√©d√©cesseurs fournie par Dijkstra.\n def reconstruction_chaine(predecesseurs,depart,arrivee) : \u0026#34;\u0026#34;\u0026#34; reconstruction_chemin(predecesseur : dict , depart : tuple , arrivee : tuple) -\u0026gt; chemin : liste de tuples predecesseur est un dictionnaire qui pour chaque cl√© sous forme de tuple (x,y) (un des sommets) donne son pr√©d√©cesseur l√† aussi sous forme de tuple (x\u0026#39;,y\u0026#39;). la liste retourn√©e, chaine, doit contenir la liste des sommets (chaque sommet est un tuple (x,y)) allant du depart √† l\u0026#39;arrivee. \u0026#34;\u0026#34;\u0026#34; chaine = [depart] s = arrivee # VOTRE CODE return chaine chaine_Dijk = reconstruction_chaine(Preds,depart,arrivee) V√©rifiez que votre cha√Æne est bien la m√™me que celle ci-dessous :\nchaine_Dijk = [(2, 2),(16, 16),(16, 17),(16, 18),(16, 19),(15, 19),(14, 19),(13, 19),(12, 19),(11, 19),(10, 18),(9, 17),(8, 16),(7, 15),(6, 14),(5, 13),(4, 12),(3, 11),(2, 10),(2, 9),(2, 8),(2, 7),(2, 6),(2, 5),(2, 4),(2, 3),(2, 2)] Tra√ßons la cha√Æne obtenue.\ntrace_terrain((20,20),depart,arrivee,limites_marecages,limites_murs) for sommet in chaine_Dijk[1:-1] : ax.add_patch(Rectangle(sommet,1,1,edgecolor=coul_bords,facecolor=coul_chemin,fill=True,lw=2)) fig On constate que le chemin trouv√© par Dijkstra prend maintenant soin de contourner le mar√©cage.\ntrace_terrain((20,20),depart,arrivee,limites_marecages,limites_murs) for sommet in Dijkstra(carte,depart,arrivee)[2] : ax.add_patch(Rectangle(sommet,1,1,edgecolor=coul_bords,facecolor=(1,1,1,0.8),fill=True,lw=2)) fig √Ä nouveau, une grande partie de la carte est inspect√©e.\n R√©pondez aux trois questions suivantes :\n le chemin trouv√© est-il le plus court possible ind√©pendemment des pond√©rations ? le chemin trouv√© est-il le plus court possible si on prend en compte les pond√©rations? l\u0026rsquo;algorithme est-il efficace en terme de nombre de sommets inspect√©s ?   ¬†Ajout d\u0026rsquo;une heuristique Pour am√©liorer la vitesse des algorithmes pr√©c√©dents, on va leur ajouter une heuristique. Une heuristique est une petite recette, une r√®gle simple, que l\u0026rsquo;algorithme va suivre pour s\u0026rsquo;√©conomiser des √©tapes.\nLe point noir des algorithmes pr√©c√©dents est qu\u0026rsquo;ils semblent contraints de parcourir quasiment toute la carte avant d\u0026rsquo;√™tre s√ªr d\u0026rsquo;avoir trouv√© le bon chemin.\nOn va les aider en les guidant vers l\u0026rsquo;arriv√©e.\nL\u0026rsquo;heuristique va donc consister √† guider le choix du prochain sommet de mani√®re √† ce qu\u0026rsquo;il diminue la distance jusqu\u0026rsquo;√† l\u0026rsquo;arriv√©e. On le dirrige en quelque sorte ves sa destination\u0026hellip;\nImpl√©mentons donc une fonction distance qui donne la distance entre deux sommets A et B.\nMais quelle distance ? Plusieurs d√©finition non √©quivalentes sont pssibles : distance euclidienne, distance de Manhattan\u0026hellip;\nIci, on va utiliser la distance de Tchebychev qui correspond √† la distance sur un √©chiquier o√π les mouvements en diagonale co√ªte 1.\ndef distance(A,B) : x_A,y_A = A x_B,y_B = B X = abs(x_B-x_A) Y = abs(y_B-y_A) return max(X,Y) Impl√©mentons maintenant une variante de la recherche en largeur qui int√®gre l\u0026rsquo;heuristique gr√¢ce √† un tas : pour chaque nouveau voisin inspect√©, on calcule sa distance √† l\u0026rsquo;arriv√©e puis on l\u0026rsquo;ajoute √† un tas avec cette distance comme cl√© de classement.\nOn s\u0026rsquo;assure ainsi √† chaque it√©ration de retirer du tas le sommet rapprochant le plus de la destination finale.\nIl s\u0026rsquo;agit √† nouveau d\u0026rsquo;un algorithme glouton.\nimport heapq def bfs_glouton(G,depart,arrivee) : tas = [(0, depart)] Vus = [] Preds = dict() Preds[depart] = None while tas : dist_actuelle, sommet_actuel = heapq.heappop(tas) # on retire le sommet le plus proche de l\u0026#39;arriv√©e if sommet_actuel == arrivee : return Preds,Vus for voisin in G[sommet_actuel]: if voisin not in Vus : Vus.append(voisin) if voisin not in Preds: dist = distance(arrivee, voisin) heapq.heappush(tas, (dist, voisin)) # on place dans le tas le voisin affubl√© de sa distance Preds[voisin] = sommet_actuel bfs_glouton(carte,depart,arrivee) chaine_glouton = reconstruction_chaine(bfs_glouton(carte,depart,arrivee)[0],depart,arrivee) trace_terrain((20,20),depart,arrivee,limites_marecages,limites_murs) for sommet in chaine_glouton[1:-1] : ax.add_patch(Rectangle(sommet,1,1,edgecolor=coul_bords,facecolor=coul_chemin,fill=True,lw=2)) fig On voit que le chemin se dirige tout de suite vers l\u0026rsquo;arriv√©e, jusqu\u0026rsquo;√† rencontrer un mur\u0026hellip;\ntrace_terrain((20,20),depart,arrivee,limites_marecages,limites_murs) for sommet in bfs_glouton(carte,depart,arrivee)[1] : ax.add_patch(Rectangle(sommet,1,1,edgecolor=coul_bords,facecolor=(1,1,1,0.8),fill=True,lw=2)) fig Le nombre de sommets inspect√©s a spectaculairement diminu√© !\n R√©pondez aux trois questions suivantes :\n le chemin trouv√© est-il le plus court possible ind√©pendemment des pond√©rations ? le chemin trouv√© est-il le plus court possible si on prend en compte les pond√©rations? l\u0026rsquo;algorithme est-il efficace en terme de nombre de sommets inspect√©s ?   ¬†A* Appliquons maintenant l\u0026rsquo;heuristique √† l\u0026rsquo;algorithme de Dijkstra. On obtient l'algorithme A* (A √©toile ou A star).\ndef Astar(G, depart, arrivee): Scores = {sommet: float(\u0026#39;inf\u0026#39;) for sommet in G} Preds = {sommet : None for sommet in G} Scores[depart] = 0 Vus = [] tas = [(0, 0, depart)] while tas : _, score_actuel, sommet_actuel = heapq.heappop(tas) # on utilise par convention \u0026#39;_\u0026#39; pour d√©baller un √©l√©ment d\u0026#39;un tuple dont on ne fera pas usage. if sommet_actuel == arrivee : return Preds,Scores,Vus if score_actuel \u0026lt;= Scores[sommet_actuel]: score_voisin = G[sommet_actuel] for voisin in score_voisin.keys(): if voisin not in Vus : Vus.append(voisin) score = score_actuel + score_voisin[voisin] if score \u0026lt; Scores[voisin]: Scores[voisin] = score Preds[voisin] = sommet_actuel heuristique = score + distance(voisin,arrivee) heapq.heappush(tas, (heuristique, score, voisin)) chaine_Astar = reconstruction_chaine(Astar(carte,depart,arrivee)[0],depart,arrivee) trace_terrain((20,20),depart,arrivee,limites_marecages,limites_murs) for sommet in chaine_Astar[1:-1] : ax.add_patch(Rectangle(sommet,1,1,edgecolor=coul_bords,facecolor=coul_chemin,fill=True,lw=2)) fig trace_terrain((20,20),depart,arrivee,limites_marecages,limites_murs) for sommet in Astar(carte,depart,arrivee)[2] : ax.add_patch(Rectangle(sommet,1,1,edgecolor=coul_bords,facecolor=(1,1,1,0.8),fill=True,lw=2)) fig  R√©pondez aux trois questions suivantes :\n le chemin trouv√© est-il le plus court possible ind√©pendemment des pond√©rations ? le chemin trouv√© est-il le plus court possible si on prend en compte les pond√©rations? l\u0026rsquo;algorithme est-il efficace en terme de nombre de sommets inspect√©s ?   "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/semestre_1/tp7image/",
	"title": "TP 7 : matrices de pixels et image",
	"tags": [],
	"description": "",
	"content": "Tableau de pixels et images Importer une image PIL (python imaging library) est l\u0026rsquo;une des librairies Python permettant de manipuler des fichiers image. On va l\u0026rsquo;utiliser en association avec numpy qui est le module de choix pour jouer avec des tableaux num√©riques.\nfrom PIL import Image import urllib.request # pour r√©cup√©rer une image sur le web from IPython.display import display # pour afficher dans le notebook import matplotlib.pyplot as plt import numpy as np plt.rcParams[\u0026#34;figure.figsize\u0026#34;] = (15,10) urllib.request.urlretrieve(\u0026#39;https://i.redd.it/quqjmqmi44q51.jpg\u0026#39;, \u0026#39;girafe\u0026#39;) # r√©cup√©ration du fichier image image_girafe = np.array(Image.open(\u0026#39;girafe\u0026#39;)) # le fichier est convertie en un tableau numpy girafe = Image.fromarray(image_girafe) # le tableau est converti en un objet image display(girafe) # affichage On a r√©cup√©r√© les donn√©es de l\u0026rsquo;image dans un tableau √† trois dimensions numpy.\nLes deux premi√®res dimensions correspondent aux coordonn√©es spatiales du pixel et l\u0026rsquo;indexation d\u0026rsquo;un tableau numpy autorise l\u0026rsquo;utilisation de virgules pour imiter les coordonn√©es math√©matiques (mais les x et les y sont invers√©s car il s\u0026rsquo;agit de matrices et on commence toujours par indexer les lignes avant les colonnes). Le pixel ayant la coordonn√©e cart√©sienne $(x,y)$ avec une origine $(0,0)$ en haut √† gauche va donc correspondre √† l\u0026rsquo;√©l√©ment image[y,x] (on peut aussi, comme avec les listes python, obtenir l\u0026rsquo;√©l√©ment via image[y][x]).\nEt √† chacun de ses pixels correspond un tableau de 3 entiers compris entre 0 et 255 codant la couleur du pixel (codage rgb, un nombre pour l\u0026rsquo;intensit√© du rouge, un pour l\u0026rsquo;intensit√© du vert et le dernier pour le bleu). C\u0026rsquo;est la 3e dimension du tableau.\nprint(image_girafe.shape) (1263, 843, 3)\nhauteur, largeur, _ = image_girafe.shape print(f\u0026#39;largeur : {largeur} pixels, hauteur : {hauteur} pixels\u0026#39;) largeur : 843 pixels, hauteur : 1263 pixel\nprint(image_girafe[20,700]) print(image_girafe[20][700]) [96 96 60]\n[96 96 60]\n¬†Codage RGB RGB pour Red Green Blue (RVB en fran√ßais) est un syst√®me de codage informatique des couleurs. Il repose sur la synth√®se additive et suit donc le m√™me principe que le codage des couleurs dans notre cerveau √† partir des signaux envoy√©s par trois cellules sp√©cialis√©es tapissant nos r√©tines, les cones, chacune ayant un spectre d\u0026rsquo;absorption centr√© sur les longueurs d\u0026rsquo;onde correspondantes √† l\u0026rsquo;une des trois couleurs, rouge, vert ou bleu.\nlongueur = 400 synthese = np.zeros([longueur, longueur, 3], dtype=np.uint8) # cr√©ation d\u0026#39;un tableau de dimension 3 (2 dimensions spatiales + la couleur) dont les entr√©es sont des entiers non sign√©s cod√©s sur 8 bits taille = longueur//2 x1,y1 = longueur//8,5*longueur//16 x2,y2 = longueur//4,longueur//8 x3,y3 = 3*longueur//8,3*longueur//8 synthese[y1:y1+taille,x1:x1+taille] = [255, 0, 0] synthese[y2:y2+taille,x2:x2+taille] = [0, 255, 0] synthese[y3:y3+taille,x3:x3+taille] = [0, 0, 255] affichage = Image.fromarray(synthese) display(affichage) On voit qu\u0026rsquo;il manque √† l\u0026rsquo;image les zones de superposition.\n Modifier l\u0026rsquo;image synthese pour reproduire la figure suivante.\n Faisons notre propre exp√©rience physique de synth√®se additive en codant des zones o√π les pixels alternent 2 couleurs primaires :\nlargeur = 900 hauteur = 300 synth_phy = np.zeros([hauteur, largeur, 3], dtype=np.uint8) for i in range(hauteur) : for j in range(largeur//3) : if (i+j)%2 : synth_phy[i,j] = [255,0,0] else : synth_phy[i,j] = [0,255,0] for i in range(hauteur) : for j in range(largeur//3,2*largeur//3) : if (i+j)%2 : synth_phy[i,j] = [0,0,255] else : synth_phy[i,j] = [0,255,0] for i in range(hauteur) : for j in range(2*largeur//3,largeur) : if (i+j)%2 : synth_phy[i,j] = [0,0,255] else : synth_phy[i,j] = [255,0,0] synth_phy = Image.fromarray(synth_phy) display(synth_phy) R√©cup√©rons les composantes bleues, vertes et rouges de la photo de girafe :\nimage_R = image_girafe.copy() image_R[:,:,(1,2)] = 0 # √©quivalent √† : # for i in range(hauteur) : # for j in range(largeur) : # image_R[i][j][1] = 0 # image_R[i][j][2] = 0 image_G = image_girafe.copy() image_G[:,:,(0,2)] = 0 image_B = image_girafe.copy() image_B[:,:,(0,1)] = 0 rvb = np.concatenate((image_R, image_G, image_B), axis=1) rvb = Image.fromarray(rvb) display(rvb) La superposition des trois filtres reproduit les couleurs d\u0026rsquo;origine.\nimage_rec = image_B.copy() image_rec[:,60:500] += image_G[:,60:500] image_rec[75:650,:] += image_R[75:650,:] image_rec = Image.fromarray(image_rec) display Dans le codage RGB utilis√© aujourd\u0026rsquo;hui, l\u0026rsquo;intensit√© de chacune des 3 couleurs primaires est cod√©e sur un octet (8 bits), ce qui permet une profondeur de 24 bits pour diff√©rentier les couleurs.\n Combien de couleurs sont alors repr√©sentables par ce syst√®me ?\n Fabriquons une image contenant toutes ces couleurs.\nL\u0026rsquo;id√©e est de fabriquer d\u0026rsquo;abord une image $256\\times 256$ contenant toutes les nuances possibles de vert et rouge, de l\u0026rsquo;agrandir d\u0026rsquo;un facteur 16 de mani√®re √† qu\u0026rsquo;une combinaison rouge/vert unique corresponde √† un gros pixel de $16\\times16$. Et on additionne √† chacun de ces gros pixels une image $16\\times16$ bleu contenant les 256 teintes de bleu dispos√©es en spirale.\nL\u0026rsquo;image rouge/verte est assez simple √† coder (l\u0026rsquo;ex√©cution met un peu de temps) :\nL1 = 4096 rougevert = np.zeros([L1, L1, 3], dtype=np.uint8) for r in range(256*16) : for g in range(256*16) : rougevert[r,g]=[r//16,g//16,0] plt.imshow(rougevert) Fabriquer la spirale bleue est plus dur\u0026hellip;\nL\u0026rsquo;image doit faire $16\\times16$ et contenir toutes les nuances de bleu. On commence en haut √† gauche (x=0 et y=0) par du noir (0,0,0), et on progresse dans le sens des aiguilles d\u0026rsquo;une montre en ajoutant 1 √† l\u0026rsquo;intensit√© du bleu √† chaque pixel successif de la spirale pour finir au centre (en position x=7, y=8 pour √™tre pr√©cis) par un pixel 100% bleu (0,0,255).\n Construisez la spirale bleue (du moins la matrice qui sera repr√©sent√©e par la spirale bleue).\n # vous appellerez votre image \u0026#34;bleu\u0026#34; L2 = 16 bleu = np.zeros([L2, L2, 3], dtype=np.uint8) ### VOTRE CODE plt.imshow(bleu) # cette commande devra afficher une image similaire √† celle de l\u0026#39;√©nonc√© ! longueur = 4096 rougevertbleu = np.zeros([longueur, longueur, 3], dtype=np.uint8) for i in range(0,4096,16) : for j in range(0,4096,16) : rougevertbleu[i:i+16,j:j+16] = rougevert[i:i+16,j:j+16]+bleu rougevertbleu = Image.fromarray(rougevertbleu) display(rougevertbleu) Les premi√®res consoles de jeu avaient des graphismes de 6 bits (de profondeur). Plut√¥t que 256 possibilit√©s pour chaque sous-pixel, on en √©tait r√©duit √† seulement 4 choix (2 bits).\n D√©finissez une fonction permettant de convertir l\u0026rsquo;image de la giraffe en 6 bits.\n def sixbit(image) : \u0026#34;\u0026#34;\u0026#34; prend en argument un tableau numpy √† 3 dimensions () obtenu comme plus haut via np.array(Image.open(\u0026#39;nom\u0026#39;)) et renvoie un nouveau tableau de m√™mes dimensions correspondant √† une conversion en 6 bits de l\u0026#39;image (chacune des 3 couleurs doit maintant n\u0026#39;avoir que 4 valeurs d\u0026#39;intensit√© possibles uniform√©ment r√©parties). \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE girafe = Image.fromarray(sixbit(image_girafe)) display(girafe) On peut tr√®s facilement inverser les couleurs de l\u0026rsquo;image. Une ligne suffit :\nimage_inv = 255-image_girafe image_inv = Image.fromarray(image_inv) display(image_inv) Construire une fonction NB qui retourne une version \u0026ldquo;niveau de gris\u0026rdquo; de l\u0026rsquo;image donn√©e en argument.\nPrincipe de la man≈ìuvre : $(r,g,b)\\rightarrow (\\frac{r+g+b}{3},\\frac{r+g+b}{3},\\frac{r+g+b}{3})$\ndef NB(image) : \u0026#34;\u0026#34;\u0026#34; prend en argument un tableau numpy √† 3 dimensions () obtenu comme plus haut via np.array(Image.open(\u0026#39;nom\u0026#39;)) et renvoie un nouveau tableau correspondant √† une conversion en niveau de gris de l\u0026#39;image. \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE giraffe_NB = Image.fromarray(NB(image_girafe)) display(giraffe_NB) ¬†Transformation d\u0026rsquo;une image  Construisez une fonction recadrage qui prend en argument l\u0026rsquo;image √† recadrer, les coordonn√©es du coin sup√©rieur gauche du nouveau cadre (sous la forme d\u0026rsquo;un tuple (x,y)), la largeur et la hauteur du nouveau cadre.\nFaites en sorte que recadrage(image_girafe,(30,50),500,600) recadre la t√™te de la girafe comme ci-dessous.\n def recadrage(image,xy_coin,l_cadre,h_cadre) : \u0026#34;\u0026#34;\u0026#34; prend en argument un tableau numpy √† 3 dimensions (hauteur,largeur,3) obtenu comme plus haut via np.array(Image.open(\u0026#39;nom\u0026#39;)) et renvoie un nouveau tableau √† 3 dimensions (h_cadre,l_cadre,3). L\u0026#39;argument xy_coin est un tuple (x,y) o√π x et y sont des entiers correspondants aux coordonn√©es du coin sup√©rieur gauche du nouveau cadre. l_cadre et h_cadre √©tant des nombres de pixels, ils doivent √™tre entiers. \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE affichage = Image.fromarray(recadrage(image_girafe,(30,50),500,600)) display(affichage)  Construisez ensuite une fonction rotation qui tourne l\u0026rsquo;image de 90¬∞ vers la gauche en modifiant la disposition des pixels.\n def rotation(image) : \u0026#34;\u0026#34;\u0026#34; prend en argument un tableau numpy √† 3 dimensions (hauteur,largeur,3) obtenu comme plus haut via np.array(Image.open(\u0026#39;nom\u0026#39;)) et renvoie un nouveau tableau correspondant √† l\u0026#39;image tourn√©e de 90¬∞ vers la gauche. \u0026#34;\u0026#34;\u0026#34; ### VOTRE CODE affichage = Image.fromarray(rotation(image_girafe)) display(affichage) On peut aussi s\u0026rsquo;amuser avec les sym√©tries :\nimage_sym = np.copy(image_girafe) for i in range(min(hauteur,largeur)) : for j in range(min(hauteur,largeur)) : image_sym[i][j]=image_sym[j][i] affichage = Image.fromarray(image_sym) display(affichage) ¬†Traitement d\u0026rsquo;image (filtrage) On va maintenant passer √† des transormations plus √©volu√©es :\n flou am√©lioration de la nettet√© d√©tection des contours  Elles reposent sur des convolutions dont la recette est la suivante :\n une petite matrice, la matrice de convolution, appel√©e noyau, est choisie, on balaye l\u0026rsquo;image √† traiter avec un cadre ayant la taille de la matrice, √† l\u0026rsquo;int√©rieur du cadre, on multiplie chacune des valeurs d\u0026rsquo;intensit√© des pixels par le coefficient correspondant de la matrice, on somme tous ces produits et on attribue la valeur au pixel au centre du cadre.  Suivant le noyau utilis√©, on va modifier l\u0026rsquo;image de diff√©rentes fa√ßons.\n¬†Floutage L\u0026rsquo;id√©e va √™tre de moyenner la valeur des pixels √† l\u0026rsquo;int√©rieur du bloc gr√¢ce √† la matrice F suivante :\n$$ F=\\frac{1}{9}\\begin{pmatrix}1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\\end{pmatrix} $$ Cela revient √† passer l\u0026rsquo;image dans un filtre passe-bas (= un moyenneur).\nEn effet, la valeur de l\u0026rsquo;intensit√© d\u0026rsquo;un pixel sera maintenant une moyenne entre tous ses voisins.\ndef conv_np(A,B) : l = len(A) C = np.zeros((l-2, l-2),dtype=int) for i in range(3) : for j in range(3) : C += B[i,j]*A[i:l-2+i,j:l-2+j] return C A = np.array([[2,2,2,2,2], [2,1,1,1,2], [2,1,3,4,2], [2,1,2,1,2], [2,2,3,2,2]]) B = np.array([[1,0,1], [0,2,0], [1,0,1]]) C = conv_np(A,B) print(C) [[11 11 11] [ 9 10 15] [12 13 12]]   Que valent les √©l√©ments $c_{ij}$ de la matrice $C$ donn√©e par conv_np(A,B) ?\n  a : $\\sum_{k=1}^{3}a_{ik}b_{kj}$ b : $\\sum_{i=1}^{3}\\sum_{j=1}^{3}a_{(5-i)(5-j)}b_{ij}$ c : $\\sum_{i=1}^{3}\\sum_{j=1}^{3}a_{(i+1)(j+1)}b_{ij}$  La fonction suivante r√©alise la m√™me t√¢che. Elle est moins rapide, mais permet de jouer avec des matrices $B$ plus grandes que $3\\times 3$ gr√¢ce √† l\u0026rsquo;introduction du param√®tre marge.\ndef conv(A,B,marge) : A = A.astype(np.int16) hauteur, largeur = A.shape C = A.copy() for i in range(marge,hauteur-marge) : for j in range(marge,largeur-marge) : C[i,j] = (A[i-marge:i+marge+1,j-marge:j+marge+1]*B).sum() return C On va ainsi pouvoir contr√¥ler l\u0026rsquo;intensit√© du floutage en liant la taille de la matrice $B$ au param√®tre force.\ndef flou(image,force) : \u0026#34;\u0026#34;\u0026#34; flou(image,intensite_flou)-\u0026gt;image_floue image doit √™tre un tableau dimension d\u0026#39;entier non sign√©s cod√©s sur 8 bits intensit√©_flou est un entier \u0026gt;= 1 image_floue est du m√™me type qu\u0026#39;image \u0026#34;\u0026#34;\u0026#34; taille = 2*force+1 # taille de la matrice F F = np.ones((taille,taille))*1/taille**2 # matrice pour la convolution marge = (taille-1)//2 image_floue = image.copy() hauteur,largeur = image_floue.shape image_floue = conv(image,F,marge) image_floue = image_floue.astype(np.uint8) return image_floue urllib.request.urlretrieve(\u0026#39;https://fichier0.cirkwi.com/image/photo/poi/800x500/545297/fr/0.jpg\u0026#39;, \u0026#39;LaR\u0026#39;) image = np.array(Image.open(\u0026#39;LaR\u0026#39;)) hauteur,largeur,_ = image.shape LaR = np.zeros([hauteur, largeur]) # on associe maintenant √† chaque pixel un seul chiffre : l\u0026#39;intensit√© de gris (entre 0 et 255) LaR = NB(image)[:,:,0] # il suffit de r√©cup√©rer une des 3 couleurs de la conversion en niveau de gris de l\u0026#39;image affichage = Image.fromarray(LaR) display(affichage) LaR_floues = (LaR,) # un singulet n√©cessite cette petite virgule pour √™tre reconnu for i in range(1,5) : LaR_floues += (flou(LaR,i),) comparaison = np.concatenate(LaR_floues, axis=1) affichage = Image.fromarray(comparaison) display(affichage) Les matrices F utilis√©es dans les 4 images flout√©es : $\\frac{1}{9}\\begin{pmatrix}1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\\end{pmatrix}$,$\\frac{1}{16}\\begin{pmatrix}1\u0026amp;1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\u0026amp;1\\end{pmatrix}$,$\\frac{1}{25}\\begin{pmatrix}1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\end{pmatrix}$,$\\frac{1}{36}\\begin{pmatrix}1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\end{pmatrix}$.\nPlus la matrices est grande, plus on moyenne de points voisins, plus le flou est important\u0026hellip;\n¬†Am√©lioration de la nettet√© On ne veut maintenant plus moyenner, mais au contraire accentuer les diff√©rences.\nPour cela, on choisit un noyau $N$ qui r√©compense les variations entre pixels voisins et est sans effet dans les zones de m√™mes teintes : $$N=\\begin{pmatrix}0\u0026amp;-1\u0026amp;0\\\\-1\u0026amp;5\u0026amp;-1\\\\0\u0026amp;-1\u0026amp;0\\end{pmatrix}$$\n Sur le mod√®le de la fonction flou, mais en plus simple, car pas besoin ici de s\u0026rsquo;emb√™ter avec une marge variable (conv_np est donc utilisable), compl√©tez la d√©finition de la fonction net qui renvoie le r√©sultat d\u0026rsquo;une image convolu√©e par $N$.\n def net(image) : \u0026#34;\u0026#34;\u0026#34; net(image)-\u0026gt;image_nette \u0026#34;\u0026#34;\u0026#34; image = image.astype(np.int32) ### VOTRE CODE # on fixe les valeurs qui ont d√©pass√© 255 √† 255 et celles sous 0 √† 0. image_nette[image_nette\u0026lt;0] = 0 image_nette[image_nette\u0026gt;255] = 255 image_nette = image_nette.astype(np.uint8) return image_nette LaR_nette = net(LaR_floues[1]) comparaison = np.concatenate((LaR_floues[1][1:-1,1:-1],LaR_nette), axis=1) affichage = Image.fromarray(comparaison) display(affichage) ¬†D√©tection de contour (filtre de Sobel) On va agir en deux temps, gr√¢ce √† deux noyaux.\nLe premier, $S_x$, va donner des valeurs d\u0026rsquo;autant plus loin de $0$ qu\u0026rsquo;il y a un fort gradient horizontal dans le bloc $3\\times3$ de l\u0026rsquo;image inspect√©e.\nEt l\u0026rsquo;autre, $S_y$, va mettre en valeur les gradients verticaux.\n$S_x = \\begin{pmatrix}-1\u0026amp;0\u0026amp;1\\\\-2\u0026amp;0\u0026amp;2\\\\-1\u0026amp;0\u0026amp;1\\end{pmatrix}$ et $S_y = \\begin{pmatrix}1\u0026amp;2\u0026amp;1\\\\0\u0026amp;0\u0026amp;0\\\\-1\u0026amp;-2\u0026amp;-1\\end{pmatrix}$\n$S_x$ fait la diff√©rence entre les voisins de droite et ceux de gauche quand $S_y$ fait la diff√©rence entre les voisins du dessus et ceux de dessous.\ndef grad_x(image) : image = image.astype(np.int32) Sx = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]) image_gradx = conv_np(image,Sx) # les gradients peuvent tr√®s bien √™tre n√©gatifs. On translate alors toutes les valeurs pour que la plus basse soit z√©ro. image_gradx = image_gradx - np.min(image_gradx) # on normalise ensuite en faisant en sorte que la plus haute valeur vaille 255 image_gradx = image_gradx/np.max(image_gradx)*255 image_gradx = image_gradx.astype(np.uint8) return image_gradx  √âcrivez la fonction grad_y sur le m√™me mod√®le :\n def grad_y(image) : ### VOTRE CODE Gx = grad_x(LaR) Gy = grad_y(LaR) comparaison = np.concatenate((Gx,Gy), axis=0) affichage = Image.fromarray(comparaison) display(affichage) Le gradient global $G$ s\u0026rsquo;obtient en \u0026ldquo;pythagorisant\u0026rdquo; Gx et Gy : $G=\\sqrt{G_x^2+G_y^2}$.\nRemarque : cela revient finalement √† appliquer un filtre passe-haut √† l\u0026rsquo;image.\ndef grad(image) : Gx = grad_x(image).astype(np.int32) Gy = grad_y(image).astype(np.int32) image_grad = np.sqrt(Gx**2+Gy**2) image_grad = image_grad/np.max(image_grad)*255 image_grad = image_grad.astype(np.uint8) return image_grad affichage = Image.fromarray(grad(LaR)) display(affichage) L\u0026rsquo;effet de relief est rendu par l\u0026rsquo;information sur la direction du gradient, information inutile si le contour est tout ce qui nous int√©resse (que l\u0026rsquo;on passe d\u0026rsquo;une forte intensit√© √† une faible ou l\u0026rsquo;inverse d√©tecte un contour dans les deux cas).\nOn va donc reprendre les d√©finitions en prenant les valeurs absolues des gradients.\ndef grad_abs_x(image) : image = image.astype(np.int32) Sx = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]) image_gradx = np.abs(conv_np(image,Sx)) image_gradx = image_gradx/np.max(image_gradx)*255 image_gradx = image_gradx.astype(np.uint8) return image_gradx def grad_abs_y(image) : image = image.astype(np.int32) Sy = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]]) image_grady = np.abs(conv_np(image,Sy)) image_grady = image_grady/np.max(image_grady)*255 image_grady = image_grady.astype(np.uint8) return image_grady def contour(image) : Gx = gradabs_x(image).astype(np.int32) Gy = gradabs_y(image).astype(np.int32) image_cont = np.sqrt(Gx**2+Gy**2) image_cont = image_cont/np.max(image_cont)*255 image_cont = image_cont.astype(np.uint8) return image_cont affichage = Image.fromarray(contour(LaR)) display(affichage)  Parmi les images suivantes num√©rot√©es de 1 √† 4, laquelle est produite par :\n  A : grad_x(echiquier) B : grad_abs_y(echiquier) C : contour(echiquier) D : grad(echiquier) o√π echiquier est l\u0026rsquo;image suivante :  Quand on joue avec des images, les erreurs de code donne parfois des r√©sultats √©tonnants. N\u0026rsquo;h√©sitez pas √† enregistrer/copier vos bizarreries, s\u0026rsquo;il y en a. Je r√©compenserai la plus belle/tordue.\nCi-dessous, un √©chec faisant tomber la pluie sur La Rochelle\u0026hellip; "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/python/divers/",
	"title": "Divers",
	"tags": [],
	"description": "",
	"content": "Divers Commentaires Tous les langages de programmations permettent d\u0026rsquo;introduire des commentaires dans le code qui servent d\u0026rsquo;aides et de rep√®res √† celui qui lit le code, mais qui sont ignor√©s lors de l\u0026rsquo;ex√©cution.\nEn Python, les commentaires sont introduits par le symbole di√®se (hashtag) #.\n¬†Utilisation de print print est la premi√®re fonction native que l\u0026rsquo;on rencontre. C\u0026rsquo;est une fonction √† effet de bord : elle ne retourne rien (elle est de type None), mais elle permet d\u0026rsquo;afficher une cha√Æne de caract√®res, ou le contenu d\u0026rsquo;une variable, quel que soit son type.\nnom = \u0026#39;Joe\u0026#39; age = 212 print(nom,\u0026#39;a\u0026#39;,age,\u0026#39;ans.\u0026#39;) Joe a 212 ans.\nDe plus, print affiche par d√©faut un retour √† la ligne.\nLes caract√®res d\u0026rsquo;√©chapement font partie de la cha√Æne de caract√®res, mais sont interpr√©t√©s par print comme des commandes. Le plus utilis√© est le retour √† la ligne \\n.\nprint(\u0026#34;a\\nb\\nc\u0026#34;) a\nb\nc\nBien que non exigible, l\u0026rsquo;utilisation des f-strings, introduites depuis Python 3.6, peut s\u0026rsquo;av√©rer tr√®s pratique. Les f-strings permettent d\u0026rsquo;inserrer des variables dans des cha√Ænes de caract√®res et de les mettre en forme avec une syntaxe minimale.\nPour les utiliser, il suffit de mettre un f devant la cha√Æne de caract√®res et de placer chaque variable entre accolade.\nprint(f\u0026#39;{nom} a {age} ans.\u0026#39;) print(f\u0026#39;{nom = }, {age = }) # tr√®s pratique pour les jeux de tests Joe a 212 ans.\nnom = 'Joe', age = 212\n¬†Importation de modules import module Pour importer le module machin, il suffit d\u0026rsquo;√©crire import machin. Chaque fonction contenue dans le module devra alors √™tre appl√©e en utilisant la notation point : machin.fonction (le point d√©signe ici une relation d\u0026rsquo;appartenance caract√©ristique de la programmation orient√©e objet).\nimport math print(f\u0026#39;{math.sqrt(2) = }\u0026#39;) math.sqrt(2) = 1.4142135623730951\n¬†import module as X Lorsqu\u0026rsquo;on utilise fr√©quemment un module, il est pratique d\u0026rsquo;abr√©ger son nom. Pour cela, on ajoute le raccourci souhait√© apr√®s un as lors de l\u0026rsquo;import : import machin as mch.\nimport numpy as np import matplotlib.pyplot as plt X = np.linspace(-np.pi,np.pi,100) Y = np.sin(X) plt.plot(X,Y) ¬†from module import x,y On peut aussi r√©cup√©rer uniquement certaines fonctions ou variables d\u0026rsquo;un module afin d\u0026rsquo;y avoir acc√®s directement (sans utiliser machin.).\nfrom math import pi,cos print(f\u0026#39;{cos(pi) = }\u0026#39;) cos(pi) = -1.0\n¬†from module import * Lorsqu\u0026rsquo;on est s√ªr que cela ne va pas poser probl√®me, on peut importer tout le contenu du module de la m√™me mani√®re. On utilise alors l\u0026rsquo;√©toile * qui signifie \u0026ldquo;tout\u0026rdquo;.\nCe type d\u0026rsquo;import est n√©anmoins d√©conseill√© √† moins de tr√®s bien conna√Ætre le contenu du module. Le danger est que dans l\u0026rsquo;ensemble de ce qui est import√©, il peut se trouver des variables ou des fonctions ayant un nom d√©j√† attribu√©. L\u0026rsquo;import r√©affectera alors ces variables contre notre gr√© et sans nous le dire.\nd = 8 e = 2 from math import * print(sqrt(d ** e)) 16.88210319127114\n¬†Manipulation de fichier texte Ouvrir et fermer un fichier Un objet file est cr√©√© par l\u0026rsquo;utilisation de la fonction open(nom du fichier,mode) qui prend deux arguments.\nf = open(\u0026#39;monfichier.txt\u0026#39;,\u0026#39;w\u0026#39;)   Le premier argument, nom du fichier, est une cha√Æne contenant le nom du fichier. Ce nom peut √™tre donn√© avec le chemin d\u0026rsquo;acc√®s absolu ou seulement l\u0026rsquo;arborescence relative au dossier dans lequel le programme est ex√©cut√©.\nEn √©crivant un nom sans chemin, le fichier se trouve dans le r√©pertoire courant.\n  Le deuxi√®me argument, mode, est une cha√Æne d\u0026rsquo;un ou deux caract√®res d√©crivant la fa√ßon dont le fichier est utilis√©.\nmode peut √™tre r quand le fichier n\u0026rsquo;est acc√©d√© qu\u0026rsquo;en lecture, w en √©criture seulement (un fichier existant portant le m√™me nom sera alors √©cras√©) et a ouvre le fichier en mode ajout (toute donn√©e √©crite dans le fichier est automatiquement ajout√©e √† la fin). r+ ouvre le fichier en mode lecture/√©criture. L\u0026rsquo;argument mode est optionnel, sa valeur par d√©faut est r.\nb coll√© √† la fin du mode indique que le fichier doit √™tre ouvert en mode binaire c\u0026rsquo;est-√†-dire que les donn√©es sont lues et √©crites sous forme d\u0026rsquo;octets (type bytes). Ce mode est √† utiliser pour les fichiers contenant autre chose que du texte.\n  Les objets file sont ferm√©s gr√¢ce √† la m√©thode close() : f.close() par exemple. Python ferme les fichiers automatiquement lorsque le programme se termine.\n¬†√âcrire dans un fichier La m√©thode write() d\u0026rsquo;un objet file √©crit une cha√Æne de caract√®res dans le fichier et renvoie le nombre de caract√®res inscrits.\nf.write(\u0026#39;Coucou monde !\u0026#39;) 14\nPlus pratique, la fonction native print() peut accepter en argument un objet file. Plut√¥t que d\u0026rsquo;√™tre affich√©e sur le shell, la sortie de print() est alors redirig√©e vers ce fichier.\nprint(\u0026#39;\\nKill all humans\u0026#39;, file=f) f.close() Exemple : le programme suivant √©crit les quatre premi√®res puissances de tous les entiers entre 1 et 1000, chaque champ √©tant s√©par√© par une virgule, dans le fichier puissances.txt.\nfi = open(\u0026#39;puissances.txt\u0026#39;,\u0026#39;w\u0026#39;) for i in range(1,1001) : print(i, i**2, i**3, i**4, sep=\u0026#39;, \u0026#39;, file=fi) fi.close() ¬†Lire un fichier Pour lire n bytes d\u0026rsquo;un fichier, on utilise f.read(n). En omettant n, tout le fichier est lu.\nreadline() lit une seule ligne d\u0026rsquo;un fichier jusqu\u0026rsquo;au, en l\u0026rsquo;incluant, caract√®re \\n de nouvelle ligne. Un nouvel appel de readline() lit la ligne suivante et ainsi de suite.\nread() et readline() renvoie toutes les deux une cha√Æne vide lorsque la fin du fichier est atteinte.\nPour lire en une fois toutes les lignes dans une liste de cha√Ænes, on utilise f.readlines().\nLes objet file sont it√©rables. On peut ainsi retourner chaque ligne d\u0026rsquo;un fichier une √† une en utilisant une boucle :\nf = open(\u0026#39;monfichier.txt\u0026#39;) for ligne in f : print(ligne, end=\u0026#39;\u0026#39;) f.close() Coucou monde !\n.\n.\n.\nKill all humans\nComme ligne contient d√©j√† le caract√®re de nouvelle ligne lorsqu\u0026rsquo;elle est lue, on utilise end = '' pour emp√™cher print d\u0026rsquo;en ajouter un autre.\nCette m√©thode de lecture ligne √† ligne est √† privil√©gier pour les gros fichiers √† moins de vraiment vouloir contenir en m√©moire l\u0026rsquo;ensemble du fichier.\nGr√¢ce √† la m√©thode split, on peut transformer un texte en une liste de ces √©l√©ments. L‚Äôargument de split correspond aux caract√®res utilis√©s comme s√©parateur. Par d√©faut il s‚Äôagit du caract√®re d‚Äôespacement ' ' (si on veut d√©couper un texte en paragraphe, on utilisera le caract√®re d‚Äô√©chappement de retour √† la ligne \\n).\nfo = open(\u0026#39;monfichier.txt\u0026#39;) texte = fo.read() liste1 = texte.split(\u0026#39;\\n\u0026#39;) liste2 = texte.split() print(liste1) print(liste2) fo.close() ['Coucou monde !', '.', '.', '.', 'Kill all humans']\n['Coucou', 'monde', '!', '.', '.', '.', 'Kill', 'all', 'humans']\nPour lire les nombres du fichier 'puissance.txt' √©crit pr√©c√©demment, les colonnes doivent √™tre converties en une liste d\u0026rsquo;entiers.\nPour cela, chaque ligne doit √™tre d√©compos√©e en ses diff√©rents champs et chaque champ explicitement converti en entier gr√¢ce √† int() :\nfo = open(\u0026#39;puissances.txt\u0026#39;) carr√©s, cubes, puiss4 = [],[],[] lignes = fo.readlines() fo.close() for ligne in lignes : champs = ligne.split(\u0026#39;,\u0026#39;) carr√©s.append(int(champs[1])) cubes.append(int(champs[2])) puiss4.append(int(champs[3])) n = 500 print(n, \u0026#39;au cube vaut\u0026#39;, cubes[n-1]) 500 au cube vaut 125000000\nMais en pratique, il vaut mieux utiliser les biblioth√®ques NumPy ou Pandas pour des fichiers de donn√©es comme celui-ci.\nVous apprendrez aussi au 3e trimestre √† utiliser les m√©thodes des bases de donn√©es.\n ¬†Les assertions Les assertions sont un moyen simple de s‚Äôassurer, avant de continuer, qu‚Äôune condition est respect√©e.\nOn utilise la syntaxe : assert test. Si le test renvoie True, l‚Äôex√©cution se poursuit normalement. Sinon, une exception AssertionError est lev√©e.\nOn peut utiliser les assertions pour s‚Äôassurer que les arguments d‚Äôune fonction vont permettre son ex√©cution.\nOn peut par exemple s√©curiser la d√©finition d\u0026rsquo;une fonction racines donnant les racines d\u0026rsquo;un trin√¥me du second degr√©. On va s‚Äôassurer que les arguments pass√©s sont bien des nombres (et renvoyer un message explicatif si ce n‚Äôest pas le cas) :\nimport math def racines(a,b,c) : \u0026#34;\u0026#34;\u0026#34;Retourne les racines de ax^2 + bx + c\u0026#34;\u0026#34;\u0026#34; type_nombre = (float,int) assert (type(a) in type_nombre) and (type(b) in type_nombre) and (type(c) in type_nombre),\u0026#34;les arguments doivent √™tre des nombres !\u0026#34; d = b**2 - 4*a*c r1 = (-b - math.sqrt(d))/2/a r2 = (-b + math.sqrt(d))/2/a return r1, r2 racines(1,6,5) retourne (-5.0, -1.0), mais racines(1,6,'5') l√®ve l\u0026rsquo;erreur suivante :\nAssertionError: les arguments de la fonction racines doivent √™tre des nombres !\n"
},
{
	"uri": "https://info-tsi-vieljeux.github.io/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "But Comp√©tences vis√©es (d\u0026rsquo;apr√®s le BO) :  analyser et modeÃÅliser un probleÃÄme ou une situation, notammant en utilisant les objets conceptuels de l\u0026rsquo;informatique pertinents (table relationnelle, graphe, dictionnaire, etc.)¬†; imaginer et concevoir une solution, d√©composer en blocs, se ramener √† des sous-probl√®mes simples et ind√©pendants, adopter une strat√©gie appropri√©e, d√©crire une d√©marche, un algorithme ou une structure de donn√©es permettant de r√©soudre le probl√®me¬†; d√©crire et sp√©cifier les caract√©ristiques d‚Äôun processus, les donn√©es d‚Äôun probl√®me, ou celles manipul√©es par un algorithme ou une fonction¬†; mettre en ≈ìuvre une solution, par la traduction d‚Äôun algorithme ou d‚Äôune structure de donn√©es dans un langage de programmation ou un langage de requ√™te¬†; justifier et critiquer une solution, que ce soit en d√©montrant un algorithme par une preuve math√©matique ou en d√©veloppant des processus d‚Äô√©valuation, de contr√¥le, de validation d‚Äôun code que l‚Äôon a produit¬†; communiquer √† l‚Äô√©crit ou √† l‚Äôoral, pr√©senter des travaux informatiques, une probl√©matique et sa solution ; d√©fendre ses choix ; documenter sa production et son impl√©mentation.  Pr√©alable Pour le fonctionnement des 3 prochains trimestres, il faut que vous ayez :\n un compte Google (ancien ou cr√©√© pour l\u0026rsquo;occasion) pour pouvoir utiliser Colaboratory un compte Github o√π seront cr√©√©s les reopositories des TP (r√©pertoires √† l\u0026rsquo;historique sauvegard√©).   La vid√©o suivante pr√©sente le protocole √† suivre pour √™tre op√©rationnel :\n  ¬†D√©roulement Pour chaque TP, on suivra la d√©marche suivante :\n Vous trouverez un lien √† cliquer au d√©but de l\u0026rsquo;√©nonc√© du TP sur ce site web. Il s\u0026rsquo;agit d\u0026rsquo;une invitation g√©n√©rer par Github Classroom. En acceptant l'\u0026ldquo;assignment\u0026rdquo; (le travail demand√©), un nouveau repository est cr√©√© sur Github.\nIl contient un ou plusieurs fichiers notebook python (d\u0026rsquo;extension \u0026ldquo;.ipynb\u0026rdquo;) produits par l\u0026rsquo;application Jupyter notebook. Ce sont ces fichiers qu\u0026rsquo;il va falloir modifier pour gagner des points. Un notebook est d√©coup√© en cellules qui peuvent contenir soit du texte et des images, soit du code. Chaque cellule peut s\u0026rsquo;ex√©cuter individuellement et fait alors tourner le code qu\u0026rsquo;elle contient, mais Github n\u0026rsquo;est pas encore capable d\u0026rsquo;interagir avec un notebook aujourd\u0026rsquo;hui.\nOn passe par une solution en ligne pour y pallier : Colaboratory (ou Colab). Pour transiter de Github √† Colab, la d√©marche est tr√®s simple (sur le papier\u0026hellip;) : une fois qu\u0026rsquo;on a cliqu√© sur le notebook, il suffit de modifier l\u0026rsquo;adresse url en ajoutant \u0026ldquo;tocolab\u0026rdquo; apr√®s github (\u0026lsquo;https://github.com/blablabla/tpx.ipynb' $\\rightarrow$ \u0026lsquo;https://githubtocolab.com/blablabla/tpx.ipynb' ). Si pour une raison ou une autre, vous n\u0026rsquo;arrivez pas √† passer de Github √† Colab directement, il y a une autre m√©thode, un peu moins confortable, mais qui fonctionnera √† coup s√ªr : vous t√©l√©chargez le notebook depuis github sur votre disque (pour cela, il faut d\u0026rsquo;abord cliquer sur Raw pour acc√©der au code source, puis sauvegarder la page en prenant soin que le navigateur n\u0026rsquo;ajoute pas une extension apr√®s le .ipynb), puis vous l\u0026rsquo;importez depuis Colab.  Le vrai travail commence alors. Des consignes sont diss√©min√©es dans le notebook et il faudra modifier les cellules en fonction de ce qui est demand√©. G√©n√©ralement, l\u0026rsquo;endroit o√π une modification est attendu est clairement indiqu√© par le commentaire # VOTRE CODE. Tout est ex√©cutable, ce qui veut dire que vous pouvez tester imm√©diatement vos modifications. Vous pouvez aussi ajouter autant de cellules que souhait√©, o√π vous le souhaitez.\nSeules les cellules de test contenant les commentaires # Cellule de test, ne pas modifier ne doivent en aucun cas √™tre modifi√©es ou supprim√©es. Pour √™tre valid√©es, vos modifications devront √™tre sauvegard√©es dans le repo github du TP. Depuis Colab, il suffit th√©oriquement d\u0026rsquo;aller sur Fichier \u0026gt; Enregistrer une copie dans Github, puis de s√©lectionner le repo du TP.\nL\u0026rsquo;autre solution est d\u0026rsquo;enregistrer le fichier modifi√© sur le disque (Fichier \u0026gt; T√©l√©charger \u0026gt; T√©l√©charger le fichier .ipynb) puis de le glisser sur la fen√™tre Github du repo (ou de cliquer sur Add file \u0026gt; Upload files). Pensez alors √† commiter (= cliquer sur le bouton vert commit) pour valider.\nAttention, il ne faut pas cr√©er un autre fichier ! C\u0026rsquo;est le notebook portant le nom initial qui sera ramass√© et corrig√© une fois le temps imparti pour le TP √©coul√©.  Aide  La partie Feedback du repository du TP, cach√© dans l\u0026rsquo;onglet Pull requests, permet de me demander de l\u0026rsquo;aide en dehors des TP. Ou vous pouvez m\u0026rsquo;envoyer un mail √† l\u0026rsquo;adresse suivante : cordier.info @ protonmail.ch  "
},
{
	"uri": "https://info-tsi-vieljeux.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://info-tsi-vieljeux.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]